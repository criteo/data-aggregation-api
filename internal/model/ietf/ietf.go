/*
Package ietf is a generated package which contains definitions
of structs which represent a YANG schema. The generated schema can be
compressed by a series of transformations (compression was false
in this case).

This package was generated by /home/k.petremann/repos/criteo/github/data-aggregation-api/.build/ygot/genutil/names.go
using the following YANG input files:
	- yang/standard/ietf/RFC/ietf-system.yang
	- yang/standard/ietf/RFC/ietf-snmp.yang
	- yang/standard/ietf/RFC/ietf-snmp-community.yang
Imported modules were sourced from:
	- yang/...
	- deps/...
*/
package ietf

import (
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/openconfig/ygot/ygot"
	"github.com/openconfig/goyang/pkg/yang"
	"github.com/openconfig/ygot/ytypes"
)

// Binary is a type that is used for fields that have a YANG type of
// binary. It is used such that binary fields can be distinguished from
// leaf-lists of uint8s (which are mapped to []uint8, equivalent to
// []byte in reflection).
type Binary []byte

// YANGEmpty is a type that is used for fields that have a YANG type of
// empty. It is used such that empty fields can be distinguished from boolean fields
// in the generated code.
type YANGEmpty bool

// UnionInt8 is an int8 type assignable to unions of which it is a subtype.
type UnionInt8 int8

// UnionInt16 is an int16 type assignable to unions of which it is a subtype.
type UnionInt16 int16

// UnionInt32 is an int32 type assignable to unions of which it is a subtype.
type UnionInt32 int32

// UnionInt64 is an int64 type assignable to unions of which it is a subtype.
type UnionInt64 int64

// UnionUint8 is a uint8 type assignable to unions of which it is a subtype.
type UnionUint8 uint8

// UnionUint16 is a uint16 type assignable to unions of which it is a subtype.
type UnionUint16 uint16

// UnionUint32 is a uint32 type assignable to unions of which it is a subtype.
type UnionUint32 uint32

// UnionUint64 is a uint64 type assignable to unions of which it is a subtype.
type UnionUint64 uint64

// UnionFloat64 is a float64 type assignable to unions of which it is a subtype.
type UnionFloat64 float64

// UnionString is a string type assignable to unions of which it is a subtype.
type UnionString string

// UnionBool is a bool type assignable to unions of which it is a subtype.
type UnionBool bool

// UnionUnsupported is an interface{} wrapper type for unsupported types. It is
// assignable to unions of which it is a subtype.
type UnionUnsupported struct {
	Value interface{}
}

var (
	SchemaTree map[string]*yang.Entry
	ΛEnumTypes map[string][]reflect.Type
)

func init() {
	var err error
	initΛEnumTypes()
	if SchemaTree, err = UnzipSchema(); err != nil {
		panic("schema error: " +  err.Error())
	}
}

// Schema returns the details of the generated schema.
func Schema() (*ytypes.Schema, error) {
	uzp, err := UnzipSchema()
	if err != nil {
		return nil, fmt.Errorf("cannot unzip schema, %v", err)
	}

	return &ytypes.Schema{
		Root: &Device{},
		SchemaTree: uzp,
		Unmarshal: Unmarshal,
	}, nil
}

// UnzipSchema unzips the zipped schema and returns a map of yang.Entry nodes,
// keyed by the name of the struct that the yang.Entry describes the schema for.
func UnzipSchema() (map[string]*yang.Entry, error) {
	var schemaTree map[string]*yang.Entry
	var err error
	if schemaTree, err = ygot.GzipToSchema(ySchema); err != nil {
		return nil, fmt.Errorf("could not unzip the schema; %v", err)
	}
	return schemaTree, nil
}

// Unmarshal unmarshals data, which must be RFC7951 JSON format, into
// destStruct, which must be non-nil and the correct GoStruct type. It returns
// an error if the destStruct is not found in the schema or the data cannot be
// unmarshaled. The supplied options (opts) are used to control the behaviour
// of the unmarshal function - for example, determining whether errors are
// thrown for unknown fields in the input JSON.
func Unmarshal(data []byte, destStruct ygot.GoStruct, opts ...ytypes.UnmarshalOpt) error {
	tn := reflect.TypeOf(destStruct).Elem().Name()
	schema, ok := SchemaTree[tn]
	if !ok {
		return fmt.Errorf("could not find schema for type %s", tn )
	}
	var jsonTree interface{}
	if err := json.Unmarshal([]byte(data), &jsonTree); err != nil {
		return err
	}
	return ytypes.Unmarshal(schema, destStruct, jsonTree, opts...)
}

// Device represents the /device YANG schema element.
type Device struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Nacm	*IETFNetconfAcm_Nacm	`path:"nacm" module:"ietf-netconf-acm"`
	ΛNacm	[]ygot.Annotation	`path:"@nacm" ygotAnnotation:"true"`
	Snmp	*IETFSnmp_Snmp	`path:"snmp" module:"ietf-snmp"`
	ΛSnmp	[]ygot.Annotation	`path:"@snmp" ygotAnnotation:"true"`
	System	*IETFSystem_System	`path:"system" module:"ietf-system"`
	ΛSystem	[]ygot.Annotation	`path:"@system" ygotAnnotation:"true"`
	SystemState	*IETFSystem_SystemState	`path:"system-state" module:"ietf-system"`
	ΛSystemState	[]ygot.Annotation	`path:"@system-state" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Device implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Device) IsYANGGoStruct() {}

// GetOrCreateNacm retrieves the value of the Nacm field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateNacm() *IETFNetconfAcm_Nacm {
	if t.Nacm != nil {
		return t.Nacm
	}
	t.Nacm = &IETFNetconfAcm_Nacm{}
	return t.Nacm
}

// GetOrCreateSnmp retrieves the value of the Snmp field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateSnmp() *IETFSnmp_Snmp {
	if t.Snmp != nil {
		return t.Snmp
	}
	t.Snmp = &IETFSnmp_Snmp{}
	return t.Snmp
}

// GetOrCreateSystem retrieves the value of the System field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateSystem() *IETFSystem_System {
	if t.System != nil {
		return t.System
	}
	t.System = &IETFSystem_System{}
	return t.System
}

// GetOrCreateSystemState retrieves the value of the SystemState field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateSystemState() *IETFSystem_SystemState {
	if t.SystemState != nil {
		return t.SystemState
	}
	t.SystemState = &IETFSystem_SystemState{}
	return t.SystemState
}

// GetNacm returns the value of the Nacm struct pointer
// from Device. If the receiver or the field Nacm is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetNacm() *IETFNetconfAcm_Nacm {
	if t != nil && t.Nacm != nil {
		return t.Nacm
	}
	return nil
}

// GetSnmp returns the value of the Snmp struct pointer
// from Device. If the receiver or the field Snmp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetSnmp() *IETFSnmp_Snmp {
	if t != nil && t.Snmp != nil {
		return t.Snmp
	}
	return nil
}

// GetSystem returns the value of the System struct pointer
// from Device. If the receiver or the field System is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetSystem() *IETFSystem_System {
	if t != nil && t.System != nil {
		return t.System
	}
	return nil
}

// GetSystemState returns the value of the SystemState struct pointer
// from Device. If the receiver or the field SystemState is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetSystemState() *IETFSystem_SystemState {
	if t != nil && t.SystemState != nil {
		return t.SystemState
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Device) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Device"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Device) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Device) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Device.
func (*Device) ΛBelongingModule() string {
	return ""
}


// IETFNetconfAcm_Nacm represents the /ietf-netconf-acm/nacm YANG schema element.
type IETFNetconfAcm_Nacm struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	DeniedDataWrites	*uint32	`path:"denied-data-writes" module:"ietf-netconf-acm"`
	ΛDeniedDataWrites	[]ygot.Annotation	`path:"@denied-data-writes" ygotAnnotation:"true"`
	DeniedNotifications	*uint32	`path:"denied-notifications" module:"ietf-netconf-acm"`
	ΛDeniedNotifications	[]ygot.Annotation	`path:"@denied-notifications" ygotAnnotation:"true"`
	DeniedOperations	*uint32	`path:"denied-operations" module:"ietf-netconf-acm"`
	ΛDeniedOperations	[]ygot.Annotation	`path:"@denied-operations" ygotAnnotation:"true"`
	EnableExternalGroups	*bool	`path:"enable-external-groups" module:"ietf-netconf-acm"`
	ΛEnableExternalGroups	[]ygot.Annotation	`path:"@enable-external-groups" ygotAnnotation:"true"`
	EnableNacm	*bool	`path:"enable-nacm" module:"ietf-netconf-acm"`
	ΛEnableNacm	[]ygot.Annotation	`path:"@enable-nacm" ygotAnnotation:"true"`
	ExecDefault	E_IETFNetconfAcm_ActionType	`path:"exec-default" module:"ietf-netconf-acm"`
	ΛExecDefault	[]ygot.Annotation	`path:"@exec-default" ygotAnnotation:"true"`
	Groups	*IETFNetconfAcm_Nacm_Groups	`path:"groups" module:"ietf-netconf-acm"`
	ΛGroups	[]ygot.Annotation	`path:"@groups" ygotAnnotation:"true"`
	ReadDefault	E_IETFNetconfAcm_ActionType	`path:"read-default" module:"ietf-netconf-acm"`
	ΛReadDefault	[]ygot.Annotation	`path:"@read-default" ygotAnnotation:"true"`
	RuleList	*IETFNetconfAcm_Nacm_RuleList_OrderedMap	`path:"rule-list" module:"ietf-netconf-acm"`
	ΛRuleList	[]ygot.Annotation	`path:"@rule-list" ygotAnnotation:"true"`
	WriteDefault	E_IETFNetconfAcm_ActionType	`path:"write-default" module:"ietf-netconf-acm"`
	ΛWriteDefault	[]ygot.Annotation	`path:"@write-default" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFNetconfAcm_Nacm implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFNetconfAcm_Nacm) IsYANGGoStruct() {}

// GetOrCreateGroups retrieves the value of the Groups field
// or returns the existing field if it already exists.
func (t *IETFNetconfAcm_Nacm) GetOrCreateGroups() *IETFNetconfAcm_Nacm_Groups {
	if t.Groups != nil {
		return t.Groups
	}
	t.Groups = &IETFNetconfAcm_Nacm_Groups{}
	return t.Groups
}

// GetGroups returns the value of the Groups struct pointer
// from IETFNetconfAcm_Nacm. If the receiver or the field Groups is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IETFNetconfAcm_Nacm) GetGroups() *IETFNetconfAcm_Nacm_Groups {
	if t != nil && t.Groups != nil {
		return t.Groups
	}
	return nil
}

// GetDeniedDataWrites retrieves the value of the leaf DeniedDataWrites from the IETFNetconfAcm_Nacm
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DeniedDataWrites is set, it can
// safely use t.GetDeniedDataWrites() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DeniedDataWrites == nil' before retrieving the leaf's value.
func (t *IETFNetconfAcm_Nacm) GetDeniedDataWrites() uint32 {
	if t == nil || t.DeniedDataWrites == nil {
		return 0
	}
	return *t.DeniedDataWrites
}

// GetDeniedNotifications retrieves the value of the leaf DeniedNotifications from the IETFNetconfAcm_Nacm
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DeniedNotifications is set, it can
// safely use t.GetDeniedNotifications() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DeniedNotifications == nil' before retrieving the leaf's value.
func (t *IETFNetconfAcm_Nacm) GetDeniedNotifications() uint32 {
	if t == nil || t.DeniedNotifications == nil {
		return 0
	}
	return *t.DeniedNotifications
}

// GetDeniedOperations retrieves the value of the leaf DeniedOperations from the IETFNetconfAcm_Nacm
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DeniedOperations is set, it can
// safely use t.GetDeniedOperations() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DeniedOperations == nil' before retrieving the leaf's value.
func (t *IETFNetconfAcm_Nacm) GetDeniedOperations() uint32 {
	if t == nil || t.DeniedOperations == nil {
		return 0
	}
	return *t.DeniedOperations
}

// GetEnableExternalGroups retrieves the value of the leaf EnableExternalGroups from the IETFNetconfAcm_Nacm
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EnableExternalGroups is set, it can
// safely use t.GetEnableExternalGroups() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EnableExternalGroups == nil' before retrieving the leaf's value.
func (t *IETFNetconfAcm_Nacm) GetEnableExternalGroups() bool {
	if t == nil || t.EnableExternalGroups == nil {
		return true
	}
	return *t.EnableExternalGroups
}

// GetEnableNacm retrieves the value of the leaf EnableNacm from the IETFNetconfAcm_Nacm
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EnableNacm is set, it can
// safely use t.GetEnableNacm() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EnableNacm == nil' before retrieving the leaf's value.
func (t *IETFNetconfAcm_Nacm) GetEnableNacm() bool {
	if t == nil || t.EnableNacm == nil {
		return true
	}
	return *t.EnableNacm
}

// GetExecDefault retrieves the value of the leaf ExecDefault from the IETFNetconfAcm_Nacm
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExecDefault is set, it can
// safely use t.GetExecDefault() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExecDefault == nil' before retrieving the leaf's value.
func (t *IETFNetconfAcm_Nacm) GetExecDefault() E_IETFNetconfAcm_ActionType {
	if t == nil || t.ExecDefault ==  0 {
		return IETFNetconfAcm_ActionType_permit
	}
	return t.ExecDefault
}

// GetReadDefault retrieves the value of the leaf ReadDefault from the IETFNetconfAcm_Nacm
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ReadDefault is set, it can
// safely use t.GetReadDefault() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ReadDefault == nil' before retrieving the leaf's value.
func (t *IETFNetconfAcm_Nacm) GetReadDefault() E_IETFNetconfAcm_ActionType {
	if t == nil || t.ReadDefault ==  0 {
		return IETFNetconfAcm_ActionType_permit
	}
	return t.ReadDefault
}

// GetWriteDefault retrieves the value of the leaf WriteDefault from the IETFNetconfAcm_Nacm
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if WriteDefault is set, it can
// safely use t.GetWriteDefault() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.WriteDefault == nil' before retrieving the leaf's value.
func (t *IETFNetconfAcm_Nacm) GetWriteDefault() E_IETFNetconfAcm_ActionType {
	if t == nil || t.WriteDefault ==  0 {
		return IETFNetconfAcm_ActionType_deny
	}
	return t.WriteDefault
}

// GetOrCreateRuleListMap returns the ordered map field
// RuleList from IETFNetconfAcm_Nacm.
//
// It initializes the field if not already initialized.
func (s *IETFNetconfAcm_Nacm) GetOrCreateRuleListMap() *IETFNetconfAcm_Nacm_RuleList_OrderedMap {
	if s.RuleList == nil {
		s.RuleList = &IETFNetconfAcm_Nacm_RuleList_OrderedMap{}
	}
	return s.RuleList
}

// AppendNewRuleList creates a new entry in the RuleList
// ordered map of the IETFNetconfAcm_Nacm struct. The keys of the list are
// populated from the input arguments.
func (s *IETFNetconfAcm_Nacm) AppendNewRuleList(Name string) (*IETFNetconfAcm_Nacm_RuleList, error) {
	if s.RuleList == nil {
		s.RuleList = &IETFNetconfAcm_Nacm_RuleList_OrderedMap{}
	}
	return s.RuleList.AppendNew(Name)
}

// AppendRuleList appends the supplied IETFNetconfAcm_Nacm_RuleList struct
// to the list RuleList of IETFNetconfAcm_Nacm. If the key value(s)
// specified in the supplied IETFNetconfAcm_Nacm_RuleList already exist in the list, an
// error is returned.
func (s *IETFNetconfAcm_Nacm) AppendRuleList(v *IETFNetconfAcm_Nacm_RuleList) error {
	if s.RuleList == nil {
		s.RuleList = &IETFNetconfAcm_Nacm_RuleList_OrderedMap{}
	}
	return s.RuleList.Append(v)
}

// GetRuleList retrieves the value with the specified key from the
// RuleList map field of IETFNetconfAcm_Nacm. If the receiver
// is nil, or the specified key is not present in the list, nil is returned
// such that Get* methods may be safely chained.
func (s *IETFNetconfAcm_Nacm) GetRuleList(Name string) *IETFNetconfAcm_Nacm_RuleList {
	if s == nil {
		return nil
	}
	key := Name
	return s.RuleList.Get(key)
}

// DeleteRuleList deletes the value with the specified keys from
// the receiver IETFNetconfAcm_Nacm. If there is no such element, the
// function is a no-op.
func (s *IETFNetconfAcm_Nacm) DeleteRuleList(Name string) bool {
	key := Name
	return s.RuleList.Delete(key)
}

// IETFNetconfAcm_Nacm_RuleList_OrderedMap is an ordered map that represents the "ordered-by user"
// list elements at /ietf-netconf-acm/nacm/rule-list.
type IETFNetconfAcm_Nacm_RuleList_OrderedMap struct {
	keys []string
	valueMap map[string]*IETFNetconfAcm_Nacm_RuleList
}

// IsYANGOrderedList ensures that IETFNetconfAcm_Nacm_RuleList_OrderedMap implements the
// ygot.GoOrderedMap interface.
func (*IETFNetconfAcm_Nacm_RuleList_OrderedMap) IsYANGOrderedList() {}

// init initializes any uninitialized values.
func (o *IETFNetconfAcm_Nacm_RuleList_OrderedMap) init() {
	if o == nil {
		return
	}
	if o.valueMap == nil {
		o.valueMap = map[string]*IETFNetconfAcm_Nacm_RuleList{}
	}
}

// Keys returns a copy of the list's keys.
func (o *IETFNetconfAcm_Nacm_RuleList_OrderedMap) Keys() []string {
	if o == nil {
		return nil
	}
	return append([]string{}, o.keys...)
}

// Values returns the current set of the list's values in order.
func (o *IETFNetconfAcm_Nacm_RuleList_OrderedMap) Values() []*IETFNetconfAcm_Nacm_RuleList {
	if o == nil {
		return nil
	}
	var values []*IETFNetconfAcm_Nacm_RuleList
	for _, key := range o.keys {
		values = append(values, o.valueMap[key])
	}
	return values
}

// Len returns a size of IETFNetconfAcm_Nacm_RuleList_OrderedMap
func (o *IETFNetconfAcm_Nacm_RuleList_OrderedMap) Len() int {
	if o == nil {
		return 0
	}
	return len(o.keys)
}

// Get returns the value corresponding to the key. If the key is not found, nil
// is returned.
func (o *IETFNetconfAcm_Nacm_RuleList_OrderedMap) Get(key string) *IETFNetconfAcm_Nacm_RuleList {
	if o == nil {
		return nil
	}
	val, _ := o.valueMap[key]
	return val
}

// Delete deletes an element.
func (o *IETFNetconfAcm_Nacm_RuleList_OrderedMap) Delete(key string) bool {
	if o == nil {
		return false
	}
	if _, ok := o.valueMap[key]; !ok {
		return false
	}
	for i, k := range o.keys {
		if k == key {
			o.keys = append(o.keys[:i], o.keys[i+1:]...)
			delete(o.valueMap, key)
			return true
		}
	}
	return false
}

// Append appends a IETFNetconfAcm_Nacm_RuleList, returning an error if the key
// already exists in the ordered list or if the key is unspecified.
func (o *IETFNetconfAcm_Nacm_RuleList_OrderedMap) Append(v *IETFNetconfAcm_Nacm_RuleList) error {
	if o == nil {
		return fmt.Errorf("nil ordered map, cannot append IETFNetconfAcm_Nacm_RuleList")
	}
	if v == nil {
		return fmt.Errorf("nil IETFNetconfAcm_Nacm_RuleList")
	}
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	if _, ok := o.valueMap[key]; ok {
		return fmt.Errorf("duplicate key for list Statement %v", key)
	}
	o.keys = append(o.keys, key)
	o.init()
	o.valueMap[key] = v
	return nil
}

// AppendNew creates and appends a new IETFNetconfAcm_Nacm_RuleList, returning the
// newly-initialized v. It returns an error if the v already exists.
func (o *IETFNetconfAcm_Nacm_RuleList_OrderedMap) AppendNew(Name string) (*IETFNetconfAcm_Nacm_RuleList, error) {
	if o == nil {
		return nil, fmt.Errorf("nil ordered map, cannot append IETFNetconfAcm_Nacm_RuleList")
	}
	key := Name

	if _, ok := o.valueMap[key]; ok {
		return nil, fmt.Errorf("duplicate key for list Statement %v", key)
	}
	o.keys = append(o.keys, key)
	newElement := &IETFNetconfAcm_Nacm_RuleList{
		Name: &Name,
	}
	o.init()
	o.valueMap[key] = newElement
	return newElement, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFNetconfAcm_Nacm) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFNetconfAcm_Nacm"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFNetconfAcm_Nacm) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFNetconfAcm_Nacm) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFNetconfAcm_Nacm.
func (*IETFNetconfAcm_Nacm) ΛBelongingModule() string {
	return "ietf-netconf-acm"
}


// IETFNetconfAcm_Nacm_Groups represents the /ietf-netconf-acm/nacm/groups YANG schema element.
type IETFNetconfAcm_Nacm_Groups struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Group	map[string]*IETFNetconfAcm_Nacm_Groups_Group	`path:"group" module:"ietf-netconf-acm"`
	ΛGroup	[]ygot.Annotation	`path:"@group" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFNetconfAcm_Nacm_Groups implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFNetconfAcm_Nacm_Groups) IsYANGGoStruct() {}

// NewGroup creates a new entry in the Group list of the
// IETFNetconfAcm_Nacm_Groups struct. The keys of the list are populated from the input
// arguments.
func (t *IETFNetconfAcm_Nacm_Groups) NewGroup(Name string) (*IETFNetconfAcm_Nacm_Groups_Group, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Group == nil {
		t.Group = make(map[string]*IETFNetconfAcm_Nacm_Groups_Group)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Group[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Group", key)
	}

	t.Group[key] = &IETFNetconfAcm_Nacm_Groups_Group{
		Name: &Name,
	}

	return t.Group[key], nil
}

// RenameGroup renames an entry in the list Group within
// the IETFNetconfAcm_Nacm_Groups struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *IETFNetconfAcm_Nacm_Groups) RenameGroup(oldK, newK string) error {
	if _, ok := t.Group[newK]; ok {
		return fmt.Errorf("key %v already exists in Group", newK)
	}

	e, ok := t.Group[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Group", oldK)
	}
	e.Name = &newK

	t.Group[newK] = e
	delete(t.Group, oldK)
	return nil
}

// GetOrCreateGroupMap returns the list (map) from IETFNetconfAcm_Nacm_Groups.
//
// It initializes the field if not already initialized.
func (t *IETFNetconfAcm_Nacm_Groups) GetOrCreateGroupMap() map[string]*IETFNetconfAcm_Nacm_Groups_Group {
	if t.Group == nil {
		t.Group = make(map[string]*IETFNetconfAcm_Nacm_Groups_Group)
	}
	return t.Group
}

// GetOrCreateGroup retrieves the value with the specified keys from
// the receiver IETFNetconfAcm_Nacm_Groups. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *IETFNetconfAcm_Nacm_Groups) GetOrCreateGroup(Name string) (*IETFNetconfAcm_Nacm_Groups_Group){

	key := Name

	if v, ok := t.Group[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewGroup(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateGroup got unexpected error: %v", err))
	}
	return v
}

// GetGroup retrieves the value with the specified key from
// the Group map field of IETFNetconfAcm_Nacm_Groups. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *IETFNetconfAcm_Nacm_Groups) GetGroup(Name string) (*IETFNetconfAcm_Nacm_Groups_Group){

	if t == nil {
		return nil
	}

  key := Name

  if lm, ok := t.Group[key]; ok {
    return lm
  }
  return nil
}

// AppendGroup appends the supplied IETFNetconfAcm_Nacm_Groups_Group struct to the
// list Group of IETFNetconfAcm_Nacm_Groups. If the key value(s) specified in
// the supplied IETFNetconfAcm_Nacm_Groups_Group already exist in the list, an error is
// returned.
func (t *IETFNetconfAcm_Nacm_Groups) AppendGroup(v *IETFNetconfAcm_Nacm_Groups_Group) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Group == nil {
		t.Group = make(map[string]*IETFNetconfAcm_Nacm_Groups_Group)
	}

	if _, ok := t.Group[key]; ok {
		return fmt.Errorf("duplicate key for list Group %v", key)
	}

	t.Group[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFNetconfAcm_Nacm_Groups) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFNetconfAcm_Nacm_Groups"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFNetconfAcm_Nacm_Groups) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFNetconfAcm_Nacm_Groups) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFNetconfAcm_Nacm_Groups.
func (*IETFNetconfAcm_Nacm_Groups) ΛBelongingModule() string {
	return "ietf-netconf-acm"
}


// IETFNetconfAcm_Nacm_Groups_Group represents the /ietf-netconf-acm/nacm/groups/group YANG schema element.
type IETFNetconfAcm_Nacm_Groups_Group struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Name	*string	`path:"name" module:"ietf-netconf-acm"`
	ΛName	[]ygot.Annotation	`path:"@name" ygotAnnotation:"true"`
	UserName	[]string	`path:"user-name" module:"ietf-netconf-acm"`
	ΛUserName	[]ygot.Annotation	`path:"@user-name" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFNetconfAcm_Nacm_Groups_Group implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFNetconfAcm_Nacm_Groups_Group) IsYANGGoStruct() {}

// GetName retrieves the value of the leaf Name from the IETFNetconfAcm_Nacm_Groups_Group
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *IETFNetconfAcm_Nacm_Groups_Group) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetUserName retrieves the value of the leaf UserName from the IETFNetconfAcm_Nacm_Groups_Group
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UserName is set, it can
// safely use t.GetUserName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UserName == nil' before retrieving the leaf's value.
func (t *IETFNetconfAcm_Nacm_Groups_Group) GetUserName() []string {
	if t == nil || t.UserName ==  nil {
		return nil
	}
	return t.UserName
}

// ΛListKeyMap returns the keys of the IETFNetconfAcm_Nacm_Groups_Group struct, which is a YANG list entry.
func (t *IETFNetconfAcm_Nacm_Groups_Group) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFNetconfAcm_Nacm_Groups_Group) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFNetconfAcm_Nacm_Groups_Group"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFNetconfAcm_Nacm_Groups_Group) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFNetconfAcm_Nacm_Groups_Group) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFNetconfAcm_Nacm_Groups_Group.
func (*IETFNetconfAcm_Nacm_Groups_Group) ΛBelongingModule() string {
	return "ietf-netconf-acm"
}


// IETFNetconfAcm_Nacm_RuleList represents the /ietf-netconf-acm/nacm/rule-list YANG schema element.
type IETFNetconfAcm_Nacm_RuleList struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Group	[]string	`path:"group" module:"ietf-netconf-acm"`
	ΛGroup	[]ygot.Annotation	`path:"@group" ygotAnnotation:"true"`
	Name	*string	`path:"name" module:"ietf-netconf-acm"`
	ΛName	[]ygot.Annotation	`path:"@name" ygotAnnotation:"true"`
	Rule	*IETFNetconfAcm_Nacm_RuleList_Rule_OrderedMap	`path:"rule" module:"ietf-netconf-acm"`
	ΛRule	[]ygot.Annotation	`path:"@rule" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFNetconfAcm_Nacm_RuleList implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFNetconfAcm_Nacm_RuleList) IsYANGGoStruct() {}

// GetGroup retrieves the value of the leaf Group from the IETFNetconfAcm_Nacm_RuleList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Group is set, it can
// safely use t.GetGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Group == nil' before retrieving the leaf's value.
func (t *IETFNetconfAcm_Nacm_RuleList) GetGroup() []string {
	if t == nil || t.Group ==  nil {
		return nil
	}
	return t.Group
}

// GetName retrieves the value of the leaf Name from the IETFNetconfAcm_Nacm_RuleList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *IETFNetconfAcm_Nacm_RuleList) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetOrCreateRuleMap returns the ordered map field
// Rule from IETFNetconfAcm_Nacm_RuleList.
//
// It initializes the field if not already initialized.
func (s *IETFNetconfAcm_Nacm_RuleList) GetOrCreateRuleMap() *IETFNetconfAcm_Nacm_RuleList_Rule_OrderedMap {
	if s.Rule == nil {
		s.Rule = &IETFNetconfAcm_Nacm_RuleList_Rule_OrderedMap{}
	}
	return s.Rule
}

// AppendNewRule creates a new entry in the Rule
// ordered map of the IETFNetconfAcm_Nacm_RuleList struct. The keys of the list are
// populated from the input arguments.
func (s *IETFNetconfAcm_Nacm_RuleList) AppendNewRule(Name string) (*IETFNetconfAcm_Nacm_RuleList_Rule, error) {
	if s.Rule == nil {
		s.Rule = &IETFNetconfAcm_Nacm_RuleList_Rule_OrderedMap{}
	}
	return s.Rule.AppendNew(Name)
}

// AppendRule appends the supplied IETFNetconfAcm_Nacm_RuleList_Rule struct
// to the list Rule of IETFNetconfAcm_Nacm_RuleList. If the key value(s)
// specified in the supplied IETFNetconfAcm_Nacm_RuleList_Rule already exist in the list, an
// error is returned.
func (s *IETFNetconfAcm_Nacm_RuleList) AppendRule(v *IETFNetconfAcm_Nacm_RuleList_Rule) error {
	if s.Rule == nil {
		s.Rule = &IETFNetconfAcm_Nacm_RuleList_Rule_OrderedMap{}
	}
	return s.Rule.Append(v)
}

// GetRule retrieves the value with the specified key from the
// Rule map field of IETFNetconfAcm_Nacm_RuleList. If the receiver
// is nil, or the specified key is not present in the list, nil is returned
// such that Get* methods may be safely chained.
func (s *IETFNetconfAcm_Nacm_RuleList) GetRule(Name string) *IETFNetconfAcm_Nacm_RuleList_Rule {
	if s == nil {
		return nil
	}
	key := Name
	return s.Rule.Get(key)
}

// DeleteRule deletes the value with the specified keys from
// the receiver IETFNetconfAcm_Nacm_RuleList. If there is no such element, the
// function is a no-op.
func (s *IETFNetconfAcm_Nacm_RuleList) DeleteRule(Name string) bool {
	key := Name
	return s.Rule.Delete(key)
}

// IETFNetconfAcm_Nacm_RuleList_Rule_OrderedMap is an ordered map that represents the "ordered-by user"
// list elements at /ietf-netconf-acm/nacm/rule-list/rule.
type IETFNetconfAcm_Nacm_RuleList_Rule_OrderedMap struct {
	keys []string
	valueMap map[string]*IETFNetconfAcm_Nacm_RuleList_Rule
}

// IsYANGOrderedList ensures that IETFNetconfAcm_Nacm_RuleList_Rule_OrderedMap implements the
// ygot.GoOrderedMap interface.
func (*IETFNetconfAcm_Nacm_RuleList_Rule_OrderedMap) IsYANGOrderedList() {}

// init initializes any uninitialized values.
func (o *IETFNetconfAcm_Nacm_RuleList_Rule_OrderedMap) init() {
	if o == nil {
		return
	}
	if o.valueMap == nil {
		o.valueMap = map[string]*IETFNetconfAcm_Nacm_RuleList_Rule{}
	}
}

// Keys returns a copy of the list's keys.
func (o *IETFNetconfAcm_Nacm_RuleList_Rule_OrderedMap) Keys() []string {
	if o == nil {
		return nil
	}
	return append([]string{}, o.keys...)
}

// Values returns the current set of the list's values in order.
func (o *IETFNetconfAcm_Nacm_RuleList_Rule_OrderedMap) Values() []*IETFNetconfAcm_Nacm_RuleList_Rule {
	if o == nil {
		return nil
	}
	var values []*IETFNetconfAcm_Nacm_RuleList_Rule
	for _, key := range o.keys {
		values = append(values, o.valueMap[key])
	}
	return values
}

// Len returns a size of IETFNetconfAcm_Nacm_RuleList_Rule_OrderedMap
func (o *IETFNetconfAcm_Nacm_RuleList_Rule_OrderedMap) Len() int {
	if o == nil {
		return 0
	}
	return len(o.keys)
}

// Get returns the value corresponding to the key. If the key is not found, nil
// is returned.
func (o *IETFNetconfAcm_Nacm_RuleList_Rule_OrderedMap) Get(key string) *IETFNetconfAcm_Nacm_RuleList_Rule {
	if o == nil {
		return nil
	}
	val, _ := o.valueMap[key]
	return val
}

// Delete deletes an element.
func (o *IETFNetconfAcm_Nacm_RuleList_Rule_OrderedMap) Delete(key string) bool {
	if o == nil {
		return false
	}
	if _, ok := o.valueMap[key]; !ok {
		return false
	}
	for i, k := range o.keys {
		if k == key {
			o.keys = append(o.keys[:i], o.keys[i+1:]...)
			delete(o.valueMap, key)
			return true
		}
	}
	return false
}

// Append appends a IETFNetconfAcm_Nacm_RuleList_Rule, returning an error if the key
// already exists in the ordered list or if the key is unspecified.
func (o *IETFNetconfAcm_Nacm_RuleList_Rule_OrderedMap) Append(v *IETFNetconfAcm_Nacm_RuleList_Rule) error {
	if o == nil {
		return fmt.Errorf("nil ordered map, cannot append IETFNetconfAcm_Nacm_RuleList_Rule")
	}
	if v == nil {
		return fmt.Errorf("nil IETFNetconfAcm_Nacm_RuleList_Rule")
	}
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	if _, ok := o.valueMap[key]; ok {
		return fmt.Errorf("duplicate key for list Statement %v", key)
	}
	o.keys = append(o.keys, key)
	o.init()
	o.valueMap[key] = v
	return nil
}

// AppendNew creates and appends a new IETFNetconfAcm_Nacm_RuleList_Rule, returning the
// newly-initialized v. It returns an error if the v already exists.
func (o *IETFNetconfAcm_Nacm_RuleList_Rule_OrderedMap) AppendNew(Name string) (*IETFNetconfAcm_Nacm_RuleList_Rule, error) {
	if o == nil {
		return nil, fmt.Errorf("nil ordered map, cannot append IETFNetconfAcm_Nacm_RuleList_Rule")
	}
	key := Name

	if _, ok := o.valueMap[key]; ok {
		return nil, fmt.Errorf("duplicate key for list Statement %v", key)
	}
	o.keys = append(o.keys, key)
	newElement := &IETFNetconfAcm_Nacm_RuleList_Rule{
		Name: &Name,
	}
	o.init()
	o.valueMap[key] = newElement
	return newElement, nil
}

// ΛListKeyMap returns the keys of the IETFNetconfAcm_Nacm_RuleList struct, which is a YANG list entry.
func (t *IETFNetconfAcm_Nacm_RuleList) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFNetconfAcm_Nacm_RuleList) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFNetconfAcm_Nacm_RuleList"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFNetconfAcm_Nacm_RuleList) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFNetconfAcm_Nacm_RuleList) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFNetconfAcm_Nacm_RuleList.
func (*IETFNetconfAcm_Nacm_RuleList) ΛBelongingModule() string {
	return "ietf-netconf-acm"
}


// IETFNetconfAcm_Nacm_RuleList_Rule represents the /ietf-netconf-acm/nacm/rule-list/rule YANG schema element.
type IETFNetconfAcm_Nacm_RuleList_Rule struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	AccessOperations	IETFNetconfAcm_Nacm_RuleList_Rule_AccessOperations_Union	`path:"access-operations" module:"ietf-netconf-acm"`
	ΛAccessOperations	[]ygot.Annotation	`path:"@access-operations" ygotAnnotation:"true"`
	Action	E_IETFNetconfAcm_ActionType	`path:"action" module:"ietf-netconf-acm"`
	ΛAction	[]ygot.Annotation	`path:"@action" ygotAnnotation:"true"`
	Comment	*string	`path:"comment" module:"ietf-netconf-acm"`
	ΛComment	[]ygot.Annotation	`path:"@comment" ygotAnnotation:"true"`
	ModuleName	*string	`path:"module-name" module:"ietf-netconf-acm"`
	ΛModuleName	[]ygot.Annotation	`path:"@module-name" ygotAnnotation:"true"`
	Name	*string	`path:"name" module:"ietf-netconf-acm"`
	ΛName	[]ygot.Annotation	`path:"@name" ygotAnnotation:"true"`
	NotificationName	*string	`path:"notification-name" module:"ietf-netconf-acm"`
	ΛNotificationName	[]ygot.Annotation	`path:"@notification-name" ygotAnnotation:"true"`
	Path	*string	`path:"path" module:"ietf-netconf-acm"`
	ΛPath	[]ygot.Annotation	`path:"@path" ygotAnnotation:"true"`
	RpcName	*string	`path:"rpc-name" module:"ietf-netconf-acm"`
	ΛRpcName	[]ygot.Annotation	`path:"@rpc-name" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFNetconfAcm_Nacm_RuleList_Rule implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFNetconfAcm_Nacm_RuleList_Rule) IsYANGGoStruct() {}

// GetAccessOperations retrieves the value of the leaf AccessOperations from the IETFNetconfAcm_Nacm_RuleList_Rule
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AccessOperations is set, it can
// safely use t.GetAccessOperations() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AccessOperations == nil' before retrieving the leaf's value.
func (t *IETFNetconfAcm_Nacm_RuleList_Rule) GetAccessOperations() IETFNetconfAcm_Nacm_RuleList_Rule_AccessOperations_Union {
	if t == nil || t.AccessOperations ==  nil {
		return UnionString("*")
	}
	return t.AccessOperations
}

// GetAction retrieves the value of the leaf Action from the IETFNetconfAcm_Nacm_RuleList_Rule
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Action is set, it can
// safely use t.GetAction() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Action == nil' before retrieving the leaf's value.
func (t *IETFNetconfAcm_Nacm_RuleList_Rule) GetAction() E_IETFNetconfAcm_ActionType {
	if t == nil || t.Action ==  0 {
		return 0
	}
	return t.Action
}

// GetComment retrieves the value of the leaf Comment from the IETFNetconfAcm_Nacm_RuleList_Rule
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Comment is set, it can
// safely use t.GetComment() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Comment == nil' before retrieving the leaf's value.
func (t *IETFNetconfAcm_Nacm_RuleList_Rule) GetComment() string {
	if t == nil || t.Comment == nil {
		return ""
	}
	return *t.Comment
}

// GetModuleName retrieves the value of the leaf ModuleName from the IETFNetconfAcm_Nacm_RuleList_Rule
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ModuleName is set, it can
// safely use t.GetModuleName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ModuleName == nil' before retrieving the leaf's value.
func (t *IETFNetconfAcm_Nacm_RuleList_Rule) GetModuleName() string {
	if t == nil || t.ModuleName == nil {
		return "*"
	}
	return *t.ModuleName
}

// GetName retrieves the value of the leaf Name from the IETFNetconfAcm_Nacm_RuleList_Rule
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *IETFNetconfAcm_Nacm_RuleList_Rule) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetNotificationName retrieves the value of the leaf NotificationName from the IETFNetconfAcm_Nacm_RuleList_Rule
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NotificationName is set, it can
// safely use t.GetNotificationName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NotificationName == nil' before retrieving the leaf's value.
func (t *IETFNetconfAcm_Nacm_RuleList_Rule) GetNotificationName() string {
	if t == nil || t.NotificationName == nil {
		return ""
	}
	return *t.NotificationName
}

// GetPath retrieves the value of the leaf Path from the IETFNetconfAcm_Nacm_RuleList_Rule
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Path is set, it can
// safely use t.GetPath() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Path == nil' before retrieving the leaf's value.
func (t *IETFNetconfAcm_Nacm_RuleList_Rule) GetPath() string {
	if t == nil || t.Path == nil {
		return ""
	}
	return *t.Path
}

// GetRpcName retrieves the value of the leaf RpcName from the IETFNetconfAcm_Nacm_RuleList_Rule
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RpcName is set, it can
// safely use t.GetRpcName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RpcName == nil' before retrieving the leaf's value.
func (t *IETFNetconfAcm_Nacm_RuleList_Rule) GetRpcName() string {
	if t == nil || t.RpcName == nil {
		return ""
	}
	return *t.RpcName
}

// ΛListKeyMap returns the keys of the IETFNetconfAcm_Nacm_RuleList_Rule struct, which is a YANG list entry.
func (t *IETFNetconfAcm_Nacm_RuleList_Rule) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFNetconfAcm_Nacm_RuleList_Rule) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFNetconfAcm_Nacm_RuleList_Rule"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFNetconfAcm_Nacm_RuleList_Rule) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFNetconfAcm_Nacm_RuleList_Rule) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFNetconfAcm_Nacm_RuleList_Rule.
func (*IETFNetconfAcm_Nacm_RuleList_Rule) ΛBelongingModule() string {
	return "ietf-netconf-acm"
}

// IETFNetconfAcm_Nacm_RuleList_Rule_AccessOperations_Union is an interface that is implemented by valid types for the union
// for the leaf /ietf-netconf-acm/nacm/rule-list/rule/access-operations within the YANG schema.
// Union type can be one of [*UnionUnsupported, UnionString].
type IETFNetconfAcm_Nacm_RuleList_Rule_AccessOperations_Union interface {
	// Union type can be one of [*UnionUnsupported, UnionString]
	Documentation_for_IETFNetconfAcm_Nacm_RuleList_Rule_AccessOperations_Union()
}

// Documentation_for_IETFNetconfAcm_Nacm_RuleList_Rule_AccessOperations_Union ensures that *UnionUnsupported
// implements the IETFNetconfAcm_Nacm_RuleList_Rule_AccessOperations_Union interface.
func (*UnionUnsupported) Documentation_for_IETFNetconfAcm_Nacm_RuleList_Rule_AccessOperations_Union() {}

// Documentation_for_IETFNetconfAcm_Nacm_RuleList_Rule_AccessOperations_Union ensures that UnionString
// implements the IETFNetconfAcm_Nacm_RuleList_Rule_AccessOperations_Union interface.
func (UnionString) Documentation_for_IETFNetconfAcm_Nacm_RuleList_Rule_AccessOperations_Union() {}

// To_IETFNetconfAcm_Nacm_RuleList_Rule_AccessOperations_Union takes an input interface{} and attempts to convert it to a struct
// which implements the IETFNetconfAcm_Nacm_RuleList_Rule_AccessOperations_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *IETFNetconfAcm_Nacm_RuleList_Rule) To_IETFNetconfAcm_Nacm_RuleList_Rule_AccessOperations_Union(i interface{}) (IETFNetconfAcm_Nacm_RuleList_Rule_AccessOperations_Union, error) {
	if v, ok := i.(IETFNetconfAcm_Nacm_RuleList_Rule_AccessOperations_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	case interface{}:
		return &UnionUnsupported{v}, nil
	}
	return nil, fmt.Errorf("cannot convert %v to IETFNetconfAcm_Nacm_RuleList_Rule_AccessOperations_Union, unknown union type, got: %T, want any of [interface{}, string]", i, i)
}


// IETFSnmp_Snmp represents the /ietf-snmp/snmp YANG schema element.
type IETFSnmp_Snmp struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Community	map[string]*IETFSnmp_Snmp_Community	`path:"community" module:"ietf-snmp"`
	ΛCommunity	[]ygot.Annotation	`path:"@community" ygotAnnotation:"true"`
	Engine	*IETFSnmp_Snmp_Engine	`path:"engine" module:"ietf-snmp"`
	ΛEngine	[]ygot.Annotation	`path:"@engine" ygotAnnotation:"true"`
	Notify	map[string]*IETFSnmp_Snmp_Notify	`path:"notify" module:"ietf-snmp"`
	ΛNotify	[]ygot.Annotation	`path:"@notify" ygotAnnotation:"true"`
	NotifyFilterProfile	map[string]*IETFSnmp_Snmp_NotifyFilterProfile	`path:"notify-filter-profile" module:"ietf-snmp"`
	ΛNotifyFilterProfile	[]ygot.Annotation	`path:"@notify-filter-profile" ygotAnnotation:"true"`
	Proxy	map[string]*IETFSnmp_Snmp_Proxy	`path:"proxy" module:"ietf-snmp"`
	ΛProxy	[]ygot.Annotation	`path:"@proxy" ygotAnnotation:"true"`
	Target	map[string]*IETFSnmp_Snmp_Target	`path:"target" module:"ietf-snmp"`
	ΛTarget	[]ygot.Annotation	`path:"@target" ygotAnnotation:"true"`
	TargetParams	map[string]*IETFSnmp_Snmp_TargetParams	`path:"target-params" module:"ietf-snmp"`
	ΛTargetParams	[]ygot.Annotation	`path:"@target-params" ygotAnnotation:"true"`
	Tlstm	*IETFSnmp_Snmp_Tlstm	`path:"tlstm" module:"ietf-snmp"`
	ΛTlstm	[]ygot.Annotation	`path:"@tlstm" ygotAnnotation:"true"`
	Tsm	*IETFSnmp_Snmp_Tsm	`path:"tsm" module:"ietf-snmp"`
	ΛTsm	[]ygot.Annotation	`path:"@tsm" ygotAnnotation:"true"`
	Usm	*IETFSnmp_Snmp_Usm	`path:"usm" module:"ietf-snmp"`
	ΛUsm	[]ygot.Annotation	`path:"@usm" ygotAnnotation:"true"`
	Vacm	*IETFSnmp_Snmp_Vacm	`path:"vacm" module:"ietf-snmp"`
	ΛVacm	[]ygot.Annotation	`path:"@vacm" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp) IsYANGGoStruct() {}

// NewCommunity creates a new entry in the Community list of the
// IETFSnmp_Snmp struct. The keys of the list are populated from the input
// arguments.
func (t *IETFSnmp_Snmp) NewCommunity(Index string) (*IETFSnmp_Snmp_Community, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Community == nil {
		t.Community = make(map[string]*IETFSnmp_Snmp_Community)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Community[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Community", key)
	}

	t.Community[key] = &IETFSnmp_Snmp_Community{
		Index: &Index,
	}

	return t.Community[key], nil
}

// RenameCommunity renames an entry in the list Community within
// the IETFSnmp_Snmp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *IETFSnmp_Snmp) RenameCommunity(oldK, newK string) error {
	if _, ok := t.Community[newK]; ok {
		return fmt.Errorf("key %v already exists in Community", newK)
	}

	e, ok := t.Community[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Community", oldK)
	}
	e.Index = &newK

	t.Community[newK] = e
	delete(t.Community, oldK)
	return nil
}

// GetOrCreateCommunityMap returns the list (map) from IETFSnmp_Snmp.
//
// It initializes the field if not already initialized.
func (t *IETFSnmp_Snmp) GetOrCreateCommunityMap() map[string]*IETFSnmp_Snmp_Community {
	if t.Community == nil {
		t.Community = make(map[string]*IETFSnmp_Snmp_Community)
	}
	return t.Community
}

// GetOrCreateCommunity retrieves the value with the specified keys from
// the receiver IETFSnmp_Snmp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *IETFSnmp_Snmp) GetOrCreateCommunity(Index string) (*IETFSnmp_Snmp_Community){

	key := Index

	if v, ok := t.Community[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewCommunity(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateCommunity got unexpected error: %v", err))
	}
	return v
}

// GetCommunity retrieves the value with the specified key from
// the Community map field of IETFSnmp_Snmp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *IETFSnmp_Snmp) GetCommunity(Index string) (*IETFSnmp_Snmp_Community){

	if t == nil {
		return nil
	}

  key := Index

  if lm, ok := t.Community[key]; ok {
    return lm
  }
  return nil
}

// AppendCommunity appends the supplied IETFSnmp_Snmp_Community struct to the
// list Community of IETFSnmp_Snmp. If the key value(s) specified in
// the supplied IETFSnmp_Snmp_Community already exist in the list, an error is
// returned.
func (t *IETFSnmp_Snmp) AppendCommunity(v *IETFSnmp_Snmp_Community) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Community == nil {
		t.Community = make(map[string]*IETFSnmp_Snmp_Community)
	}

	if _, ok := t.Community[key]; ok {
		return fmt.Errorf("duplicate key for list Community %v", key)
	}

	t.Community[key] = v
	return nil
}

// NewNotify creates a new entry in the Notify list of the
// IETFSnmp_Snmp struct. The keys of the list are populated from the input
// arguments.
func (t *IETFSnmp_Snmp) NewNotify(Name string) (*IETFSnmp_Snmp_Notify, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Notify == nil {
		t.Notify = make(map[string]*IETFSnmp_Snmp_Notify)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Notify[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Notify", key)
	}

	t.Notify[key] = &IETFSnmp_Snmp_Notify{
		Name: &Name,
	}

	return t.Notify[key], nil
}

// RenameNotify renames an entry in the list Notify within
// the IETFSnmp_Snmp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *IETFSnmp_Snmp) RenameNotify(oldK, newK string) error {
	if _, ok := t.Notify[newK]; ok {
		return fmt.Errorf("key %v already exists in Notify", newK)
	}

	e, ok := t.Notify[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Notify", oldK)
	}
	e.Name = &newK

	t.Notify[newK] = e
	delete(t.Notify, oldK)
	return nil
}

// GetOrCreateNotifyMap returns the list (map) from IETFSnmp_Snmp.
//
// It initializes the field if not already initialized.
func (t *IETFSnmp_Snmp) GetOrCreateNotifyMap() map[string]*IETFSnmp_Snmp_Notify {
	if t.Notify == nil {
		t.Notify = make(map[string]*IETFSnmp_Snmp_Notify)
	}
	return t.Notify
}

// GetOrCreateNotify retrieves the value with the specified keys from
// the receiver IETFSnmp_Snmp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *IETFSnmp_Snmp) GetOrCreateNotify(Name string) (*IETFSnmp_Snmp_Notify){

	key := Name

	if v, ok := t.Notify[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNotify(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNotify got unexpected error: %v", err))
	}
	return v
}

// GetNotify retrieves the value with the specified key from
// the Notify map field of IETFSnmp_Snmp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *IETFSnmp_Snmp) GetNotify(Name string) (*IETFSnmp_Snmp_Notify){

	if t == nil {
		return nil
	}

  key := Name

  if lm, ok := t.Notify[key]; ok {
    return lm
  }
  return nil
}

// AppendNotify appends the supplied IETFSnmp_Snmp_Notify struct to the
// list Notify of IETFSnmp_Snmp. If the key value(s) specified in
// the supplied IETFSnmp_Snmp_Notify already exist in the list, an error is
// returned.
func (t *IETFSnmp_Snmp) AppendNotify(v *IETFSnmp_Snmp_Notify) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Notify == nil {
		t.Notify = make(map[string]*IETFSnmp_Snmp_Notify)
	}

	if _, ok := t.Notify[key]; ok {
		return fmt.Errorf("duplicate key for list Notify %v", key)
	}

	t.Notify[key] = v
	return nil
}

// NewNotifyFilterProfile creates a new entry in the NotifyFilterProfile list of the
// IETFSnmp_Snmp struct. The keys of the list are populated from the input
// arguments.
func (t *IETFSnmp_Snmp) NewNotifyFilterProfile(Name string) (*IETFSnmp_Snmp_NotifyFilterProfile, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NotifyFilterProfile == nil {
		t.NotifyFilterProfile = make(map[string]*IETFSnmp_Snmp_NotifyFilterProfile)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NotifyFilterProfile[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NotifyFilterProfile", key)
	}

	t.NotifyFilterProfile[key] = &IETFSnmp_Snmp_NotifyFilterProfile{
		Name: &Name,
	}

	return t.NotifyFilterProfile[key], nil
}

// RenameNotifyFilterProfile renames an entry in the list NotifyFilterProfile within
// the IETFSnmp_Snmp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *IETFSnmp_Snmp) RenameNotifyFilterProfile(oldK, newK string) error {
	if _, ok := t.NotifyFilterProfile[newK]; ok {
		return fmt.Errorf("key %v already exists in NotifyFilterProfile", newK)
	}

	e, ok := t.NotifyFilterProfile[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NotifyFilterProfile", oldK)
	}
	e.Name = &newK

	t.NotifyFilterProfile[newK] = e
	delete(t.NotifyFilterProfile, oldK)
	return nil
}

// GetOrCreateNotifyFilterProfileMap returns the list (map) from IETFSnmp_Snmp.
//
// It initializes the field if not already initialized.
func (t *IETFSnmp_Snmp) GetOrCreateNotifyFilterProfileMap() map[string]*IETFSnmp_Snmp_NotifyFilterProfile {
	if t.NotifyFilterProfile == nil {
		t.NotifyFilterProfile = make(map[string]*IETFSnmp_Snmp_NotifyFilterProfile)
	}
	return t.NotifyFilterProfile
}

// GetOrCreateNotifyFilterProfile retrieves the value with the specified keys from
// the receiver IETFSnmp_Snmp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *IETFSnmp_Snmp) GetOrCreateNotifyFilterProfile(Name string) (*IETFSnmp_Snmp_NotifyFilterProfile){

	key := Name

	if v, ok := t.NotifyFilterProfile[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNotifyFilterProfile(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNotifyFilterProfile got unexpected error: %v", err))
	}
	return v
}

// GetNotifyFilterProfile retrieves the value with the specified key from
// the NotifyFilterProfile map field of IETFSnmp_Snmp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *IETFSnmp_Snmp) GetNotifyFilterProfile(Name string) (*IETFSnmp_Snmp_NotifyFilterProfile){

	if t == nil {
		return nil
	}

  key := Name

  if lm, ok := t.NotifyFilterProfile[key]; ok {
    return lm
  }
  return nil
}

// AppendNotifyFilterProfile appends the supplied IETFSnmp_Snmp_NotifyFilterProfile struct to the
// list NotifyFilterProfile of IETFSnmp_Snmp. If the key value(s) specified in
// the supplied IETFSnmp_Snmp_NotifyFilterProfile already exist in the list, an error is
// returned.
func (t *IETFSnmp_Snmp) AppendNotifyFilterProfile(v *IETFSnmp_Snmp_NotifyFilterProfile) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NotifyFilterProfile == nil {
		t.NotifyFilterProfile = make(map[string]*IETFSnmp_Snmp_NotifyFilterProfile)
	}

	if _, ok := t.NotifyFilterProfile[key]; ok {
		return fmt.Errorf("duplicate key for list NotifyFilterProfile %v", key)
	}

	t.NotifyFilterProfile[key] = v
	return nil
}

// NewProxy creates a new entry in the Proxy list of the
// IETFSnmp_Snmp struct. The keys of the list are populated from the input
// arguments.
func (t *IETFSnmp_Snmp) NewProxy(Name string) (*IETFSnmp_Snmp_Proxy, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Proxy == nil {
		t.Proxy = make(map[string]*IETFSnmp_Snmp_Proxy)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Proxy[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Proxy", key)
	}

	t.Proxy[key] = &IETFSnmp_Snmp_Proxy{
		Name: &Name,
	}

	return t.Proxy[key], nil
}

// RenameProxy renames an entry in the list Proxy within
// the IETFSnmp_Snmp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *IETFSnmp_Snmp) RenameProxy(oldK, newK string) error {
	if _, ok := t.Proxy[newK]; ok {
		return fmt.Errorf("key %v already exists in Proxy", newK)
	}

	e, ok := t.Proxy[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Proxy", oldK)
	}
	e.Name = &newK

	t.Proxy[newK] = e
	delete(t.Proxy, oldK)
	return nil
}

// GetOrCreateProxyMap returns the list (map) from IETFSnmp_Snmp.
//
// It initializes the field if not already initialized.
func (t *IETFSnmp_Snmp) GetOrCreateProxyMap() map[string]*IETFSnmp_Snmp_Proxy {
	if t.Proxy == nil {
		t.Proxy = make(map[string]*IETFSnmp_Snmp_Proxy)
	}
	return t.Proxy
}

// GetOrCreateProxy retrieves the value with the specified keys from
// the receiver IETFSnmp_Snmp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *IETFSnmp_Snmp) GetOrCreateProxy(Name string) (*IETFSnmp_Snmp_Proxy){

	key := Name

	if v, ok := t.Proxy[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewProxy(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateProxy got unexpected error: %v", err))
	}
	return v
}

// GetProxy retrieves the value with the specified key from
// the Proxy map field of IETFSnmp_Snmp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *IETFSnmp_Snmp) GetProxy(Name string) (*IETFSnmp_Snmp_Proxy){

	if t == nil {
		return nil
	}

  key := Name

  if lm, ok := t.Proxy[key]; ok {
    return lm
  }
  return nil
}

// AppendProxy appends the supplied IETFSnmp_Snmp_Proxy struct to the
// list Proxy of IETFSnmp_Snmp. If the key value(s) specified in
// the supplied IETFSnmp_Snmp_Proxy already exist in the list, an error is
// returned.
func (t *IETFSnmp_Snmp) AppendProxy(v *IETFSnmp_Snmp_Proxy) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Proxy == nil {
		t.Proxy = make(map[string]*IETFSnmp_Snmp_Proxy)
	}

	if _, ok := t.Proxy[key]; ok {
		return fmt.Errorf("duplicate key for list Proxy %v", key)
	}

	t.Proxy[key] = v
	return nil
}

// NewTarget creates a new entry in the Target list of the
// IETFSnmp_Snmp struct. The keys of the list are populated from the input
// arguments.
func (t *IETFSnmp_Snmp) NewTarget(Name string) (*IETFSnmp_Snmp_Target, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Target == nil {
		t.Target = make(map[string]*IETFSnmp_Snmp_Target)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Target[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Target", key)
	}

	t.Target[key] = &IETFSnmp_Snmp_Target{
		Name: &Name,
	}

	return t.Target[key], nil
}

// RenameTarget renames an entry in the list Target within
// the IETFSnmp_Snmp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *IETFSnmp_Snmp) RenameTarget(oldK, newK string) error {
	if _, ok := t.Target[newK]; ok {
		return fmt.Errorf("key %v already exists in Target", newK)
	}

	e, ok := t.Target[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Target", oldK)
	}
	e.Name = &newK

	t.Target[newK] = e
	delete(t.Target, oldK)
	return nil
}

// GetOrCreateTargetMap returns the list (map) from IETFSnmp_Snmp.
//
// It initializes the field if not already initialized.
func (t *IETFSnmp_Snmp) GetOrCreateTargetMap() map[string]*IETFSnmp_Snmp_Target {
	if t.Target == nil {
		t.Target = make(map[string]*IETFSnmp_Snmp_Target)
	}
	return t.Target
}

// GetOrCreateTarget retrieves the value with the specified keys from
// the receiver IETFSnmp_Snmp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *IETFSnmp_Snmp) GetOrCreateTarget(Name string) (*IETFSnmp_Snmp_Target){

	key := Name

	if v, ok := t.Target[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTarget(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTarget got unexpected error: %v", err))
	}
	return v
}

// GetTarget retrieves the value with the specified key from
// the Target map field of IETFSnmp_Snmp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *IETFSnmp_Snmp) GetTarget(Name string) (*IETFSnmp_Snmp_Target){

	if t == nil {
		return nil
	}

  key := Name

  if lm, ok := t.Target[key]; ok {
    return lm
  }
  return nil
}

// AppendTarget appends the supplied IETFSnmp_Snmp_Target struct to the
// list Target of IETFSnmp_Snmp. If the key value(s) specified in
// the supplied IETFSnmp_Snmp_Target already exist in the list, an error is
// returned.
func (t *IETFSnmp_Snmp) AppendTarget(v *IETFSnmp_Snmp_Target) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Target == nil {
		t.Target = make(map[string]*IETFSnmp_Snmp_Target)
	}

	if _, ok := t.Target[key]; ok {
		return fmt.Errorf("duplicate key for list Target %v", key)
	}

	t.Target[key] = v
	return nil
}

// NewTargetParams creates a new entry in the TargetParams list of the
// IETFSnmp_Snmp struct. The keys of the list are populated from the input
// arguments.
func (t *IETFSnmp_Snmp) NewTargetParams(Name string) (*IETFSnmp_Snmp_TargetParams, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TargetParams == nil {
		t.TargetParams = make(map[string]*IETFSnmp_Snmp_TargetParams)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.TargetParams[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list TargetParams", key)
	}

	t.TargetParams[key] = &IETFSnmp_Snmp_TargetParams{
		Name: &Name,
	}

	return t.TargetParams[key], nil
}

// RenameTargetParams renames an entry in the list TargetParams within
// the IETFSnmp_Snmp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *IETFSnmp_Snmp) RenameTargetParams(oldK, newK string) error {
	if _, ok := t.TargetParams[newK]; ok {
		return fmt.Errorf("key %v already exists in TargetParams", newK)
	}

	e, ok := t.TargetParams[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in TargetParams", oldK)
	}
	e.Name = &newK

	t.TargetParams[newK] = e
	delete(t.TargetParams, oldK)
	return nil
}

// GetOrCreateTargetParamsMap returns the list (map) from IETFSnmp_Snmp.
//
// It initializes the field if not already initialized.
func (t *IETFSnmp_Snmp) GetOrCreateTargetParamsMap() map[string]*IETFSnmp_Snmp_TargetParams {
	if t.TargetParams == nil {
		t.TargetParams = make(map[string]*IETFSnmp_Snmp_TargetParams)
	}
	return t.TargetParams
}

// GetOrCreateTargetParams retrieves the value with the specified keys from
// the receiver IETFSnmp_Snmp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *IETFSnmp_Snmp) GetOrCreateTargetParams(Name string) (*IETFSnmp_Snmp_TargetParams){

	key := Name

	if v, ok := t.TargetParams[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTargetParams(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTargetParams got unexpected error: %v", err))
	}
	return v
}

// GetTargetParams retrieves the value with the specified key from
// the TargetParams map field of IETFSnmp_Snmp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *IETFSnmp_Snmp) GetTargetParams(Name string) (*IETFSnmp_Snmp_TargetParams){

	if t == nil {
		return nil
	}

  key := Name

  if lm, ok := t.TargetParams[key]; ok {
    return lm
  }
  return nil
}

// AppendTargetParams appends the supplied IETFSnmp_Snmp_TargetParams struct to the
// list TargetParams of IETFSnmp_Snmp. If the key value(s) specified in
// the supplied IETFSnmp_Snmp_TargetParams already exist in the list, an error is
// returned.
func (t *IETFSnmp_Snmp) AppendTargetParams(v *IETFSnmp_Snmp_TargetParams) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TargetParams == nil {
		t.TargetParams = make(map[string]*IETFSnmp_Snmp_TargetParams)
	}

	if _, ok := t.TargetParams[key]; ok {
		return fmt.Errorf("duplicate key for list TargetParams %v", key)
	}

	t.TargetParams[key] = v
	return nil
}

// GetOrCreateEngine retrieves the value of the Engine field
// or returns the existing field if it already exists.
func (t *IETFSnmp_Snmp) GetOrCreateEngine() *IETFSnmp_Snmp_Engine {
	if t.Engine != nil {
		return t.Engine
	}
	t.Engine = &IETFSnmp_Snmp_Engine{}
	return t.Engine
}

// GetOrCreateTlstm retrieves the value of the Tlstm field
// or returns the existing field if it already exists.
func (t *IETFSnmp_Snmp) GetOrCreateTlstm() *IETFSnmp_Snmp_Tlstm {
	if t.Tlstm != nil {
		return t.Tlstm
	}
	t.Tlstm = &IETFSnmp_Snmp_Tlstm{}
	return t.Tlstm
}

// GetOrCreateTsm retrieves the value of the Tsm field
// or returns the existing field if it already exists.
func (t *IETFSnmp_Snmp) GetOrCreateTsm() *IETFSnmp_Snmp_Tsm {
	if t.Tsm != nil {
		return t.Tsm
	}
	t.Tsm = &IETFSnmp_Snmp_Tsm{}
	return t.Tsm
}

// GetOrCreateUsm retrieves the value of the Usm field
// or returns the existing field if it already exists.
func (t *IETFSnmp_Snmp) GetOrCreateUsm() *IETFSnmp_Snmp_Usm {
	if t.Usm != nil {
		return t.Usm
	}
	t.Usm = &IETFSnmp_Snmp_Usm{}
	return t.Usm
}

// GetOrCreateVacm retrieves the value of the Vacm field
// or returns the existing field if it already exists.
func (t *IETFSnmp_Snmp) GetOrCreateVacm() *IETFSnmp_Snmp_Vacm {
	if t.Vacm != nil {
		return t.Vacm
	}
	t.Vacm = &IETFSnmp_Snmp_Vacm{}
	return t.Vacm
}

// GetEngine returns the value of the Engine struct pointer
// from IETFSnmp_Snmp. If the receiver or the field Engine is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IETFSnmp_Snmp) GetEngine() *IETFSnmp_Snmp_Engine {
	if t != nil && t.Engine != nil {
		return t.Engine
	}
	return nil
}

// GetTlstm returns the value of the Tlstm struct pointer
// from IETFSnmp_Snmp. If the receiver or the field Tlstm is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IETFSnmp_Snmp) GetTlstm() *IETFSnmp_Snmp_Tlstm {
	if t != nil && t.Tlstm != nil {
		return t.Tlstm
	}
	return nil
}

// GetTsm returns the value of the Tsm struct pointer
// from IETFSnmp_Snmp. If the receiver or the field Tsm is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IETFSnmp_Snmp) GetTsm() *IETFSnmp_Snmp_Tsm {
	if t != nil && t.Tsm != nil {
		return t.Tsm
	}
	return nil
}

// GetUsm returns the value of the Usm struct pointer
// from IETFSnmp_Snmp. If the receiver or the field Usm is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IETFSnmp_Snmp) GetUsm() *IETFSnmp_Snmp_Usm {
	if t != nil && t.Usm != nil {
		return t.Usm
	}
	return nil
}

// GetVacm returns the value of the Vacm struct pointer
// from IETFSnmp_Snmp. If the receiver or the field Vacm is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IETFSnmp_Snmp) GetVacm() *IETFSnmp_Snmp_Vacm {
	if t != nil && t.Vacm != nil {
		return t.Vacm
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp.
func (*IETFSnmp_Snmp) ΛBelongingModule() string {
	return "ietf-snmp"
}


// IETFSnmp_Snmp_Community represents the /ietf-snmp/snmp/community YANG schema element.
type IETFSnmp_Snmp_Community struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	BinaryName	Binary	`path:"binary-name" module:"ietf-snmp"`
	ΛBinaryName	[]ygot.Annotation	`path:"@binary-name" ygotAnnotation:"true"`
	Context	*string	`path:"context" module:"ietf-snmp"`
	ΛContext	[]ygot.Annotation	`path:"@context" ygotAnnotation:"true"`
	EngineId	*string	`path:"engine-id" module:"ietf-snmp"`
	ΛEngineId	[]ygot.Annotation	`path:"@engine-id" ygotAnnotation:"true"`
	Index	*string	`path:"index" module:"ietf-snmp"`
	ΛIndex	[]ygot.Annotation	`path:"@index" ygotAnnotation:"true"`
	SecurityName	*string	`path:"security-name" module:"ietf-snmp"`
	ΛSecurityName	[]ygot.Annotation	`path:"@security-name" ygotAnnotation:"true"`
	TargetTag	*string	`path:"target-tag" module:"ietf-snmp"`
	ΛTargetTag	[]ygot.Annotation	`path:"@target-tag" ygotAnnotation:"true"`
	TextName	*string	`path:"text-name" module:"ietf-snmp"`
	ΛTextName	[]ygot.Annotation	`path:"@text-name" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_Community implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_Community) IsYANGGoStruct() {}

// GetBinaryName retrieves the value of the leaf BinaryName from the IETFSnmp_Snmp_Community
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BinaryName is set, it can
// safely use t.GetBinaryName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BinaryName == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Community) GetBinaryName() Binary {
	if t == nil || t.BinaryName ==  nil {
		return nil
	}
	return t.BinaryName
}

// GetContext retrieves the value of the leaf Context from the IETFSnmp_Snmp_Community
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Context is set, it can
// safely use t.GetContext() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Context == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Community) GetContext() string {
	if t == nil || t.Context == nil {
		return ""
	}
	return *t.Context
}

// GetEngineId retrieves the value of the leaf EngineId from the IETFSnmp_Snmp_Community
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EngineId is set, it can
// safely use t.GetEngineId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EngineId == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Community) GetEngineId() string {
	if t == nil || t.EngineId == nil {
		return ""
	}
	return *t.EngineId
}

// GetIndex retrieves the value of the leaf Index from the IETFSnmp_Snmp_Community
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Community) GetIndex() string {
	if t == nil || t.Index == nil {
		return ""
	}
	return *t.Index
}

// GetSecurityName retrieves the value of the leaf SecurityName from the IETFSnmp_Snmp_Community
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SecurityName is set, it can
// safely use t.GetSecurityName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SecurityName == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Community) GetSecurityName() string {
	if t == nil || t.SecurityName == nil {
		return ""
	}
	return *t.SecurityName
}

// GetTargetTag retrieves the value of the leaf TargetTag from the IETFSnmp_Snmp_Community
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TargetTag is set, it can
// safely use t.GetTargetTag() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TargetTag == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Community) GetTargetTag() string {
	if t == nil || t.TargetTag == nil {
		return ""
	}
	return *t.TargetTag
}

// GetTextName retrieves the value of the leaf TextName from the IETFSnmp_Snmp_Community
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TextName is set, it can
// safely use t.GetTextName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TextName == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Community) GetTextName() string {
	if t == nil || t.TextName == nil {
		return ""
	}
	return *t.TextName
}

// ΛListKeyMap returns the keys of the IETFSnmp_Snmp_Community struct, which is a YANG list entry.
func (t *IETFSnmp_Snmp_Community) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Community) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_Community"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Community) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_Community) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_Community.
func (*IETFSnmp_Snmp_Community) ΛBelongingModule() string {
	return "ietf-snmp"
}


// IETFSnmp_Snmp_Engine represents the /ietf-snmp/snmp/engine YANG schema element.
type IETFSnmp_Snmp_Engine struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	EnableAuthenTraps	*bool	`path:"enable-authen-traps" module:"ietf-snmp"`
	ΛEnableAuthenTraps	[]ygot.Annotation	`path:"@enable-authen-traps" ygotAnnotation:"true"`
	Enabled	*bool	`path:"enabled" module:"ietf-snmp"`
	ΛEnabled	[]ygot.Annotation	`path:"@enabled" ygotAnnotation:"true"`
	EngineId	*string	`path:"engine-id" module:"ietf-snmp"`
	ΛEngineId	[]ygot.Annotation	`path:"@engine-id" ygotAnnotation:"true"`
	Listen	map[string]*IETFSnmp_Snmp_Engine_Listen	`path:"listen" module:"ietf-snmp"`
	ΛListen	[]ygot.Annotation	`path:"@listen" ygotAnnotation:"true"`
	Version	*IETFSnmp_Snmp_Engine_Version	`path:"version" module:"ietf-snmp"`
	ΛVersion	[]ygot.Annotation	`path:"@version" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_Engine implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_Engine) IsYANGGoStruct() {}

// NewListen creates a new entry in the Listen list of the
// IETFSnmp_Snmp_Engine struct. The keys of the list are populated from the input
// arguments.
func (t *IETFSnmp_Snmp_Engine) NewListen(Name string) (*IETFSnmp_Snmp_Engine_Listen, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Listen == nil {
		t.Listen = make(map[string]*IETFSnmp_Snmp_Engine_Listen)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Listen[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Listen", key)
	}

	t.Listen[key] = &IETFSnmp_Snmp_Engine_Listen{
		Name: &Name,
	}

	return t.Listen[key], nil
}

// RenameListen renames an entry in the list Listen within
// the IETFSnmp_Snmp_Engine struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *IETFSnmp_Snmp_Engine) RenameListen(oldK, newK string) error {
	if _, ok := t.Listen[newK]; ok {
		return fmt.Errorf("key %v already exists in Listen", newK)
	}

	e, ok := t.Listen[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Listen", oldK)
	}
	e.Name = &newK

	t.Listen[newK] = e
	delete(t.Listen, oldK)
	return nil
}

// GetOrCreateListenMap returns the list (map) from IETFSnmp_Snmp_Engine.
//
// It initializes the field if not already initialized.
func (t *IETFSnmp_Snmp_Engine) GetOrCreateListenMap() map[string]*IETFSnmp_Snmp_Engine_Listen {
	if t.Listen == nil {
		t.Listen = make(map[string]*IETFSnmp_Snmp_Engine_Listen)
	}
	return t.Listen
}

// GetOrCreateListen retrieves the value with the specified keys from
// the receiver IETFSnmp_Snmp_Engine. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *IETFSnmp_Snmp_Engine) GetOrCreateListen(Name string) (*IETFSnmp_Snmp_Engine_Listen){

	key := Name

	if v, ok := t.Listen[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewListen(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateListen got unexpected error: %v", err))
	}
	return v
}

// GetListen retrieves the value with the specified key from
// the Listen map field of IETFSnmp_Snmp_Engine. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *IETFSnmp_Snmp_Engine) GetListen(Name string) (*IETFSnmp_Snmp_Engine_Listen){

	if t == nil {
		return nil
	}

  key := Name

  if lm, ok := t.Listen[key]; ok {
    return lm
  }
  return nil
}

// AppendListen appends the supplied IETFSnmp_Snmp_Engine_Listen struct to the
// list Listen of IETFSnmp_Snmp_Engine. If the key value(s) specified in
// the supplied IETFSnmp_Snmp_Engine_Listen already exist in the list, an error is
// returned.
func (t *IETFSnmp_Snmp_Engine) AppendListen(v *IETFSnmp_Snmp_Engine_Listen) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Listen == nil {
		t.Listen = make(map[string]*IETFSnmp_Snmp_Engine_Listen)
	}

	if _, ok := t.Listen[key]; ok {
		return fmt.Errorf("duplicate key for list Listen %v", key)
	}

	t.Listen[key] = v
	return nil
}

// GetOrCreateVersion retrieves the value of the Version field
// or returns the existing field if it already exists.
func (t *IETFSnmp_Snmp_Engine) GetOrCreateVersion() *IETFSnmp_Snmp_Engine_Version {
	if t.Version != nil {
		return t.Version
	}
	t.Version = &IETFSnmp_Snmp_Engine_Version{}
	return t.Version
}

// GetVersion returns the value of the Version struct pointer
// from IETFSnmp_Snmp_Engine. If the receiver or the field Version is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IETFSnmp_Snmp_Engine) GetVersion() *IETFSnmp_Snmp_Engine_Version {
	if t != nil && t.Version != nil {
		return t.Version
	}
	return nil
}

// GetEnableAuthenTraps retrieves the value of the leaf EnableAuthenTraps from the IETFSnmp_Snmp_Engine
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EnableAuthenTraps is set, it can
// safely use t.GetEnableAuthenTraps() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EnableAuthenTraps == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Engine) GetEnableAuthenTraps() bool {
	if t == nil || t.EnableAuthenTraps == nil {
		return false
	}
	return *t.EnableAuthenTraps
}

// GetEnabled retrieves the value of the leaf Enabled from the IETFSnmp_Snmp_Engine
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Engine) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return false
	}
	return *t.Enabled
}

// GetEngineId retrieves the value of the leaf EngineId from the IETFSnmp_Snmp_Engine
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EngineId is set, it can
// safely use t.GetEngineId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EngineId == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Engine) GetEngineId() string {
	if t == nil || t.EngineId == nil {
		return ""
	}
	return *t.EngineId
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Engine) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_Engine"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Engine) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_Engine) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_Engine.
func (*IETFSnmp_Snmp_Engine) ΛBelongingModule() string {
	return "ietf-snmp"
}


// IETFSnmp_Snmp_Engine_Listen represents the /ietf-snmp/snmp/engine/listen YANG schema element.
type IETFSnmp_Snmp_Engine_Listen struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Dtls	*IETFSnmp_Snmp_Engine_Listen_Dtls	`path:"dtls" module:"ietf-snmp"`
	ΛDtls	[]ygot.Annotation	`path:"@dtls" ygotAnnotation:"true"`
	Name	*string	`path:"name" module:"ietf-snmp"`
	ΛName	[]ygot.Annotation	`path:"@name" ygotAnnotation:"true"`
	Ssh	*IETFSnmp_Snmp_Engine_Listen_Ssh	`path:"ssh" module:"ietf-snmp"`
	ΛSsh	[]ygot.Annotation	`path:"@ssh" ygotAnnotation:"true"`
	Tls	*IETFSnmp_Snmp_Engine_Listen_Tls	`path:"tls" module:"ietf-snmp"`
	ΛTls	[]ygot.Annotation	`path:"@tls" ygotAnnotation:"true"`
	Udp	*IETFSnmp_Snmp_Engine_Listen_Udp	`path:"udp" module:"ietf-snmp"`
	ΛUdp	[]ygot.Annotation	`path:"@udp" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_Engine_Listen implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_Engine_Listen) IsYANGGoStruct() {}

// GetOrCreateDtls retrieves the value of the Dtls field
// or returns the existing field if it already exists.
func (t *IETFSnmp_Snmp_Engine_Listen) GetOrCreateDtls() *IETFSnmp_Snmp_Engine_Listen_Dtls {
	if t.Dtls != nil {
		return t.Dtls
	}
	t.Dtls = &IETFSnmp_Snmp_Engine_Listen_Dtls{}
	return t.Dtls
}

// GetOrCreateSsh retrieves the value of the Ssh field
// or returns the existing field if it already exists.
func (t *IETFSnmp_Snmp_Engine_Listen) GetOrCreateSsh() *IETFSnmp_Snmp_Engine_Listen_Ssh {
	if t.Ssh != nil {
		return t.Ssh
	}
	t.Ssh = &IETFSnmp_Snmp_Engine_Listen_Ssh{}
	return t.Ssh
}

// GetOrCreateTls retrieves the value of the Tls field
// or returns the existing field if it already exists.
func (t *IETFSnmp_Snmp_Engine_Listen) GetOrCreateTls() *IETFSnmp_Snmp_Engine_Listen_Tls {
	if t.Tls != nil {
		return t.Tls
	}
	t.Tls = &IETFSnmp_Snmp_Engine_Listen_Tls{}
	return t.Tls
}

// GetOrCreateUdp retrieves the value of the Udp field
// or returns the existing field if it already exists.
func (t *IETFSnmp_Snmp_Engine_Listen) GetOrCreateUdp() *IETFSnmp_Snmp_Engine_Listen_Udp {
	if t.Udp != nil {
		return t.Udp
	}
	t.Udp = &IETFSnmp_Snmp_Engine_Listen_Udp{}
	return t.Udp
}

// GetDtls returns the value of the Dtls struct pointer
// from IETFSnmp_Snmp_Engine_Listen. If the receiver or the field Dtls is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IETFSnmp_Snmp_Engine_Listen) GetDtls() *IETFSnmp_Snmp_Engine_Listen_Dtls {
	if t != nil && t.Dtls != nil {
		return t.Dtls
	}
	return nil
}

// GetSsh returns the value of the Ssh struct pointer
// from IETFSnmp_Snmp_Engine_Listen. If the receiver or the field Ssh is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IETFSnmp_Snmp_Engine_Listen) GetSsh() *IETFSnmp_Snmp_Engine_Listen_Ssh {
	if t != nil && t.Ssh != nil {
		return t.Ssh
	}
	return nil
}

// GetTls returns the value of the Tls struct pointer
// from IETFSnmp_Snmp_Engine_Listen. If the receiver or the field Tls is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IETFSnmp_Snmp_Engine_Listen) GetTls() *IETFSnmp_Snmp_Engine_Listen_Tls {
	if t != nil && t.Tls != nil {
		return t.Tls
	}
	return nil
}

// GetUdp returns the value of the Udp struct pointer
// from IETFSnmp_Snmp_Engine_Listen. If the receiver or the field Udp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IETFSnmp_Snmp_Engine_Listen) GetUdp() *IETFSnmp_Snmp_Engine_Listen_Udp {
	if t != nil && t.Udp != nil {
		return t.Udp
	}
	return nil
}

// GetName retrieves the value of the leaf Name from the IETFSnmp_Snmp_Engine_Listen
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Engine_Listen) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// ΛListKeyMap returns the keys of the IETFSnmp_Snmp_Engine_Listen struct, which is a YANG list entry.
func (t *IETFSnmp_Snmp_Engine_Listen) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Engine_Listen) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_Engine_Listen"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Engine_Listen) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_Engine_Listen) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_Engine_Listen.
func (*IETFSnmp_Snmp_Engine_Listen) ΛBelongingModule() string {
	return "ietf-snmp"
}


// IETFSnmp_Snmp_Engine_Listen_Dtls represents the /ietf-snmp/snmp/engine/listen/dtls YANG schema element.
type IETFSnmp_Snmp_Engine_Listen_Dtls struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Ip	*string	`path:"ip" module:"ietf-snmp"`
	ΛIp	[]ygot.Annotation	`path:"@ip" ygotAnnotation:"true"`
	Port	*uint16	`path:"port" module:"ietf-snmp"`
	ΛPort	[]ygot.Annotation	`path:"@port" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_Engine_Listen_Dtls implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_Engine_Listen_Dtls) IsYANGGoStruct() {}

// GetIp retrieves the value of the leaf Ip from the IETFSnmp_Snmp_Engine_Listen_Dtls
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ip is set, it can
// safely use t.GetIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ip == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Engine_Listen_Dtls) GetIp() string {
	if t == nil || t.Ip == nil {
		return ""
	}
	return *t.Ip
}

// GetPort retrieves the value of the leaf Port from the IETFSnmp_Snmp_Engine_Listen_Dtls
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Port is set, it can
// safely use t.GetPort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Port == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Engine_Listen_Dtls) GetPort() uint16 {
	if t == nil || t.Port == nil {
		return 0
	}
	return *t.Port
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Engine_Listen_Dtls) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_Engine_Listen_Dtls"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Engine_Listen_Dtls) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_Engine_Listen_Dtls) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_Engine_Listen_Dtls.
func (*IETFSnmp_Snmp_Engine_Listen_Dtls) ΛBelongingModule() string {
	return "ietf-snmp"
}


// IETFSnmp_Snmp_Engine_Listen_Ssh represents the /ietf-snmp/snmp/engine/listen/ssh YANG schema element.
type IETFSnmp_Snmp_Engine_Listen_Ssh struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Ip	*string	`path:"ip" module:"ietf-snmp"`
	ΛIp	[]ygot.Annotation	`path:"@ip" ygotAnnotation:"true"`
	Port	*uint16	`path:"port" module:"ietf-snmp"`
	ΛPort	[]ygot.Annotation	`path:"@port" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_Engine_Listen_Ssh implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_Engine_Listen_Ssh) IsYANGGoStruct() {}

// GetIp retrieves the value of the leaf Ip from the IETFSnmp_Snmp_Engine_Listen_Ssh
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ip is set, it can
// safely use t.GetIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ip == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Engine_Listen_Ssh) GetIp() string {
	if t == nil || t.Ip == nil {
		return ""
	}
	return *t.Ip
}

// GetPort retrieves the value of the leaf Port from the IETFSnmp_Snmp_Engine_Listen_Ssh
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Port is set, it can
// safely use t.GetPort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Port == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Engine_Listen_Ssh) GetPort() uint16 {
	if t == nil || t.Port == nil {
		return 0
	}
	return *t.Port
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Engine_Listen_Ssh) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_Engine_Listen_Ssh"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Engine_Listen_Ssh) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_Engine_Listen_Ssh) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_Engine_Listen_Ssh.
func (*IETFSnmp_Snmp_Engine_Listen_Ssh) ΛBelongingModule() string {
	return "ietf-snmp"
}


// IETFSnmp_Snmp_Engine_Listen_Tls represents the /ietf-snmp/snmp/engine/listen/tls YANG schema element.
type IETFSnmp_Snmp_Engine_Listen_Tls struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Ip	*string	`path:"ip" module:"ietf-snmp"`
	ΛIp	[]ygot.Annotation	`path:"@ip" ygotAnnotation:"true"`
	Port	*uint16	`path:"port" module:"ietf-snmp"`
	ΛPort	[]ygot.Annotation	`path:"@port" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_Engine_Listen_Tls implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_Engine_Listen_Tls) IsYANGGoStruct() {}

// GetIp retrieves the value of the leaf Ip from the IETFSnmp_Snmp_Engine_Listen_Tls
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ip is set, it can
// safely use t.GetIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ip == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Engine_Listen_Tls) GetIp() string {
	if t == nil || t.Ip == nil {
		return ""
	}
	return *t.Ip
}

// GetPort retrieves the value of the leaf Port from the IETFSnmp_Snmp_Engine_Listen_Tls
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Port is set, it can
// safely use t.GetPort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Port == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Engine_Listen_Tls) GetPort() uint16 {
	if t == nil || t.Port == nil {
		return 0
	}
	return *t.Port
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Engine_Listen_Tls) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_Engine_Listen_Tls"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Engine_Listen_Tls) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_Engine_Listen_Tls) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_Engine_Listen_Tls.
func (*IETFSnmp_Snmp_Engine_Listen_Tls) ΛBelongingModule() string {
	return "ietf-snmp"
}


// IETFSnmp_Snmp_Engine_Listen_Udp represents the /ietf-snmp/snmp/engine/listen/udp YANG schema element.
type IETFSnmp_Snmp_Engine_Listen_Udp struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Ip	*string	`path:"ip" module:"ietf-snmp"`
	ΛIp	[]ygot.Annotation	`path:"@ip" ygotAnnotation:"true"`
	Port	*uint16	`path:"port" module:"ietf-snmp"`
	ΛPort	[]ygot.Annotation	`path:"@port" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_Engine_Listen_Udp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_Engine_Listen_Udp) IsYANGGoStruct() {}

// GetIp retrieves the value of the leaf Ip from the IETFSnmp_Snmp_Engine_Listen_Udp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ip is set, it can
// safely use t.GetIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ip == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Engine_Listen_Udp) GetIp() string {
	if t == nil || t.Ip == nil {
		return ""
	}
	return *t.Ip
}

// GetPort retrieves the value of the leaf Port from the IETFSnmp_Snmp_Engine_Listen_Udp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Port is set, it can
// safely use t.GetPort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Port == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Engine_Listen_Udp) GetPort() uint16 {
	if t == nil || t.Port == nil {
		return 0
	}
	return *t.Port
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Engine_Listen_Udp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_Engine_Listen_Udp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Engine_Listen_Udp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_Engine_Listen_Udp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_Engine_Listen_Udp.
func (*IETFSnmp_Snmp_Engine_Listen_Udp) ΛBelongingModule() string {
	return "ietf-snmp"
}


// IETFSnmp_Snmp_Engine_Version represents the /ietf-snmp/snmp/engine/version YANG schema element.
type IETFSnmp_Snmp_Engine_Version struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	V1	YANGEmpty	`path:"v1" module:"ietf-snmp"`
	ΛV1	[]ygot.Annotation	`path:"@v1" ygotAnnotation:"true"`
	V2C	YANGEmpty	`path:"v2c" module:"ietf-snmp"`
	ΛV2C	[]ygot.Annotation	`path:"@v2c" ygotAnnotation:"true"`
	V3	YANGEmpty	`path:"v3" module:"ietf-snmp"`
	ΛV3	[]ygot.Annotation	`path:"@v3" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_Engine_Version implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_Engine_Version) IsYANGGoStruct() {}

// GetV1 retrieves the value of the leaf V1 from the IETFSnmp_Snmp_Engine_Version
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if V1 is set, it can
// safely use t.GetV1() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.V1 == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Engine_Version) GetV1() YANGEmpty {
	if t == nil || t.V1 ==  false {
		return false
	}
	return t.V1
}

// GetV2C retrieves the value of the leaf V2C from the IETFSnmp_Snmp_Engine_Version
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if V2C is set, it can
// safely use t.GetV2C() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.V2C == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Engine_Version) GetV2C() YANGEmpty {
	if t == nil || t.V2C ==  false {
		return false
	}
	return t.V2C
}

// GetV3 retrieves the value of the leaf V3 from the IETFSnmp_Snmp_Engine_Version
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if V3 is set, it can
// safely use t.GetV3() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.V3 == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Engine_Version) GetV3() YANGEmpty {
	if t == nil || t.V3 ==  false {
		return false
	}
	return t.V3
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Engine_Version) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_Engine_Version"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Engine_Version) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_Engine_Version) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_Engine_Version.
func (*IETFSnmp_Snmp_Engine_Version) ΛBelongingModule() string {
	return "ietf-snmp"
}


// IETFSnmp_Snmp_Notify represents the /ietf-snmp/snmp/notify YANG schema element.
type IETFSnmp_Snmp_Notify struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Name	*string	`path:"name" module:"ietf-snmp"`
	ΛName	[]ygot.Annotation	`path:"@name" ygotAnnotation:"true"`
	Tag	*string	`path:"tag" module:"ietf-snmp"`
	ΛTag	[]ygot.Annotation	`path:"@tag" ygotAnnotation:"true"`
	Type	E_IETFSnmp_Snmp_Notify_Type	`path:"type" module:"ietf-snmp"`
	ΛType	[]ygot.Annotation	`path:"@type" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_Notify implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_Notify) IsYANGGoStruct() {}

// GetName retrieves the value of the leaf Name from the IETFSnmp_Snmp_Notify
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Notify) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetTag retrieves the value of the leaf Tag from the IETFSnmp_Snmp_Notify
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Tag is set, it can
// safely use t.GetTag() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Tag == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Notify) GetTag() string {
	if t == nil || t.Tag == nil {
		return ""
	}
	return *t.Tag
}

// GetType retrieves the value of the leaf Type from the IETFSnmp_Snmp_Notify
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Notify) GetType() E_IETFSnmp_Snmp_Notify_Type {
	if t == nil || t.Type ==  0 {
		return IETFSnmp_Snmp_Notify_Type_trap
	}
	return t.Type
}

// ΛListKeyMap returns the keys of the IETFSnmp_Snmp_Notify struct, which is a YANG list entry.
func (t *IETFSnmp_Snmp_Notify) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Notify) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_Notify"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Notify) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_Notify) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_Notify.
func (*IETFSnmp_Snmp_Notify) ΛBelongingModule() string {
	return "ietf-snmp"
}


// IETFSnmp_Snmp_NotifyFilterProfile represents the /ietf-snmp/snmp/notify-filter-profile YANG schema element.
type IETFSnmp_Snmp_NotifyFilterProfile struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Exclude	[]string	`path:"exclude" module:"ietf-snmp"`
	ΛExclude	[]ygot.Annotation	`path:"@exclude" ygotAnnotation:"true"`
	Include	[]string	`path:"include" module:"ietf-snmp"`
	ΛInclude	[]ygot.Annotation	`path:"@include" ygotAnnotation:"true"`
	Name	*string	`path:"name" module:"ietf-snmp"`
	ΛName	[]ygot.Annotation	`path:"@name" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_NotifyFilterProfile implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_NotifyFilterProfile) IsYANGGoStruct() {}

// GetExclude retrieves the value of the leaf Exclude from the IETFSnmp_Snmp_NotifyFilterProfile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Exclude is set, it can
// safely use t.GetExclude() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Exclude == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_NotifyFilterProfile) GetExclude() []string {
	if t == nil || t.Exclude ==  nil {
		return nil
	}
	return t.Exclude
}

// GetInclude retrieves the value of the leaf Include from the IETFSnmp_Snmp_NotifyFilterProfile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Include is set, it can
// safely use t.GetInclude() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Include == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_NotifyFilterProfile) GetInclude() []string {
	if t == nil || t.Include ==  nil {
		return nil
	}
	return t.Include
}

// GetName retrieves the value of the leaf Name from the IETFSnmp_Snmp_NotifyFilterProfile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_NotifyFilterProfile) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// ΛListKeyMap returns the keys of the IETFSnmp_Snmp_NotifyFilterProfile struct, which is a YANG list entry.
func (t *IETFSnmp_Snmp_NotifyFilterProfile) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_NotifyFilterProfile) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_NotifyFilterProfile"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_NotifyFilterProfile) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_NotifyFilterProfile) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_NotifyFilterProfile.
func (*IETFSnmp_Snmp_NotifyFilterProfile) ΛBelongingModule() string {
	return "ietf-snmp"
}


// IETFSnmp_Snmp_Proxy represents the /ietf-snmp/snmp/proxy YANG schema element.
type IETFSnmp_Snmp_Proxy struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	ContextEngineId	*string	`path:"context-engine-id" module:"ietf-snmp"`
	ΛContextEngineId	[]ygot.Annotation	`path:"@context-engine-id" ygotAnnotation:"true"`
	ContextName	*string	`path:"context-name" module:"ietf-snmp"`
	ΛContextName	[]ygot.Annotation	`path:"@context-name" ygotAnnotation:"true"`
	MultipleTargetOut	*string	`path:"multiple-target-out" module:"ietf-snmp"`
	ΛMultipleTargetOut	[]ygot.Annotation	`path:"@multiple-target-out" ygotAnnotation:"true"`
	Name	*string	`path:"name" module:"ietf-snmp"`
	ΛName	[]ygot.Annotation	`path:"@name" ygotAnnotation:"true"`
	SingleTargetOut	*string	`path:"single-target-out" module:"ietf-snmp"`
	ΛSingleTargetOut	[]ygot.Annotation	`path:"@single-target-out" ygotAnnotation:"true"`
	TargetParamsIn	*string	`path:"target-params-in" module:"ietf-snmp"`
	ΛTargetParamsIn	[]ygot.Annotation	`path:"@target-params-in" ygotAnnotation:"true"`
	Type	E_IETFSnmp_Snmp_Proxy_Type	`path:"type" module:"ietf-snmp"`
	ΛType	[]ygot.Annotation	`path:"@type" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_Proxy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_Proxy) IsYANGGoStruct() {}

// GetContextEngineId retrieves the value of the leaf ContextEngineId from the IETFSnmp_Snmp_Proxy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ContextEngineId is set, it can
// safely use t.GetContextEngineId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ContextEngineId == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Proxy) GetContextEngineId() string {
	if t == nil || t.ContextEngineId == nil {
		return ""
	}
	return *t.ContextEngineId
}

// GetContextName retrieves the value of the leaf ContextName from the IETFSnmp_Snmp_Proxy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ContextName is set, it can
// safely use t.GetContextName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ContextName == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Proxy) GetContextName() string {
	if t == nil || t.ContextName == nil {
		return ""
	}
	return *t.ContextName
}

// GetMultipleTargetOut retrieves the value of the leaf MultipleTargetOut from the IETFSnmp_Snmp_Proxy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MultipleTargetOut is set, it can
// safely use t.GetMultipleTargetOut() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MultipleTargetOut == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Proxy) GetMultipleTargetOut() string {
	if t == nil || t.MultipleTargetOut == nil {
		return ""
	}
	return *t.MultipleTargetOut
}

// GetName retrieves the value of the leaf Name from the IETFSnmp_Snmp_Proxy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Proxy) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetSingleTargetOut retrieves the value of the leaf SingleTargetOut from the IETFSnmp_Snmp_Proxy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SingleTargetOut is set, it can
// safely use t.GetSingleTargetOut() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SingleTargetOut == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Proxy) GetSingleTargetOut() string {
	if t == nil || t.SingleTargetOut == nil {
		return ""
	}
	return *t.SingleTargetOut
}

// GetTargetParamsIn retrieves the value of the leaf TargetParamsIn from the IETFSnmp_Snmp_Proxy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TargetParamsIn is set, it can
// safely use t.GetTargetParamsIn() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TargetParamsIn == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Proxy) GetTargetParamsIn() string {
	if t == nil || t.TargetParamsIn == nil {
		return ""
	}
	return *t.TargetParamsIn
}

// GetType retrieves the value of the leaf Type from the IETFSnmp_Snmp_Proxy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Proxy) GetType() E_IETFSnmp_Snmp_Proxy_Type {
	if t == nil || t.Type ==  0 {
		return 0
	}
	return t.Type
}

// ΛListKeyMap returns the keys of the IETFSnmp_Snmp_Proxy struct, which is a YANG list entry.
func (t *IETFSnmp_Snmp_Proxy) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Proxy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_Proxy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Proxy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_Proxy) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_Proxy.
func (*IETFSnmp_Snmp_Proxy) ΛBelongingModule() string {
	return "ietf-snmp"
}


// IETFSnmp_Snmp_Target represents the /ietf-snmp/snmp/target YANG schema element.
type IETFSnmp_Snmp_Target struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Dtls	*IETFSnmp_Snmp_Target_Dtls	`path:"dtls" module:"ietf-snmp"`
	ΛDtls	[]ygot.Annotation	`path:"@dtls" ygotAnnotation:"true"`
	Mms	IETFSnmp_Snmp_Target_Mms_Union	`path:"mms" module:"ietf-snmp"`
	ΛMms	[]ygot.Annotation	`path:"@mms" ygotAnnotation:"true"`
	Name	*string	`path:"name" module:"ietf-snmp"`
	ΛName	[]ygot.Annotation	`path:"@name" ygotAnnotation:"true"`
	Retries	*uint8	`path:"retries" module:"ietf-snmp"`
	ΛRetries	[]ygot.Annotation	`path:"@retries" ygotAnnotation:"true"`
	Ssh	*IETFSnmp_Snmp_Target_Ssh	`path:"ssh" module:"ietf-snmp"`
	ΛSsh	[]ygot.Annotation	`path:"@ssh" ygotAnnotation:"true"`
	Tag	[]string	`path:"tag" module:"ietf-snmp"`
	ΛTag	[]ygot.Annotation	`path:"@tag" ygotAnnotation:"true"`
	TargetParams	*string	`path:"target-params" module:"ietf-snmp"`
	ΛTargetParams	[]ygot.Annotation	`path:"@target-params" ygotAnnotation:"true"`
	Timeout	*uint32	`path:"timeout" module:"ietf-snmp"`
	ΛTimeout	[]ygot.Annotation	`path:"@timeout" ygotAnnotation:"true"`
	Tls	*IETFSnmp_Snmp_Target_Tls	`path:"tls" module:"ietf-snmp"`
	ΛTls	[]ygot.Annotation	`path:"@tls" ygotAnnotation:"true"`
	Udp	*IETFSnmp_Snmp_Target_Udp	`path:"udp" module:"ietf-snmp"`
	ΛUdp	[]ygot.Annotation	`path:"@udp" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_Target implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_Target) IsYANGGoStruct() {}

// GetOrCreateDtls retrieves the value of the Dtls field
// or returns the existing field if it already exists.
func (t *IETFSnmp_Snmp_Target) GetOrCreateDtls() *IETFSnmp_Snmp_Target_Dtls {
	if t.Dtls != nil {
		return t.Dtls
	}
	t.Dtls = &IETFSnmp_Snmp_Target_Dtls{}
	return t.Dtls
}

// GetOrCreateSsh retrieves the value of the Ssh field
// or returns the existing field if it already exists.
func (t *IETFSnmp_Snmp_Target) GetOrCreateSsh() *IETFSnmp_Snmp_Target_Ssh {
	if t.Ssh != nil {
		return t.Ssh
	}
	t.Ssh = &IETFSnmp_Snmp_Target_Ssh{}
	return t.Ssh
}

// GetOrCreateTls retrieves the value of the Tls field
// or returns the existing field if it already exists.
func (t *IETFSnmp_Snmp_Target) GetOrCreateTls() *IETFSnmp_Snmp_Target_Tls {
	if t.Tls != nil {
		return t.Tls
	}
	t.Tls = &IETFSnmp_Snmp_Target_Tls{}
	return t.Tls
}

// GetOrCreateUdp retrieves the value of the Udp field
// or returns the existing field if it already exists.
func (t *IETFSnmp_Snmp_Target) GetOrCreateUdp() *IETFSnmp_Snmp_Target_Udp {
	if t.Udp != nil {
		return t.Udp
	}
	t.Udp = &IETFSnmp_Snmp_Target_Udp{}
	return t.Udp
}

// GetDtls returns the value of the Dtls struct pointer
// from IETFSnmp_Snmp_Target. If the receiver or the field Dtls is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IETFSnmp_Snmp_Target) GetDtls() *IETFSnmp_Snmp_Target_Dtls {
	if t != nil && t.Dtls != nil {
		return t.Dtls
	}
	return nil
}

// GetSsh returns the value of the Ssh struct pointer
// from IETFSnmp_Snmp_Target. If the receiver or the field Ssh is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IETFSnmp_Snmp_Target) GetSsh() *IETFSnmp_Snmp_Target_Ssh {
	if t != nil && t.Ssh != nil {
		return t.Ssh
	}
	return nil
}

// GetTls returns the value of the Tls struct pointer
// from IETFSnmp_Snmp_Target. If the receiver or the field Tls is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IETFSnmp_Snmp_Target) GetTls() *IETFSnmp_Snmp_Target_Tls {
	if t != nil && t.Tls != nil {
		return t.Tls
	}
	return nil
}

// GetUdp returns the value of the Udp struct pointer
// from IETFSnmp_Snmp_Target. If the receiver or the field Udp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IETFSnmp_Snmp_Target) GetUdp() *IETFSnmp_Snmp_Target_Udp {
	if t != nil && t.Udp != nil {
		return t.Udp
	}
	return nil
}

// GetMms retrieves the value of the leaf Mms from the IETFSnmp_Snmp_Target
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mms is set, it can
// safely use t.GetMms() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mms == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Target) GetMms() IETFSnmp_Snmp_Target_Mms_Union {
	if t == nil || t.Mms ==  nil {
		return UnionInt32(484)
	}
	return t.Mms
}

// GetName retrieves the value of the leaf Name from the IETFSnmp_Snmp_Target
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Target) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetRetries retrieves the value of the leaf Retries from the IETFSnmp_Snmp_Target
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Retries is set, it can
// safely use t.GetRetries() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Retries == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Target) GetRetries() uint8 {
	if t == nil || t.Retries == nil {
		return 3
	}
	return *t.Retries
}

// GetTag retrieves the value of the leaf Tag from the IETFSnmp_Snmp_Target
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Tag is set, it can
// safely use t.GetTag() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Tag == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Target) GetTag() []string {
	if t == nil || t.Tag ==  nil {
		return nil
	}
	return t.Tag
}

// GetTargetParams retrieves the value of the leaf TargetParams from the IETFSnmp_Snmp_Target
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TargetParams is set, it can
// safely use t.GetTargetParams() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TargetParams == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Target) GetTargetParams() string {
	if t == nil || t.TargetParams == nil {
		return ""
	}
	return *t.TargetParams
}

// GetTimeout retrieves the value of the leaf Timeout from the IETFSnmp_Snmp_Target
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Timeout is set, it can
// safely use t.GetTimeout() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Timeout == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Target) GetTimeout() uint32 {
	if t == nil || t.Timeout == nil {
		return 1500
	}
	return *t.Timeout
}

// ΛListKeyMap returns the keys of the IETFSnmp_Snmp_Target struct, which is a YANG list entry.
func (t *IETFSnmp_Snmp_Target) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Target) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_Target"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Target) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_Target) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_Target.
func (*IETFSnmp_Snmp_Target) ΛBelongingModule() string {
	return "ietf-snmp"
}

// IETFSnmp_Snmp_Target_Mms_Union is an interface that is implemented by valid types for the union
// for the leaf /ietf-snmp/snmp/target/mms within the YANG schema.
// Union type can be one of [E_IETFSnmp_Snmp_Target_Mms_Enum, UnionInt32].
type IETFSnmp_Snmp_Target_Mms_Union interface {
	// Union type can be one of [E_IETFSnmp_Snmp_Target_Mms_Enum, UnionInt32]
	Documentation_for_IETFSnmp_Snmp_Target_Mms_Union()
}

// Documentation_for_IETFSnmp_Snmp_Target_Mms_Union ensures that E_IETFSnmp_Snmp_Target_Mms_Enum
// implements the IETFSnmp_Snmp_Target_Mms_Union interface.
func (E_IETFSnmp_Snmp_Target_Mms_Enum) Documentation_for_IETFSnmp_Snmp_Target_Mms_Union() {}

// Documentation_for_IETFSnmp_Snmp_Target_Mms_Union ensures that UnionInt32
// implements the IETFSnmp_Snmp_Target_Mms_Union interface.
func (UnionInt32) Documentation_for_IETFSnmp_Snmp_Target_Mms_Union() {}

// To_IETFSnmp_Snmp_Target_Mms_Union takes an input interface{} and attempts to convert it to a struct
// which implements the IETFSnmp_Snmp_Target_Mms_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *IETFSnmp_Snmp_Target) To_IETFSnmp_Snmp_Target_Mms_Union(i interface{}) (IETFSnmp_Snmp_Target_Mms_Union, error) {
	if v, ok := i.(IETFSnmp_Snmp_Target_Mms_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case int32:
		return UnionInt32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to IETFSnmp_Snmp_Target_Mms_Union, unknown union type, got: %T, want any of [E_IETFSnmp_Snmp_Target_Mms_Enum, int32]", i, i)
}


// IETFSnmp_Snmp_TargetParams represents the /ietf-snmp/snmp/target-params YANG schema element.
type IETFSnmp_Snmp_TargetParams struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Name	*string	`path:"name" module:"ietf-snmp"`
	ΛName	[]ygot.Annotation	`path:"@name" ygotAnnotation:"true"`
	NotifyFilterProfile	*string	`path:"notify-filter-profile" module:"ietf-snmp"`
	ΛNotifyFilterProfile	[]ygot.Annotation	`path:"@notify-filter-profile" ygotAnnotation:"true"`
	Tsm	*IETFSnmp_Snmp_TargetParams_Tsm	`path:"tsm" module:"ietf-snmp"`
	ΛTsm	[]ygot.Annotation	`path:"@tsm" ygotAnnotation:"true"`
	Usm	*IETFSnmp_Snmp_TargetParams_Usm	`path:"usm" module:"ietf-snmp"`
	ΛUsm	[]ygot.Annotation	`path:"@usm" ygotAnnotation:"true"`
	V1	*IETFSnmp_Snmp_TargetParams_V1	`path:"v1" module:"ietf-snmp"`
	ΛV1	[]ygot.Annotation	`path:"@v1" ygotAnnotation:"true"`
	V2C	*IETFSnmp_Snmp_TargetParams_V2C	`path:"v2c" module:"ietf-snmp"`
	ΛV2C	[]ygot.Annotation	`path:"@v2c" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_TargetParams implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_TargetParams) IsYANGGoStruct() {}

// GetOrCreateTsm retrieves the value of the Tsm field
// or returns the existing field if it already exists.
func (t *IETFSnmp_Snmp_TargetParams) GetOrCreateTsm() *IETFSnmp_Snmp_TargetParams_Tsm {
	if t.Tsm != nil {
		return t.Tsm
	}
	t.Tsm = &IETFSnmp_Snmp_TargetParams_Tsm{}
	return t.Tsm
}

// GetOrCreateUsm retrieves the value of the Usm field
// or returns the existing field if it already exists.
func (t *IETFSnmp_Snmp_TargetParams) GetOrCreateUsm() *IETFSnmp_Snmp_TargetParams_Usm {
	if t.Usm != nil {
		return t.Usm
	}
	t.Usm = &IETFSnmp_Snmp_TargetParams_Usm{}
	return t.Usm
}

// GetOrCreateV1 retrieves the value of the V1 field
// or returns the existing field if it already exists.
func (t *IETFSnmp_Snmp_TargetParams) GetOrCreateV1() *IETFSnmp_Snmp_TargetParams_V1 {
	if t.V1 != nil {
		return t.V1
	}
	t.V1 = &IETFSnmp_Snmp_TargetParams_V1{}
	return t.V1
}

// GetOrCreateV2C retrieves the value of the V2C field
// or returns the existing field if it already exists.
func (t *IETFSnmp_Snmp_TargetParams) GetOrCreateV2C() *IETFSnmp_Snmp_TargetParams_V2C {
	if t.V2C != nil {
		return t.V2C
	}
	t.V2C = &IETFSnmp_Snmp_TargetParams_V2C{}
	return t.V2C
}

// GetTsm returns the value of the Tsm struct pointer
// from IETFSnmp_Snmp_TargetParams. If the receiver or the field Tsm is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IETFSnmp_Snmp_TargetParams) GetTsm() *IETFSnmp_Snmp_TargetParams_Tsm {
	if t != nil && t.Tsm != nil {
		return t.Tsm
	}
	return nil
}

// GetUsm returns the value of the Usm struct pointer
// from IETFSnmp_Snmp_TargetParams. If the receiver or the field Usm is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IETFSnmp_Snmp_TargetParams) GetUsm() *IETFSnmp_Snmp_TargetParams_Usm {
	if t != nil && t.Usm != nil {
		return t.Usm
	}
	return nil
}

// GetV1 returns the value of the V1 struct pointer
// from IETFSnmp_Snmp_TargetParams. If the receiver or the field V1 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IETFSnmp_Snmp_TargetParams) GetV1() *IETFSnmp_Snmp_TargetParams_V1 {
	if t != nil && t.V1 != nil {
		return t.V1
	}
	return nil
}

// GetV2C returns the value of the V2C struct pointer
// from IETFSnmp_Snmp_TargetParams. If the receiver or the field V2C is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IETFSnmp_Snmp_TargetParams) GetV2C() *IETFSnmp_Snmp_TargetParams_V2C {
	if t != nil && t.V2C != nil {
		return t.V2C
	}
	return nil
}

// GetName retrieves the value of the leaf Name from the IETFSnmp_Snmp_TargetParams
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_TargetParams) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetNotifyFilterProfile retrieves the value of the leaf NotifyFilterProfile from the IETFSnmp_Snmp_TargetParams
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NotifyFilterProfile is set, it can
// safely use t.GetNotifyFilterProfile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NotifyFilterProfile == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_TargetParams) GetNotifyFilterProfile() string {
	if t == nil || t.NotifyFilterProfile == nil {
		return ""
	}
	return *t.NotifyFilterProfile
}

// ΛListKeyMap returns the keys of the IETFSnmp_Snmp_TargetParams struct, which is a YANG list entry.
func (t *IETFSnmp_Snmp_TargetParams) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_TargetParams) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_TargetParams"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_TargetParams) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_TargetParams) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_TargetParams.
func (*IETFSnmp_Snmp_TargetParams) ΛBelongingModule() string {
	return "ietf-snmp"
}


// IETFSnmp_Snmp_TargetParams_Tsm represents the /ietf-snmp/snmp/target-params/tsm YANG schema element.
type IETFSnmp_Snmp_TargetParams_Tsm struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	SecurityLevel	E_IETFSnmp_SecurityLevel	`path:"security-level" module:"ietf-snmp"`
	ΛSecurityLevel	[]ygot.Annotation	`path:"@security-level" ygotAnnotation:"true"`
	SecurityName	*string	`path:"security-name" module:"ietf-snmp"`
	ΛSecurityName	[]ygot.Annotation	`path:"@security-name" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_TargetParams_Tsm implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_TargetParams_Tsm) IsYANGGoStruct() {}

// GetSecurityLevel retrieves the value of the leaf SecurityLevel from the IETFSnmp_Snmp_TargetParams_Tsm
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SecurityLevel is set, it can
// safely use t.GetSecurityLevel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SecurityLevel == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_TargetParams_Tsm) GetSecurityLevel() E_IETFSnmp_SecurityLevel {
	if t == nil || t.SecurityLevel ==  0 {
		return 0
	}
	return t.SecurityLevel
}

// GetSecurityName retrieves the value of the leaf SecurityName from the IETFSnmp_Snmp_TargetParams_Tsm
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SecurityName is set, it can
// safely use t.GetSecurityName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SecurityName == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_TargetParams_Tsm) GetSecurityName() string {
	if t == nil || t.SecurityName == nil {
		return ""
	}
	return *t.SecurityName
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_TargetParams_Tsm) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_TargetParams_Tsm"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_TargetParams_Tsm) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_TargetParams_Tsm) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_TargetParams_Tsm.
func (*IETFSnmp_Snmp_TargetParams_Tsm) ΛBelongingModule() string {
	return "ietf-snmp"
}


// IETFSnmp_Snmp_TargetParams_Usm represents the /ietf-snmp/snmp/target-params/usm YANG schema element.
type IETFSnmp_Snmp_TargetParams_Usm struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	SecurityLevel	E_IETFSnmp_SecurityLevel	`path:"security-level" module:"ietf-snmp"`
	ΛSecurityLevel	[]ygot.Annotation	`path:"@security-level" ygotAnnotation:"true"`
	UserName	*string	`path:"user-name" module:"ietf-snmp"`
	ΛUserName	[]ygot.Annotation	`path:"@user-name" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_TargetParams_Usm implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_TargetParams_Usm) IsYANGGoStruct() {}

// GetSecurityLevel retrieves the value of the leaf SecurityLevel from the IETFSnmp_Snmp_TargetParams_Usm
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SecurityLevel is set, it can
// safely use t.GetSecurityLevel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SecurityLevel == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_TargetParams_Usm) GetSecurityLevel() E_IETFSnmp_SecurityLevel {
	if t == nil || t.SecurityLevel ==  0 {
		return 0
	}
	return t.SecurityLevel
}

// GetUserName retrieves the value of the leaf UserName from the IETFSnmp_Snmp_TargetParams_Usm
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UserName is set, it can
// safely use t.GetUserName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UserName == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_TargetParams_Usm) GetUserName() string {
	if t == nil || t.UserName == nil {
		return ""
	}
	return *t.UserName
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_TargetParams_Usm) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_TargetParams_Usm"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_TargetParams_Usm) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_TargetParams_Usm) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_TargetParams_Usm.
func (*IETFSnmp_Snmp_TargetParams_Usm) ΛBelongingModule() string {
	return "ietf-snmp"
}


// IETFSnmp_Snmp_TargetParams_V1 represents the /ietf-snmp/snmp/target-params/v1 YANG schema element.
type IETFSnmp_Snmp_TargetParams_V1 struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	SecurityName	*string	`path:"security-name" module:"ietf-snmp"`
	ΛSecurityName	[]ygot.Annotation	`path:"@security-name" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_TargetParams_V1 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_TargetParams_V1) IsYANGGoStruct() {}

// GetSecurityName retrieves the value of the leaf SecurityName from the IETFSnmp_Snmp_TargetParams_V1
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SecurityName is set, it can
// safely use t.GetSecurityName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SecurityName == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_TargetParams_V1) GetSecurityName() string {
	if t == nil || t.SecurityName == nil {
		return ""
	}
	return *t.SecurityName
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_TargetParams_V1) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_TargetParams_V1"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_TargetParams_V1) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_TargetParams_V1) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_TargetParams_V1.
func (*IETFSnmp_Snmp_TargetParams_V1) ΛBelongingModule() string {
	return "ietf-snmp"
}


// IETFSnmp_Snmp_TargetParams_V2C represents the /ietf-snmp/snmp/target-params/v2c YANG schema element.
type IETFSnmp_Snmp_TargetParams_V2C struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	SecurityName	*string	`path:"security-name" module:"ietf-snmp"`
	ΛSecurityName	[]ygot.Annotation	`path:"@security-name" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_TargetParams_V2C implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_TargetParams_V2C) IsYANGGoStruct() {}

// GetSecurityName retrieves the value of the leaf SecurityName from the IETFSnmp_Snmp_TargetParams_V2C
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SecurityName is set, it can
// safely use t.GetSecurityName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SecurityName == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_TargetParams_V2C) GetSecurityName() string {
	if t == nil || t.SecurityName == nil {
		return ""
	}
	return *t.SecurityName
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_TargetParams_V2C) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_TargetParams_V2C"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_TargetParams_V2C) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_TargetParams_V2C) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_TargetParams_V2C.
func (*IETFSnmp_Snmp_TargetParams_V2C) ΛBelongingModule() string {
	return "ietf-snmp"
}


// IETFSnmp_Snmp_Target_Dtls represents the /ietf-snmp/snmp/target/dtls YANG schema element.
type IETFSnmp_Snmp_Target_Dtls struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	ClientFingerprint	*string	`path:"client-fingerprint" module:"ietf-snmp"`
	ΛClientFingerprint	[]ygot.Annotation	`path:"@client-fingerprint" ygotAnnotation:"true"`
	Ip	*string	`path:"ip" module:"ietf-snmp"`
	ΛIp	[]ygot.Annotation	`path:"@ip" ygotAnnotation:"true"`
	Port	*uint16	`path:"port" module:"ietf-snmp"`
	ΛPort	[]ygot.Annotation	`path:"@port" ygotAnnotation:"true"`
	ServerFingerprint	*string	`path:"server-fingerprint" module:"ietf-snmp"`
	ΛServerFingerprint	[]ygot.Annotation	`path:"@server-fingerprint" ygotAnnotation:"true"`
	ServerIdentity	*string	`path:"server-identity" module:"ietf-snmp"`
	ΛServerIdentity	[]ygot.Annotation	`path:"@server-identity" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_Target_Dtls implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_Target_Dtls) IsYANGGoStruct() {}

// GetClientFingerprint retrieves the value of the leaf ClientFingerprint from the IETFSnmp_Snmp_Target_Dtls
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ClientFingerprint is set, it can
// safely use t.GetClientFingerprint() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ClientFingerprint == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Target_Dtls) GetClientFingerprint() string {
	if t == nil || t.ClientFingerprint == nil {
		return ""
	}
	return *t.ClientFingerprint
}

// GetIp retrieves the value of the leaf Ip from the IETFSnmp_Snmp_Target_Dtls
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ip is set, it can
// safely use t.GetIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ip == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Target_Dtls) GetIp() string {
	if t == nil || t.Ip == nil {
		return ""
	}
	return *t.Ip
}

// GetPort retrieves the value of the leaf Port from the IETFSnmp_Snmp_Target_Dtls
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Port is set, it can
// safely use t.GetPort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Port == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Target_Dtls) GetPort() uint16 {
	if t == nil || t.Port == nil {
		return 10161
	}
	return *t.Port
}

// GetServerFingerprint retrieves the value of the leaf ServerFingerprint from the IETFSnmp_Snmp_Target_Dtls
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ServerFingerprint is set, it can
// safely use t.GetServerFingerprint() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ServerFingerprint == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Target_Dtls) GetServerFingerprint() string {
	if t == nil || t.ServerFingerprint == nil {
		return ""
	}
	return *t.ServerFingerprint
}

// GetServerIdentity retrieves the value of the leaf ServerIdentity from the IETFSnmp_Snmp_Target_Dtls
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ServerIdentity is set, it can
// safely use t.GetServerIdentity() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ServerIdentity == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Target_Dtls) GetServerIdentity() string {
	if t == nil || t.ServerIdentity == nil {
		return ""
	}
	return *t.ServerIdentity
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Target_Dtls) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_Target_Dtls"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Target_Dtls) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_Target_Dtls) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_Target_Dtls.
func (*IETFSnmp_Snmp_Target_Dtls) ΛBelongingModule() string {
	return "ietf-snmp"
}


// IETFSnmp_Snmp_Target_Ssh represents the /ietf-snmp/snmp/target/ssh YANG schema element.
type IETFSnmp_Snmp_Target_Ssh struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Ip	*string	`path:"ip" module:"ietf-snmp"`
	ΛIp	[]ygot.Annotation	`path:"@ip" ygotAnnotation:"true"`
	Port	*uint16	`path:"port" module:"ietf-snmp"`
	ΛPort	[]ygot.Annotation	`path:"@port" ygotAnnotation:"true"`
	Username	*string	`path:"username" module:"ietf-snmp"`
	ΛUsername	[]ygot.Annotation	`path:"@username" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_Target_Ssh implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_Target_Ssh) IsYANGGoStruct() {}

// GetIp retrieves the value of the leaf Ip from the IETFSnmp_Snmp_Target_Ssh
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ip is set, it can
// safely use t.GetIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ip == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Target_Ssh) GetIp() string {
	if t == nil || t.Ip == nil {
		return ""
	}
	return *t.Ip
}

// GetPort retrieves the value of the leaf Port from the IETFSnmp_Snmp_Target_Ssh
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Port is set, it can
// safely use t.GetPort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Port == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Target_Ssh) GetPort() uint16 {
	if t == nil || t.Port == nil {
		return 5161
	}
	return *t.Port
}

// GetUsername retrieves the value of the leaf Username from the IETFSnmp_Snmp_Target_Ssh
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Username is set, it can
// safely use t.GetUsername() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Username == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Target_Ssh) GetUsername() string {
	if t == nil || t.Username == nil {
		return ""
	}
	return *t.Username
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Target_Ssh) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_Target_Ssh"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Target_Ssh) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_Target_Ssh) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_Target_Ssh.
func (*IETFSnmp_Snmp_Target_Ssh) ΛBelongingModule() string {
	return "ietf-snmp"
}


// IETFSnmp_Snmp_Target_Tls represents the /ietf-snmp/snmp/target/tls YANG schema element.
type IETFSnmp_Snmp_Target_Tls struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	ClientFingerprint	*string	`path:"client-fingerprint" module:"ietf-snmp"`
	ΛClientFingerprint	[]ygot.Annotation	`path:"@client-fingerprint" ygotAnnotation:"true"`
	Ip	*string	`path:"ip" module:"ietf-snmp"`
	ΛIp	[]ygot.Annotation	`path:"@ip" ygotAnnotation:"true"`
	Port	*uint16	`path:"port" module:"ietf-snmp"`
	ΛPort	[]ygot.Annotation	`path:"@port" ygotAnnotation:"true"`
	ServerFingerprint	*string	`path:"server-fingerprint" module:"ietf-snmp"`
	ΛServerFingerprint	[]ygot.Annotation	`path:"@server-fingerprint" ygotAnnotation:"true"`
	ServerIdentity	*string	`path:"server-identity" module:"ietf-snmp"`
	ΛServerIdentity	[]ygot.Annotation	`path:"@server-identity" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_Target_Tls implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_Target_Tls) IsYANGGoStruct() {}

// GetClientFingerprint retrieves the value of the leaf ClientFingerprint from the IETFSnmp_Snmp_Target_Tls
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ClientFingerprint is set, it can
// safely use t.GetClientFingerprint() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ClientFingerprint == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Target_Tls) GetClientFingerprint() string {
	if t == nil || t.ClientFingerprint == nil {
		return ""
	}
	return *t.ClientFingerprint
}

// GetIp retrieves the value of the leaf Ip from the IETFSnmp_Snmp_Target_Tls
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ip is set, it can
// safely use t.GetIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ip == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Target_Tls) GetIp() string {
	if t == nil || t.Ip == nil {
		return ""
	}
	return *t.Ip
}

// GetPort retrieves the value of the leaf Port from the IETFSnmp_Snmp_Target_Tls
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Port is set, it can
// safely use t.GetPort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Port == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Target_Tls) GetPort() uint16 {
	if t == nil || t.Port == nil {
		return 10161
	}
	return *t.Port
}

// GetServerFingerprint retrieves the value of the leaf ServerFingerprint from the IETFSnmp_Snmp_Target_Tls
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ServerFingerprint is set, it can
// safely use t.GetServerFingerprint() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ServerFingerprint == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Target_Tls) GetServerFingerprint() string {
	if t == nil || t.ServerFingerprint == nil {
		return ""
	}
	return *t.ServerFingerprint
}

// GetServerIdentity retrieves the value of the leaf ServerIdentity from the IETFSnmp_Snmp_Target_Tls
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ServerIdentity is set, it can
// safely use t.GetServerIdentity() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ServerIdentity == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Target_Tls) GetServerIdentity() string {
	if t == nil || t.ServerIdentity == nil {
		return ""
	}
	return *t.ServerIdentity
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Target_Tls) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_Target_Tls"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Target_Tls) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_Target_Tls) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_Target_Tls.
func (*IETFSnmp_Snmp_Target_Tls) ΛBelongingModule() string {
	return "ietf-snmp"
}


// IETFSnmp_Snmp_Target_Udp represents the /ietf-snmp/snmp/target/udp YANG schema element.
type IETFSnmp_Snmp_Target_Udp struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Ip	*string	`path:"ip" module:"ietf-snmp"`
	ΛIp	[]ygot.Annotation	`path:"@ip" ygotAnnotation:"true"`
	Port	*uint16	`path:"port" module:"ietf-snmp"`
	ΛPort	[]ygot.Annotation	`path:"@port" ygotAnnotation:"true"`
	PrefixLength	*uint8	`path:"prefix-length" module:"ietf-snmp"`
	ΛPrefixLength	[]ygot.Annotation	`path:"@prefix-length" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_Target_Udp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_Target_Udp) IsYANGGoStruct() {}

// GetIp retrieves the value of the leaf Ip from the IETFSnmp_Snmp_Target_Udp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ip is set, it can
// safely use t.GetIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ip == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Target_Udp) GetIp() string {
	if t == nil || t.Ip == nil {
		return ""
	}
	return *t.Ip
}

// GetPort retrieves the value of the leaf Port from the IETFSnmp_Snmp_Target_Udp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Port is set, it can
// safely use t.GetPort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Port == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Target_Udp) GetPort() uint16 {
	if t == nil || t.Port == nil {
		return 162
	}
	return *t.Port
}

// GetPrefixLength retrieves the value of the leaf PrefixLength from the IETFSnmp_Snmp_Target_Udp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PrefixLength is set, it can
// safely use t.GetPrefixLength() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PrefixLength == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Target_Udp) GetPrefixLength() uint8 {
	if t == nil || t.PrefixLength == nil {
		return 0
	}
	return *t.PrefixLength
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Target_Udp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_Target_Udp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Target_Udp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_Target_Udp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_Target_Udp.
func (*IETFSnmp_Snmp_Target_Udp) ΛBelongingModule() string {
	return "ietf-snmp"
}


// IETFSnmp_Snmp_Tlstm represents the /ietf-snmp/snmp/tlstm YANG schema element.
type IETFSnmp_Snmp_Tlstm struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	CertToName	map[uint32]*IETFSnmp_Snmp_Tlstm_CertToName	`path:"cert-to-name" module:"ietf-snmp"`
	ΛCertToName	[]ygot.Annotation	`path:"@cert-to-name" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_Tlstm implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_Tlstm) IsYANGGoStruct() {}

// NewCertToName creates a new entry in the CertToName list of the
// IETFSnmp_Snmp_Tlstm struct. The keys of the list are populated from the input
// arguments.
func (t *IETFSnmp_Snmp_Tlstm) NewCertToName(Id uint32) (*IETFSnmp_Snmp_Tlstm_CertToName, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.CertToName == nil {
		t.CertToName = make(map[uint32]*IETFSnmp_Snmp_Tlstm_CertToName)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.CertToName[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list CertToName", key)
	}

	t.CertToName[key] = &IETFSnmp_Snmp_Tlstm_CertToName{
		Id: &Id,
	}

	return t.CertToName[key], nil
}

// RenameCertToName renames an entry in the list CertToName within
// the IETFSnmp_Snmp_Tlstm struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *IETFSnmp_Snmp_Tlstm) RenameCertToName(oldK, newK uint32) error {
	if _, ok := t.CertToName[newK]; ok {
		return fmt.Errorf("key %v already exists in CertToName", newK)
	}

	e, ok := t.CertToName[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in CertToName", oldK)
	}
	e.Id = &newK

	t.CertToName[newK] = e
	delete(t.CertToName, oldK)
	return nil
}

// GetOrCreateCertToNameMap returns the list (map) from IETFSnmp_Snmp_Tlstm.
//
// It initializes the field if not already initialized.
func (t *IETFSnmp_Snmp_Tlstm) GetOrCreateCertToNameMap() map[uint32]*IETFSnmp_Snmp_Tlstm_CertToName {
	if t.CertToName == nil {
		t.CertToName = make(map[uint32]*IETFSnmp_Snmp_Tlstm_CertToName)
	}
	return t.CertToName
}

// GetOrCreateCertToName retrieves the value with the specified keys from
// the receiver IETFSnmp_Snmp_Tlstm. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *IETFSnmp_Snmp_Tlstm) GetOrCreateCertToName(Id uint32) (*IETFSnmp_Snmp_Tlstm_CertToName){

	key := Id

	if v, ok := t.CertToName[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewCertToName(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateCertToName got unexpected error: %v", err))
	}
	return v
}

// GetCertToName retrieves the value with the specified key from
// the CertToName map field of IETFSnmp_Snmp_Tlstm. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *IETFSnmp_Snmp_Tlstm) GetCertToName(Id uint32) (*IETFSnmp_Snmp_Tlstm_CertToName){

	if t == nil {
		return nil
	}

  key := Id

  if lm, ok := t.CertToName[key]; ok {
    return lm
  }
  return nil
}

// AppendCertToName appends the supplied IETFSnmp_Snmp_Tlstm_CertToName struct to the
// list CertToName of IETFSnmp_Snmp_Tlstm. If the key value(s) specified in
// the supplied IETFSnmp_Snmp_Tlstm_CertToName already exist in the list, an error is
// returned.
func (t *IETFSnmp_Snmp_Tlstm) AppendCertToName(v *IETFSnmp_Snmp_Tlstm_CertToName) error {
	if v.Id == nil {
		return fmt.Errorf("invalid nil key received for Id")
	}

	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.CertToName == nil {
		t.CertToName = make(map[uint32]*IETFSnmp_Snmp_Tlstm_CertToName)
	}

	if _, ok := t.CertToName[key]; ok {
		return fmt.Errorf("duplicate key for list CertToName %v", key)
	}

	t.CertToName[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Tlstm) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_Tlstm"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Tlstm) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_Tlstm) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_Tlstm.
func (*IETFSnmp_Snmp_Tlstm) ΛBelongingModule() string {
	return "ietf-snmp"
}


// IETFSnmp_Snmp_Tlstm_CertToName represents the /ietf-snmp/snmp/tlstm/cert-to-name YANG schema element.
type IETFSnmp_Snmp_Tlstm_CertToName struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Fingerprint	*string	`path:"fingerprint" module:"ietf-snmp"`
	ΛFingerprint	[]ygot.Annotation	`path:"@fingerprint" ygotAnnotation:"true"`
	Id	*uint32	`path:"id" module:"ietf-snmp"`
	ΛId	[]ygot.Annotation	`path:"@id" ygotAnnotation:"true"`
	MapType	E_IETFX509CertToName_CertToName	`path:"map-type" module:"ietf-snmp"`
	ΛMapType	[]ygot.Annotation	`path:"@map-type" ygotAnnotation:"true"`
	Name	*string	`path:"name" module:"ietf-snmp"`
	ΛName	[]ygot.Annotation	`path:"@name" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_Tlstm_CertToName implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_Tlstm_CertToName) IsYANGGoStruct() {}

// GetFingerprint retrieves the value of the leaf Fingerprint from the IETFSnmp_Snmp_Tlstm_CertToName
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Fingerprint is set, it can
// safely use t.GetFingerprint() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Fingerprint == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Tlstm_CertToName) GetFingerprint() string {
	if t == nil || t.Fingerprint == nil {
		return ""
	}
	return *t.Fingerprint
}

// GetId retrieves the value of the leaf Id from the IETFSnmp_Snmp_Tlstm_CertToName
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Tlstm_CertToName) GetId() uint32 {
	if t == nil || t.Id == nil {
		return 0
	}
	return *t.Id
}

// GetMapType retrieves the value of the leaf MapType from the IETFSnmp_Snmp_Tlstm_CertToName
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MapType is set, it can
// safely use t.GetMapType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MapType == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Tlstm_CertToName) GetMapType() E_IETFX509CertToName_CertToName {
	if t == nil || t.MapType ==  0 {
		return 0
	}
	return t.MapType
}

// GetName retrieves the value of the leaf Name from the IETFSnmp_Snmp_Tlstm_CertToName
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Tlstm_CertToName) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// ΛListKeyMap returns the keys of the IETFSnmp_Snmp_Tlstm_CertToName struct, which is a YANG list entry.
func (t *IETFSnmp_Snmp_Tlstm_CertToName) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Tlstm_CertToName) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_Tlstm_CertToName"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Tlstm_CertToName) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_Tlstm_CertToName) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_Tlstm_CertToName.
func (*IETFSnmp_Snmp_Tlstm_CertToName) ΛBelongingModule() string {
	return "ietf-snmp"
}


// IETFSnmp_Snmp_Tsm represents the /ietf-snmp/snmp/tsm YANG schema element.
type IETFSnmp_Snmp_Tsm struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	UsePrefix	*bool	`path:"use-prefix" module:"ietf-snmp"`
	ΛUsePrefix	[]ygot.Annotation	`path:"@use-prefix" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_Tsm implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_Tsm) IsYANGGoStruct() {}

// GetUsePrefix retrieves the value of the leaf UsePrefix from the IETFSnmp_Snmp_Tsm
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UsePrefix is set, it can
// safely use t.GetUsePrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UsePrefix == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Tsm) GetUsePrefix() bool {
	if t == nil || t.UsePrefix == nil {
		return false
	}
	return *t.UsePrefix
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Tsm) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_Tsm"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Tsm) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_Tsm) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_Tsm.
func (*IETFSnmp_Snmp_Tsm) ΛBelongingModule() string {
	return "ietf-snmp"
}


// IETFSnmp_Snmp_Usm represents the /ietf-snmp/snmp/usm YANG schema element.
type IETFSnmp_Snmp_Usm struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Local	*IETFSnmp_Snmp_Usm_Local	`path:"local" module:"ietf-snmp"`
	ΛLocal	[]ygot.Annotation	`path:"@local" ygotAnnotation:"true"`
	Remote	map[string]*IETFSnmp_Snmp_Usm_Remote	`path:"remote" module:"ietf-snmp"`
	ΛRemote	[]ygot.Annotation	`path:"@remote" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_Usm implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_Usm) IsYANGGoStruct() {}

// NewRemote creates a new entry in the Remote list of the
// IETFSnmp_Snmp_Usm struct. The keys of the list are populated from the input
// arguments.
func (t *IETFSnmp_Snmp_Usm) NewRemote(EngineId string) (*IETFSnmp_Snmp_Usm_Remote, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Remote == nil {
		t.Remote = make(map[string]*IETFSnmp_Snmp_Usm_Remote)
	}

	key := EngineId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Remote[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Remote", key)
	}

	t.Remote[key] = &IETFSnmp_Snmp_Usm_Remote{
		EngineId: &EngineId,
	}

	return t.Remote[key], nil
}

// RenameRemote renames an entry in the list Remote within
// the IETFSnmp_Snmp_Usm struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *IETFSnmp_Snmp_Usm) RenameRemote(oldK, newK string) error {
	if _, ok := t.Remote[newK]; ok {
		return fmt.Errorf("key %v already exists in Remote", newK)
	}

	e, ok := t.Remote[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Remote", oldK)
	}
	e.EngineId = &newK

	t.Remote[newK] = e
	delete(t.Remote, oldK)
	return nil
}

// GetOrCreateRemoteMap returns the list (map) from IETFSnmp_Snmp_Usm.
//
// It initializes the field if not already initialized.
func (t *IETFSnmp_Snmp_Usm) GetOrCreateRemoteMap() map[string]*IETFSnmp_Snmp_Usm_Remote {
	if t.Remote == nil {
		t.Remote = make(map[string]*IETFSnmp_Snmp_Usm_Remote)
	}
	return t.Remote
}

// GetOrCreateRemote retrieves the value with the specified keys from
// the receiver IETFSnmp_Snmp_Usm. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *IETFSnmp_Snmp_Usm) GetOrCreateRemote(EngineId string) (*IETFSnmp_Snmp_Usm_Remote){

	key := EngineId

	if v, ok := t.Remote[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewRemote(EngineId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateRemote got unexpected error: %v", err))
	}
	return v
}

// GetRemote retrieves the value with the specified key from
// the Remote map field of IETFSnmp_Snmp_Usm. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *IETFSnmp_Snmp_Usm) GetRemote(EngineId string) (*IETFSnmp_Snmp_Usm_Remote){

	if t == nil {
		return nil
	}

  key := EngineId

  if lm, ok := t.Remote[key]; ok {
    return lm
  }
  return nil
}

// AppendRemote appends the supplied IETFSnmp_Snmp_Usm_Remote struct to the
// list Remote of IETFSnmp_Snmp_Usm. If the key value(s) specified in
// the supplied IETFSnmp_Snmp_Usm_Remote already exist in the list, an error is
// returned.
func (t *IETFSnmp_Snmp_Usm) AppendRemote(v *IETFSnmp_Snmp_Usm_Remote) error {
	if v.EngineId == nil {
		return fmt.Errorf("invalid nil key received for EngineId")
	}

	key := *v.EngineId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Remote == nil {
		t.Remote = make(map[string]*IETFSnmp_Snmp_Usm_Remote)
	}

	if _, ok := t.Remote[key]; ok {
		return fmt.Errorf("duplicate key for list Remote %v", key)
	}

	t.Remote[key] = v
	return nil
}

// GetOrCreateLocal retrieves the value of the Local field
// or returns the existing field if it already exists.
func (t *IETFSnmp_Snmp_Usm) GetOrCreateLocal() *IETFSnmp_Snmp_Usm_Local {
	if t.Local != nil {
		return t.Local
	}
	t.Local = &IETFSnmp_Snmp_Usm_Local{}
	return t.Local
}

// GetLocal returns the value of the Local struct pointer
// from IETFSnmp_Snmp_Usm. If the receiver or the field Local is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IETFSnmp_Snmp_Usm) GetLocal() *IETFSnmp_Snmp_Usm_Local {
	if t != nil && t.Local != nil {
		return t.Local
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Usm) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_Usm"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Usm) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_Usm) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_Usm.
func (*IETFSnmp_Snmp_Usm) ΛBelongingModule() string {
	return "ietf-snmp"
}


// IETFSnmp_Snmp_Usm_Local represents the /ietf-snmp/snmp/usm/local YANG schema element.
type IETFSnmp_Snmp_Usm_Local struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	User	map[string]*IETFSnmp_Snmp_Usm_Local_User	`path:"user" module:"ietf-snmp"`
	ΛUser	[]ygot.Annotation	`path:"@user" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_Usm_Local implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_Usm_Local) IsYANGGoStruct() {}

// NewUser creates a new entry in the User list of the
// IETFSnmp_Snmp_Usm_Local struct. The keys of the list are populated from the input
// arguments.
func (t *IETFSnmp_Snmp_Usm_Local) NewUser(Name string) (*IETFSnmp_Snmp_Usm_Local_User, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.User == nil {
		t.User = make(map[string]*IETFSnmp_Snmp_Usm_Local_User)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.User[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list User", key)
	}

	t.User[key] = &IETFSnmp_Snmp_Usm_Local_User{
		Name: &Name,
	}

	return t.User[key], nil
}

// RenameUser renames an entry in the list User within
// the IETFSnmp_Snmp_Usm_Local struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *IETFSnmp_Snmp_Usm_Local) RenameUser(oldK, newK string) error {
	if _, ok := t.User[newK]; ok {
		return fmt.Errorf("key %v already exists in User", newK)
	}

	e, ok := t.User[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in User", oldK)
	}
	e.Name = &newK

	t.User[newK] = e
	delete(t.User, oldK)
	return nil
}

// GetOrCreateUserMap returns the list (map) from IETFSnmp_Snmp_Usm_Local.
//
// It initializes the field if not already initialized.
func (t *IETFSnmp_Snmp_Usm_Local) GetOrCreateUserMap() map[string]*IETFSnmp_Snmp_Usm_Local_User {
	if t.User == nil {
		t.User = make(map[string]*IETFSnmp_Snmp_Usm_Local_User)
	}
	return t.User
}

// GetOrCreateUser retrieves the value with the specified keys from
// the receiver IETFSnmp_Snmp_Usm_Local. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *IETFSnmp_Snmp_Usm_Local) GetOrCreateUser(Name string) (*IETFSnmp_Snmp_Usm_Local_User){

	key := Name

	if v, ok := t.User[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewUser(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateUser got unexpected error: %v", err))
	}
	return v
}

// GetUser retrieves the value with the specified key from
// the User map field of IETFSnmp_Snmp_Usm_Local. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *IETFSnmp_Snmp_Usm_Local) GetUser(Name string) (*IETFSnmp_Snmp_Usm_Local_User){

	if t == nil {
		return nil
	}

  key := Name

  if lm, ok := t.User[key]; ok {
    return lm
  }
  return nil
}

// AppendUser appends the supplied IETFSnmp_Snmp_Usm_Local_User struct to the
// list User of IETFSnmp_Snmp_Usm_Local. If the key value(s) specified in
// the supplied IETFSnmp_Snmp_Usm_Local_User already exist in the list, an error is
// returned.
func (t *IETFSnmp_Snmp_Usm_Local) AppendUser(v *IETFSnmp_Snmp_Usm_Local_User) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.User == nil {
		t.User = make(map[string]*IETFSnmp_Snmp_Usm_Local_User)
	}

	if _, ok := t.User[key]; ok {
		return fmt.Errorf("duplicate key for list User %v", key)
	}

	t.User[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Usm_Local) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_Usm_Local"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Usm_Local) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_Usm_Local) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_Usm_Local.
func (*IETFSnmp_Snmp_Usm_Local) ΛBelongingModule() string {
	return "ietf-snmp"
}


// IETFSnmp_Snmp_Usm_Local_User represents the /ietf-snmp/snmp/usm/local/user YANG schema element.
type IETFSnmp_Snmp_Usm_Local_User struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Auth	*IETFSnmp_Snmp_Usm_Local_User_Auth	`path:"auth" module:"ietf-snmp"`
	ΛAuth	[]ygot.Annotation	`path:"@auth" ygotAnnotation:"true"`
	Name	*string	`path:"name" module:"ietf-snmp"`
	ΛName	[]ygot.Annotation	`path:"@name" ygotAnnotation:"true"`
	Priv	*IETFSnmp_Snmp_Usm_Local_User_Priv	`path:"priv" module:"ietf-snmp"`
	ΛPriv	[]ygot.Annotation	`path:"@priv" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_Usm_Local_User implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_Usm_Local_User) IsYANGGoStruct() {}

// GetOrCreateAuth retrieves the value of the Auth field
// or returns the existing field if it already exists.
func (t *IETFSnmp_Snmp_Usm_Local_User) GetOrCreateAuth() *IETFSnmp_Snmp_Usm_Local_User_Auth {
	if t.Auth != nil {
		return t.Auth
	}
	t.Auth = &IETFSnmp_Snmp_Usm_Local_User_Auth{}
	return t.Auth
}

// GetOrCreatePriv retrieves the value of the Priv field
// or returns the existing field if it already exists.
func (t *IETFSnmp_Snmp_Usm_Local_User) GetOrCreatePriv() *IETFSnmp_Snmp_Usm_Local_User_Priv {
	if t.Priv != nil {
		return t.Priv
	}
	t.Priv = &IETFSnmp_Snmp_Usm_Local_User_Priv{}
	return t.Priv
}

// GetAuth returns the value of the Auth struct pointer
// from IETFSnmp_Snmp_Usm_Local_User. If the receiver or the field Auth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IETFSnmp_Snmp_Usm_Local_User) GetAuth() *IETFSnmp_Snmp_Usm_Local_User_Auth {
	if t != nil && t.Auth != nil {
		return t.Auth
	}
	return nil
}

// GetPriv returns the value of the Priv struct pointer
// from IETFSnmp_Snmp_Usm_Local_User. If the receiver or the field Priv is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IETFSnmp_Snmp_Usm_Local_User) GetPriv() *IETFSnmp_Snmp_Usm_Local_User_Priv {
	if t != nil && t.Priv != nil {
		return t.Priv
	}
	return nil
}

// GetName retrieves the value of the leaf Name from the IETFSnmp_Snmp_Usm_Local_User
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Usm_Local_User) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// ΛListKeyMap returns the keys of the IETFSnmp_Snmp_Usm_Local_User struct, which is a YANG list entry.
func (t *IETFSnmp_Snmp_Usm_Local_User) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Usm_Local_User) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_Usm_Local_User"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Usm_Local_User) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_Usm_Local_User) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_Usm_Local_User.
func (*IETFSnmp_Snmp_Usm_Local_User) ΛBelongingModule() string {
	return "ietf-snmp"
}


// IETFSnmp_Snmp_Usm_Local_User_Auth represents the /ietf-snmp/snmp/usm/local/user/auth YANG schema element.
type IETFSnmp_Snmp_Usm_Local_User_Auth struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Md5	*IETFSnmp_Snmp_Usm_Local_User_Auth_Md5	`path:"md5" module:"ietf-snmp"`
	ΛMd5	[]ygot.Annotation	`path:"@md5" ygotAnnotation:"true"`
	Sha	*IETFSnmp_Snmp_Usm_Local_User_Auth_Sha	`path:"sha" module:"ietf-snmp"`
	ΛSha	[]ygot.Annotation	`path:"@sha" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_Usm_Local_User_Auth implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_Usm_Local_User_Auth) IsYANGGoStruct() {}

// GetOrCreateMd5 retrieves the value of the Md5 field
// or returns the existing field if it already exists.
func (t *IETFSnmp_Snmp_Usm_Local_User_Auth) GetOrCreateMd5() *IETFSnmp_Snmp_Usm_Local_User_Auth_Md5 {
	if t.Md5 != nil {
		return t.Md5
	}
	t.Md5 = &IETFSnmp_Snmp_Usm_Local_User_Auth_Md5{}
	return t.Md5
}

// GetOrCreateSha retrieves the value of the Sha field
// or returns the existing field if it already exists.
func (t *IETFSnmp_Snmp_Usm_Local_User_Auth) GetOrCreateSha() *IETFSnmp_Snmp_Usm_Local_User_Auth_Sha {
	if t.Sha != nil {
		return t.Sha
	}
	t.Sha = &IETFSnmp_Snmp_Usm_Local_User_Auth_Sha{}
	return t.Sha
}

// GetMd5 returns the value of the Md5 struct pointer
// from IETFSnmp_Snmp_Usm_Local_User_Auth. If the receiver or the field Md5 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IETFSnmp_Snmp_Usm_Local_User_Auth) GetMd5() *IETFSnmp_Snmp_Usm_Local_User_Auth_Md5 {
	if t != nil && t.Md5 != nil {
		return t.Md5
	}
	return nil
}

// GetSha returns the value of the Sha struct pointer
// from IETFSnmp_Snmp_Usm_Local_User_Auth. If the receiver or the field Sha is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IETFSnmp_Snmp_Usm_Local_User_Auth) GetSha() *IETFSnmp_Snmp_Usm_Local_User_Auth_Sha {
	if t != nil && t.Sha != nil {
		return t.Sha
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Usm_Local_User_Auth) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_Usm_Local_User_Auth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Usm_Local_User_Auth) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_Usm_Local_User_Auth) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_Usm_Local_User_Auth.
func (*IETFSnmp_Snmp_Usm_Local_User_Auth) ΛBelongingModule() string {
	return "ietf-snmp"
}


// IETFSnmp_Snmp_Usm_Local_User_Auth_Md5 represents the /ietf-snmp/snmp/usm/local/user/auth/md5 YANG schema element.
type IETFSnmp_Snmp_Usm_Local_User_Auth_Md5 struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Key	*string	`path:"key" module:"ietf-snmp"`
	ΛKey	[]ygot.Annotation	`path:"@key" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_Usm_Local_User_Auth_Md5 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_Usm_Local_User_Auth_Md5) IsYANGGoStruct() {}

// GetKey retrieves the value of the leaf Key from the IETFSnmp_Snmp_Usm_Local_User_Auth_Md5
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Key is set, it can
// safely use t.GetKey() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Key == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Usm_Local_User_Auth_Md5) GetKey() string {
	if t == nil || t.Key == nil {
		return ""
	}
	return *t.Key
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Usm_Local_User_Auth_Md5) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_Usm_Local_User_Auth_Md5"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Usm_Local_User_Auth_Md5) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_Usm_Local_User_Auth_Md5) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_Usm_Local_User_Auth_Md5.
func (*IETFSnmp_Snmp_Usm_Local_User_Auth_Md5) ΛBelongingModule() string {
	return "ietf-snmp"
}


// IETFSnmp_Snmp_Usm_Local_User_Auth_Sha represents the /ietf-snmp/snmp/usm/local/user/auth/sha YANG schema element.
type IETFSnmp_Snmp_Usm_Local_User_Auth_Sha struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Key	*string	`path:"key" module:"ietf-snmp"`
	ΛKey	[]ygot.Annotation	`path:"@key" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_Usm_Local_User_Auth_Sha implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_Usm_Local_User_Auth_Sha) IsYANGGoStruct() {}

// GetKey retrieves the value of the leaf Key from the IETFSnmp_Snmp_Usm_Local_User_Auth_Sha
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Key is set, it can
// safely use t.GetKey() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Key == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Usm_Local_User_Auth_Sha) GetKey() string {
	if t == nil || t.Key == nil {
		return ""
	}
	return *t.Key
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Usm_Local_User_Auth_Sha) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_Usm_Local_User_Auth_Sha"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Usm_Local_User_Auth_Sha) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_Usm_Local_User_Auth_Sha) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_Usm_Local_User_Auth_Sha.
func (*IETFSnmp_Snmp_Usm_Local_User_Auth_Sha) ΛBelongingModule() string {
	return "ietf-snmp"
}


// IETFSnmp_Snmp_Usm_Local_User_Priv represents the /ietf-snmp/snmp/usm/local/user/priv YANG schema element.
type IETFSnmp_Snmp_Usm_Local_User_Priv struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Aes	*IETFSnmp_Snmp_Usm_Local_User_Priv_Aes	`path:"aes" module:"ietf-snmp"`
	ΛAes	[]ygot.Annotation	`path:"@aes" ygotAnnotation:"true"`
	Des	*IETFSnmp_Snmp_Usm_Local_User_Priv_Des	`path:"des" module:"ietf-snmp"`
	ΛDes	[]ygot.Annotation	`path:"@des" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_Usm_Local_User_Priv implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_Usm_Local_User_Priv) IsYANGGoStruct() {}

// GetOrCreateAes retrieves the value of the Aes field
// or returns the existing field if it already exists.
func (t *IETFSnmp_Snmp_Usm_Local_User_Priv) GetOrCreateAes() *IETFSnmp_Snmp_Usm_Local_User_Priv_Aes {
	if t.Aes != nil {
		return t.Aes
	}
	t.Aes = &IETFSnmp_Snmp_Usm_Local_User_Priv_Aes{}
	return t.Aes
}

// GetOrCreateDes retrieves the value of the Des field
// or returns the existing field if it already exists.
func (t *IETFSnmp_Snmp_Usm_Local_User_Priv) GetOrCreateDes() *IETFSnmp_Snmp_Usm_Local_User_Priv_Des {
	if t.Des != nil {
		return t.Des
	}
	t.Des = &IETFSnmp_Snmp_Usm_Local_User_Priv_Des{}
	return t.Des
}

// GetAes returns the value of the Aes struct pointer
// from IETFSnmp_Snmp_Usm_Local_User_Priv. If the receiver or the field Aes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IETFSnmp_Snmp_Usm_Local_User_Priv) GetAes() *IETFSnmp_Snmp_Usm_Local_User_Priv_Aes {
	if t != nil && t.Aes != nil {
		return t.Aes
	}
	return nil
}

// GetDes returns the value of the Des struct pointer
// from IETFSnmp_Snmp_Usm_Local_User_Priv. If the receiver or the field Des is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IETFSnmp_Snmp_Usm_Local_User_Priv) GetDes() *IETFSnmp_Snmp_Usm_Local_User_Priv_Des {
	if t != nil && t.Des != nil {
		return t.Des
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Usm_Local_User_Priv) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_Usm_Local_User_Priv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Usm_Local_User_Priv) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_Usm_Local_User_Priv) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_Usm_Local_User_Priv.
func (*IETFSnmp_Snmp_Usm_Local_User_Priv) ΛBelongingModule() string {
	return "ietf-snmp"
}


// IETFSnmp_Snmp_Usm_Local_User_Priv_Aes represents the /ietf-snmp/snmp/usm/local/user/priv/aes YANG schema element.
type IETFSnmp_Snmp_Usm_Local_User_Priv_Aes struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Key	*string	`path:"key" module:"ietf-snmp"`
	ΛKey	[]ygot.Annotation	`path:"@key" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_Usm_Local_User_Priv_Aes implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_Usm_Local_User_Priv_Aes) IsYANGGoStruct() {}

// GetKey retrieves the value of the leaf Key from the IETFSnmp_Snmp_Usm_Local_User_Priv_Aes
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Key is set, it can
// safely use t.GetKey() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Key == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Usm_Local_User_Priv_Aes) GetKey() string {
	if t == nil || t.Key == nil {
		return ""
	}
	return *t.Key
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Usm_Local_User_Priv_Aes) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_Usm_Local_User_Priv_Aes"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Usm_Local_User_Priv_Aes) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_Usm_Local_User_Priv_Aes) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_Usm_Local_User_Priv_Aes.
func (*IETFSnmp_Snmp_Usm_Local_User_Priv_Aes) ΛBelongingModule() string {
	return "ietf-snmp"
}


// IETFSnmp_Snmp_Usm_Local_User_Priv_Des represents the /ietf-snmp/snmp/usm/local/user/priv/des YANG schema element.
type IETFSnmp_Snmp_Usm_Local_User_Priv_Des struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Key	*string	`path:"key" module:"ietf-snmp"`
	ΛKey	[]ygot.Annotation	`path:"@key" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_Usm_Local_User_Priv_Des implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_Usm_Local_User_Priv_Des) IsYANGGoStruct() {}

// GetKey retrieves the value of the leaf Key from the IETFSnmp_Snmp_Usm_Local_User_Priv_Des
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Key is set, it can
// safely use t.GetKey() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Key == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Usm_Local_User_Priv_Des) GetKey() string {
	if t == nil || t.Key == nil {
		return ""
	}
	return *t.Key
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Usm_Local_User_Priv_Des) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_Usm_Local_User_Priv_Des"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Usm_Local_User_Priv_Des) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_Usm_Local_User_Priv_Des) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_Usm_Local_User_Priv_Des.
func (*IETFSnmp_Snmp_Usm_Local_User_Priv_Des) ΛBelongingModule() string {
	return "ietf-snmp"
}


// IETFSnmp_Snmp_Usm_Remote represents the /ietf-snmp/snmp/usm/remote YANG schema element.
type IETFSnmp_Snmp_Usm_Remote struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	EngineId	*string	`path:"engine-id" module:"ietf-snmp"`
	ΛEngineId	[]ygot.Annotation	`path:"@engine-id" ygotAnnotation:"true"`
	User	map[string]*IETFSnmp_Snmp_Usm_Remote_User	`path:"user" module:"ietf-snmp"`
	ΛUser	[]ygot.Annotation	`path:"@user" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_Usm_Remote implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_Usm_Remote) IsYANGGoStruct() {}

// NewUser creates a new entry in the User list of the
// IETFSnmp_Snmp_Usm_Remote struct. The keys of the list are populated from the input
// arguments.
func (t *IETFSnmp_Snmp_Usm_Remote) NewUser(Name string) (*IETFSnmp_Snmp_Usm_Remote_User, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.User == nil {
		t.User = make(map[string]*IETFSnmp_Snmp_Usm_Remote_User)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.User[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list User", key)
	}

	t.User[key] = &IETFSnmp_Snmp_Usm_Remote_User{
		Name: &Name,
	}

	return t.User[key], nil
}

// RenameUser renames an entry in the list User within
// the IETFSnmp_Snmp_Usm_Remote struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *IETFSnmp_Snmp_Usm_Remote) RenameUser(oldK, newK string) error {
	if _, ok := t.User[newK]; ok {
		return fmt.Errorf("key %v already exists in User", newK)
	}

	e, ok := t.User[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in User", oldK)
	}
	e.Name = &newK

	t.User[newK] = e
	delete(t.User, oldK)
	return nil
}

// GetOrCreateUserMap returns the list (map) from IETFSnmp_Snmp_Usm_Remote.
//
// It initializes the field if not already initialized.
func (t *IETFSnmp_Snmp_Usm_Remote) GetOrCreateUserMap() map[string]*IETFSnmp_Snmp_Usm_Remote_User {
	if t.User == nil {
		t.User = make(map[string]*IETFSnmp_Snmp_Usm_Remote_User)
	}
	return t.User
}

// GetOrCreateUser retrieves the value with the specified keys from
// the receiver IETFSnmp_Snmp_Usm_Remote. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *IETFSnmp_Snmp_Usm_Remote) GetOrCreateUser(Name string) (*IETFSnmp_Snmp_Usm_Remote_User){

	key := Name

	if v, ok := t.User[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewUser(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateUser got unexpected error: %v", err))
	}
	return v
}

// GetUser retrieves the value with the specified key from
// the User map field of IETFSnmp_Snmp_Usm_Remote. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *IETFSnmp_Snmp_Usm_Remote) GetUser(Name string) (*IETFSnmp_Snmp_Usm_Remote_User){

	if t == nil {
		return nil
	}

  key := Name

  if lm, ok := t.User[key]; ok {
    return lm
  }
  return nil
}

// AppendUser appends the supplied IETFSnmp_Snmp_Usm_Remote_User struct to the
// list User of IETFSnmp_Snmp_Usm_Remote. If the key value(s) specified in
// the supplied IETFSnmp_Snmp_Usm_Remote_User already exist in the list, an error is
// returned.
func (t *IETFSnmp_Snmp_Usm_Remote) AppendUser(v *IETFSnmp_Snmp_Usm_Remote_User) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.User == nil {
		t.User = make(map[string]*IETFSnmp_Snmp_Usm_Remote_User)
	}

	if _, ok := t.User[key]; ok {
		return fmt.Errorf("duplicate key for list User %v", key)
	}

	t.User[key] = v
	return nil
}

// GetEngineId retrieves the value of the leaf EngineId from the IETFSnmp_Snmp_Usm_Remote
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EngineId is set, it can
// safely use t.GetEngineId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EngineId == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Usm_Remote) GetEngineId() string {
	if t == nil || t.EngineId == nil {
		return ""
	}
	return *t.EngineId
}

// ΛListKeyMap returns the keys of the IETFSnmp_Snmp_Usm_Remote struct, which is a YANG list entry.
func (t *IETFSnmp_Snmp_Usm_Remote) ΛListKeyMap() (map[string]interface{}, error) {
	if t.EngineId == nil {
		return nil, fmt.Errorf("nil value for key EngineId")
	}

	return map[string]interface{}{
		"engine-id": *t.EngineId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Usm_Remote) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_Usm_Remote"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Usm_Remote) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_Usm_Remote) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_Usm_Remote.
func (*IETFSnmp_Snmp_Usm_Remote) ΛBelongingModule() string {
	return "ietf-snmp"
}


// IETFSnmp_Snmp_Usm_Remote_User represents the /ietf-snmp/snmp/usm/remote/user YANG schema element.
type IETFSnmp_Snmp_Usm_Remote_User struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Auth	*IETFSnmp_Snmp_Usm_Remote_User_Auth	`path:"auth" module:"ietf-snmp"`
	ΛAuth	[]ygot.Annotation	`path:"@auth" ygotAnnotation:"true"`
	Name	*string	`path:"name" module:"ietf-snmp"`
	ΛName	[]ygot.Annotation	`path:"@name" ygotAnnotation:"true"`
	Priv	*IETFSnmp_Snmp_Usm_Remote_User_Priv	`path:"priv" module:"ietf-snmp"`
	ΛPriv	[]ygot.Annotation	`path:"@priv" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_Usm_Remote_User implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_Usm_Remote_User) IsYANGGoStruct() {}

// GetOrCreateAuth retrieves the value of the Auth field
// or returns the existing field if it already exists.
func (t *IETFSnmp_Snmp_Usm_Remote_User) GetOrCreateAuth() *IETFSnmp_Snmp_Usm_Remote_User_Auth {
	if t.Auth != nil {
		return t.Auth
	}
	t.Auth = &IETFSnmp_Snmp_Usm_Remote_User_Auth{}
	return t.Auth
}

// GetOrCreatePriv retrieves the value of the Priv field
// or returns the existing field if it already exists.
func (t *IETFSnmp_Snmp_Usm_Remote_User) GetOrCreatePriv() *IETFSnmp_Snmp_Usm_Remote_User_Priv {
	if t.Priv != nil {
		return t.Priv
	}
	t.Priv = &IETFSnmp_Snmp_Usm_Remote_User_Priv{}
	return t.Priv
}

// GetAuth returns the value of the Auth struct pointer
// from IETFSnmp_Snmp_Usm_Remote_User. If the receiver or the field Auth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IETFSnmp_Snmp_Usm_Remote_User) GetAuth() *IETFSnmp_Snmp_Usm_Remote_User_Auth {
	if t != nil && t.Auth != nil {
		return t.Auth
	}
	return nil
}

// GetPriv returns the value of the Priv struct pointer
// from IETFSnmp_Snmp_Usm_Remote_User. If the receiver or the field Priv is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IETFSnmp_Snmp_Usm_Remote_User) GetPriv() *IETFSnmp_Snmp_Usm_Remote_User_Priv {
	if t != nil && t.Priv != nil {
		return t.Priv
	}
	return nil
}

// GetName retrieves the value of the leaf Name from the IETFSnmp_Snmp_Usm_Remote_User
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Usm_Remote_User) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// ΛListKeyMap returns the keys of the IETFSnmp_Snmp_Usm_Remote_User struct, which is a YANG list entry.
func (t *IETFSnmp_Snmp_Usm_Remote_User) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Usm_Remote_User) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_Usm_Remote_User"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Usm_Remote_User) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_Usm_Remote_User) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_Usm_Remote_User.
func (*IETFSnmp_Snmp_Usm_Remote_User) ΛBelongingModule() string {
	return "ietf-snmp"
}


// IETFSnmp_Snmp_Usm_Remote_User_Auth represents the /ietf-snmp/snmp/usm/remote/user/auth YANG schema element.
type IETFSnmp_Snmp_Usm_Remote_User_Auth struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Md5	*IETFSnmp_Snmp_Usm_Remote_User_Auth_Md5	`path:"md5" module:"ietf-snmp"`
	ΛMd5	[]ygot.Annotation	`path:"@md5" ygotAnnotation:"true"`
	Sha	*IETFSnmp_Snmp_Usm_Remote_User_Auth_Sha	`path:"sha" module:"ietf-snmp"`
	ΛSha	[]ygot.Annotation	`path:"@sha" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_Usm_Remote_User_Auth implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_Usm_Remote_User_Auth) IsYANGGoStruct() {}

// GetOrCreateMd5 retrieves the value of the Md5 field
// or returns the existing field if it already exists.
func (t *IETFSnmp_Snmp_Usm_Remote_User_Auth) GetOrCreateMd5() *IETFSnmp_Snmp_Usm_Remote_User_Auth_Md5 {
	if t.Md5 != nil {
		return t.Md5
	}
	t.Md5 = &IETFSnmp_Snmp_Usm_Remote_User_Auth_Md5{}
	return t.Md5
}

// GetOrCreateSha retrieves the value of the Sha field
// or returns the existing field if it already exists.
func (t *IETFSnmp_Snmp_Usm_Remote_User_Auth) GetOrCreateSha() *IETFSnmp_Snmp_Usm_Remote_User_Auth_Sha {
	if t.Sha != nil {
		return t.Sha
	}
	t.Sha = &IETFSnmp_Snmp_Usm_Remote_User_Auth_Sha{}
	return t.Sha
}

// GetMd5 returns the value of the Md5 struct pointer
// from IETFSnmp_Snmp_Usm_Remote_User_Auth. If the receiver or the field Md5 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IETFSnmp_Snmp_Usm_Remote_User_Auth) GetMd5() *IETFSnmp_Snmp_Usm_Remote_User_Auth_Md5 {
	if t != nil && t.Md5 != nil {
		return t.Md5
	}
	return nil
}

// GetSha returns the value of the Sha struct pointer
// from IETFSnmp_Snmp_Usm_Remote_User_Auth. If the receiver or the field Sha is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IETFSnmp_Snmp_Usm_Remote_User_Auth) GetSha() *IETFSnmp_Snmp_Usm_Remote_User_Auth_Sha {
	if t != nil && t.Sha != nil {
		return t.Sha
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Usm_Remote_User_Auth) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_Usm_Remote_User_Auth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Usm_Remote_User_Auth) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_Usm_Remote_User_Auth) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_Usm_Remote_User_Auth.
func (*IETFSnmp_Snmp_Usm_Remote_User_Auth) ΛBelongingModule() string {
	return "ietf-snmp"
}


// IETFSnmp_Snmp_Usm_Remote_User_Auth_Md5 represents the /ietf-snmp/snmp/usm/remote/user/auth/md5 YANG schema element.
type IETFSnmp_Snmp_Usm_Remote_User_Auth_Md5 struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Key	*string	`path:"key" module:"ietf-snmp"`
	ΛKey	[]ygot.Annotation	`path:"@key" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_Usm_Remote_User_Auth_Md5 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_Usm_Remote_User_Auth_Md5) IsYANGGoStruct() {}

// GetKey retrieves the value of the leaf Key from the IETFSnmp_Snmp_Usm_Remote_User_Auth_Md5
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Key is set, it can
// safely use t.GetKey() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Key == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Usm_Remote_User_Auth_Md5) GetKey() string {
	if t == nil || t.Key == nil {
		return ""
	}
	return *t.Key
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Usm_Remote_User_Auth_Md5) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_Usm_Remote_User_Auth_Md5"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Usm_Remote_User_Auth_Md5) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_Usm_Remote_User_Auth_Md5) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_Usm_Remote_User_Auth_Md5.
func (*IETFSnmp_Snmp_Usm_Remote_User_Auth_Md5) ΛBelongingModule() string {
	return "ietf-snmp"
}


// IETFSnmp_Snmp_Usm_Remote_User_Auth_Sha represents the /ietf-snmp/snmp/usm/remote/user/auth/sha YANG schema element.
type IETFSnmp_Snmp_Usm_Remote_User_Auth_Sha struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Key	*string	`path:"key" module:"ietf-snmp"`
	ΛKey	[]ygot.Annotation	`path:"@key" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_Usm_Remote_User_Auth_Sha implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_Usm_Remote_User_Auth_Sha) IsYANGGoStruct() {}

// GetKey retrieves the value of the leaf Key from the IETFSnmp_Snmp_Usm_Remote_User_Auth_Sha
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Key is set, it can
// safely use t.GetKey() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Key == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Usm_Remote_User_Auth_Sha) GetKey() string {
	if t == nil || t.Key == nil {
		return ""
	}
	return *t.Key
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Usm_Remote_User_Auth_Sha) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_Usm_Remote_User_Auth_Sha"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Usm_Remote_User_Auth_Sha) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_Usm_Remote_User_Auth_Sha) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_Usm_Remote_User_Auth_Sha.
func (*IETFSnmp_Snmp_Usm_Remote_User_Auth_Sha) ΛBelongingModule() string {
	return "ietf-snmp"
}


// IETFSnmp_Snmp_Usm_Remote_User_Priv represents the /ietf-snmp/snmp/usm/remote/user/priv YANG schema element.
type IETFSnmp_Snmp_Usm_Remote_User_Priv struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Aes	*IETFSnmp_Snmp_Usm_Remote_User_Priv_Aes	`path:"aes" module:"ietf-snmp"`
	ΛAes	[]ygot.Annotation	`path:"@aes" ygotAnnotation:"true"`
	Des	*IETFSnmp_Snmp_Usm_Remote_User_Priv_Des	`path:"des" module:"ietf-snmp"`
	ΛDes	[]ygot.Annotation	`path:"@des" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_Usm_Remote_User_Priv implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_Usm_Remote_User_Priv) IsYANGGoStruct() {}

// GetOrCreateAes retrieves the value of the Aes field
// or returns the existing field if it already exists.
func (t *IETFSnmp_Snmp_Usm_Remote_User_Priv) GetOrCreateAes() *IETFSnmp_Snmp_Usm_Remote_User_Priv_Aes {
	if t.Aes != nil {
		return t.Aes
	}
	t.Aes = &IETFSnmp_Snmp_Usm_Remote_User_Priv_Aes{}
	return t.Aes
}

// GetOrCreateDes retrieves the value of the Des field
// or returns the existing field if it already exists.
func (t *IETFSnmp_Snmp_Usm_Remote_User_Priv) GetOrCreateDes() *IETFSnmp_Snmp_Usm_Remote_User_Priv_Des {
	if t.Des != nil {
		return t.Des
	}
	t.Des = &IETFSnmp_Snmp_Usm_Remote_User_Priv_Des{}
	return t.Des
}

// GetAes returns the value of the Aes struct pointer
// from IETFSnmp_Snmp_Usm_Remote_User_Priv. If the receiver or the field Aes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IETFSnmp_Snmp_Usm_Remote_User_Priv) GetAes() *IETFSnmp_Snmp_Usm_Remote_User_Priv_Aes {
	if t != nil && t.Aes != nil {
		return t.Aes
	}
	return nil
}

// GetDes returns the value of the Des struct pointer
// from IETFSnmp_Snmp_Usm_Remote_User_Priv. If the receiver or the field Des is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IETFSnmp_Snmp_Usm_Remote_User_Priv) GetDes() *IETFSnmp_Snmp_Usm_Remote_User_Priv_Des {
	if t != nil && t.Des != nil {
		return t.Des
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Usm_Remote_User_Priv) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_Usm_Remote_User_Priv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Usm_Remote_User_Priv) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_Usm_Remote_User_Priv) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_Usm_Remote_User_Priv.
func (*IETFSnmp_Snmp_Usm_Remote_User_Priv) ΛBelongingModule() string {
	return "ietf-snmp"
}


// IETFSnmp_Snmp_Usm_Remote_User_Priv_Aes represents the /ietf-snmp/snmp/usm/remote/user/priv/aes YANG schema element.
type IETFSnmp_Snmp_Usm_Remote_User_Priv_Aes struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Key	*string	`path:"key" module:"ietf-snmp"`
	ΛKey	[]ygot.Annotation	`path:"@key" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_Usm_Remote_User_Priv_Aes implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_Usm_Remote_User_Priv_Aes) IsYANGGoStruct() {}

// GetKey retrieves the value of the leaf Key from the IETFSnmp_Snmp_Usm_Remote_User_Priv_Aes
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Key is set, it can
// safely use t.GetKey() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Key == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Usm_Remote_User_Priv_Aes) GetKey() string {
	if t == nil || t.Key == nil {
		return ""
	}
	return *t.Key
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Usm_Remote_User_Priv_Aes) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_Usm_Remote_User_Priv_Aes"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Usm_Remote_User_Priv_Aes) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_Usm_Remote_User_Priv_Aes) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_Usm_Remote_User_Priv_Aes.
func (*IETFSnmp_Snmp_Usm_Remote_User_Priv_Aes) ΛBelongingModule() string {
	return "ietf-snmp"
}


// IETFSnmp_Snmp_Usm_Remote_User_Priv_Des represents the /ietf-snmp/snmp/usm/remote/user/priv/des YANG schema element.
type IETFSnmp_Snmp_Usm_Remote_User_Priv_Des struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Key	*string	`path:"key" module:"ietf-snmp"`
	ΛKey	[]ygot.Annotation	`path:"@key" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_Usm_Remote_User_Priv_Des implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_Usm_Remote_User_Priv_Des) IsYANGGoStruct() {}

// GetKey retrieves the value of the leaf Key from the IETFSnmp_Snmp_Usm_Remote_User_Priv_Des
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Key is set, it can
// safely use t.GetKey() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Key == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Usm_Remote_User_Priv_Des) GetKey() string {
	if t == nil || t.Key == nil {
		return ""
	}
	return *t.Key
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Usm_Remote_User_Priv_Des) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_Usm_Remote_User_Priv_Des"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Usm_Remote_User_Priv_Des) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_Usm_Remote_User_Priv_Des) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_Usm_Remote_User_Priv_Des.
func (*IETFSnmp_Snmp_Usm_Remote_User_Priv_Des) ΛBelongingModule() string {
	return "ietf-snmp"
}


// IETFSnmp_Snmp_Vacm represents the /ietf-snmp/snmp/vacm YANG schema element.
type IETFSnmp_Snmp_Vacm struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Group	map[string]*IETFSnmp_Snmp_Vacm_Group	`path:"group" module:"ietf-snmp"`
	ΛGroup	[]ygot.Annotation	`path:"@group" ygotAnnotation:"true"`
	View	map[string]*IETFSnmp_Snmp_Vacm_View	`path:"view" module:"ietf-snmp"`
	ΛView	[]ygot.Annotation	`path:"@view" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_Vacm implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_Vacm) IsYANGGoStruct() {}

// NewGroup creates a new entry in the Group list of the
// IETFSnmp_Snmp_Vacm struct. The keys of the list are populated from the input
// arguments.
func (t *IETFSnmp_Snmp_Vacm) NewGroup(Name string) (*IETFSnmp_Snmp_Vacm_Group, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Group == nil {
		t.Group = make(map[string]*IETFSnmp_Snmp_Vacm_Group)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Group[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Group", key)
	}

	t.Group[key] = &IETFSnmp_Snmp_Vacm_Group{
		Name: &Name,
	}

	return t.Group[key], nil
}

// RenameGroup renames an entry in the list Group within
// the IETFSnmp_Snmp_Vacm struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *IETFSnmp_Snmp_Vacm) RenameGroup(oldK, newK string) error {
	if _, ok := t.Group[newK]; ok {
		return fmt.Errorf("key %v already exists in Group", newK)
	}

	e, ok := t.Group[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Group", oldK)
	}
	e.Name = &newK

	t.Group[newK] = e
	delete(t.Group, oldK)
	return nil
}

// GetOrCreateGroupMap returns the list (map) from IETFSnmp_Snmp_Vacm.
//
// It initializes the field if not already initialized.
func (t *IETFSnmp_Snmp_Vacm) GetOrCreateGroupMap() map[string]*IETFSnmp_Snmp_Vacm_Group {
	if t.Group == nil {
		t.Group = make(map[string]*IETFSnmp_Snmp_Vacm_Group)
	}
	return t.Group
}

// GetOrCreateGroup retrieves the value with the specified keys from
// the receiver IETFSnmp_Snmp_Vacm. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *IETFSnmp_Snmp_Vacm) GetOrCreateGroup(Name string) (*IETFSnmp_Snmp_Vacm_Group){

	key := Name

	if v, ok := t.Group[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewGroup(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateGroup got unexpected error: %v", err))
	}
	return v
}

// GetGroup retrieves the value with the specified key from
// the Group map field of IETFSnmp_Snmp_Vacm. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *IETFSnmp_Snmp_Vacm) GetGroup(Name string) (*IETFSnmp_Snmp_Vacm_Group){

	if t == nil {
		return nil
	}

  key := Name

  if lm, ok := t.Group[key]; ok {
    return lm
  }
  return nil
}

// AppendGroup appends the supplied IETFSnmp_Snmp_Vacm_Group struct to the
// list Group of IETFSnmp_Snmp_Vacm. If the key value(s) specified in
// the supplied IETFSnmp_Snmp_Vacm_Group already exist in the list, an error is
// returned.
func (t *IETFSnmp_Snmp_Vacm) AppendGroup(v *IETFSnmp_Snmp_Vacm_Group) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Group == nil {
		t.Group = make(map[string]*IETFSnmp_Snmp_Vacm_Group)
	}

	if _, ok := t.Group[key]; ok {
		return fmt.Errorf("duplicate key for list Group %v", key)
	}

	t.Group[key] = v
	return nil
}

// NewView creates a new entry in the View list of the
// IETFSnmp_Snmp_Vacm struct. The keys of the list are populated from the input
// arguments.
func (t *IETFSnmp_Snmp_Vacm) NewView(Name string) (*IETFSnmp_Snmp_Vacm_View, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.View == nil {
		t.View = make(map[string]*IETFSnmp_Snmp_Vacm_View)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.View[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list View", key)
	}

	t.View[key] = &IETFSnmp_Snmp_Vacm_View{
		Name: &Name,
	}

	return t.View[key], nil
}

// RenameView renames an entry in the list View within
// the IETFSnmp_Snmp_Vacm struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *IETFSnmp_Snmp_Vacm) RenameView(oldK, newK string) error {
	if _, ok := t.View[newK]; ok {
		return fmt.Errorf("key %v already exists in View", newK)
	}

	e, ok := t.View[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in View", oldK)
	}
	e.Name = &newK

	t.View[newK] = e
	delete(t.View, oldK)
	return nil
}

// GetOrCreateViewMap returns the list (map) from IETFSnmp_Snmp_Vacm.
//
// It initializes the field if not already initialized.
func (t *IETFSnmp_Snmp_Vacm) GetOrCreateViewMap() map[string]*IETFSnmp_Snmp_Vacm_View {
	if t.View == nil {
		t.View = make(map[string]*IETFSnmp_Snmp_Vacm_View)
	}
	return t.View
}

// GetOrCreateView retrieves the value with the specified keys from
// the receiver IETFSnmp_Snmp_Vacm. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *IETFSnmp_Snmp_Vacm) GetOrCreateView(Name string) (*IETFSnmp_Snmp_Vacm_View){

	key := Name

	if v, ok := t.View[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewView(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateView got unexpected error: %v", err))
	}
	return v
}

// GetView retrieves the value with the specified key from
// the View map field of IETFSnmp_Snmp_Vacm. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *IETFSnmp_Snmp_Vacm) GetView(Name string) (*IETFSnmp_Snmp_Vacm_View){

	if t == nil {
		return nil
	}

  key := Name

  if lm, ok := t.View[key]; ok {
    return lm
  }
  return nil
}

// AppendView appends the supplied IETFSnmp_Snmp_Vacm_View struct to the
// list View of IETFSnmp_Snmp_Vacm. If the key value(s) specified in
// the supplied IETFSnmp_Snmp_Vacm_View already exist in the list, an error is
// returned.
func (t *IETFSnmp_Snmp_Vacm) AppendView(v *IETFSnmp_Snmp_Vacm_View) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.View == nil {
		t.View = make(map[string]*IETFSnmp_Snmp_Vacm_View)
	}

	if _, ok := t.View[key]; ok {
		return fmt.Errorf("duplicate key for list View %v", key)
	}

	t.View[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Vacm) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_Vacm"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Vacm) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_Vacm) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_Vacm.
func (*IETFSnmp_Snmp_Vacm) ΛBelongingModule() string {
	return "ietf-snmp"
}


// IETFSnmp_Snmp_Vacm_Group represents the /ietf-snmp/snmp/vacm/group YANG schema element.
type IETFSnmp_Snmp_Vacm_Group struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Access	map[IETFSnmp_Snmp_Vacm_Group_Access_Key]*IETFSnmp_Snmp_Vacm_Group_Access	`path:"access" module:"ietf-snmp"`
	ΛAccess	[]ygot.Annotation	`path:"@access" ygotAnnotation:"true"`
	Member	map[string]*IETFSnmp_Snmp_Vacm_Group_Member	`path:"member" module:"ietf-snmp"`
	ΛMember	[]ygot.Annotation	`path:"@member" ygotAnnotation:"true"`
	Name	*string	`path:"name" module:"ietf-snmp"`
	ΛName	[]ygot.Annotation	`path:"@name" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_Vacm_Group implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_Vacm_Group) IsYANGGoStruct() {}

// IETFSnmp_Snmp_Vacm_Group_Access_Key represents the key for list Access of element /ietf-snmp/snmp/vacm/group.
type IETFSnmp_Snmp_Vacm_Group_Access_Key struct {
	Context	string	`path:"context"`
	SecurityModel	IETFSnmp_Snmp_Vacm_Group_Access_SecurityModel_Union	`path:"security-model"`
	SecurityLevel	E_IETFSnmp_SecurityLevel	`path:"security-level"`
}

// IsYANGGoKeyStruct ensures that IETFSnmp_Snmp_Vacm_Group_Access_Key partially implements the
// yang.GoKeyStruct interface. This allows functions that need to
// handle this key struct to identify it as being generated by gogen.
func (IETFSnmp_Snmp_Vacm_Group_Access_Key) IsYANGGoKeyStruct() {}

// ΛListKeyMap returns the values of the IETFSnmp_Snmp_Vacm_Group_Access_Key key struct.
func (t IETFSnmp_Snmp_Vacm_Group_Access_Key) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"context": t.Context,
		"security-model": t.SecurityModel,
		"security-level": t.SecurityLevel,
	}, nil
}

// NewAccess creates a new entry in the Access list of the
// IETFSnmp_Snmp_Vacm_Group struct. The keys of the list are populated from the input
// arguments.
func (t *IETFSnmp_Snmp_Vacm_Group) NewAccess(Context string, SecurityModel IETFSnmp_Snmp_Vacm_Group_Access_SecurityModel_Union, SecurityLevel E_IETFSnmp_SecurityLevel) (*IETFSnmp_Snmp_Vacm_Group_Access, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Access == nil {
		t.Access = make(map[IETFSnmp_Snmp_Vacm_Group_Access_Key]*IETFSnmp_Snmp_Vacm_Group_Access)
	}

	key := IETFSnmp_Snmp_Vacm_Group_Access_Key{
		Context: Context,
		SecurityModel: SecurityModel,
		SecurityLevel: SecurityLevel,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Access[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Access", key)
	}

	t.Access[key] = &IETFSnmp_Snmp_Vacm_Group_Access{
		Context: &Context,
		SecurityModel: SecurityModel,
		SecurityLevel: SecurityLevel,
	}

	return t.Access[key], nil
}

// RenameAccess renames an entry in the list Access within
// the IETFSnmp_Snmp_Vacm_Group struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *IETFSnmp_Snmp_Vacm_Group) RenameAccess(oldK, newK IETFSnmp_Snmp_Vacm_Group_Access_Key) error {
	if _, ok := t.Access[newK]; ok {
		return fmt.Errorf("key %v already exists in Access", newK)
	}

	e, ok := t.Access[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Access", oldK)
	}
	e.Context = &newK.Context
	e.SecurityModel = newK.SecurityModel
	e.SecurityLevel = newK.SecurityLevel

	t.Access[newK] = e
	delete(t.Access, oldK)
	return nil
}

// GetOrCreateAccessMap returns the list (map) from IETFSnmp_Snmp_Vacm_Group.
//
// It initializes the field if not already initialized.
func (t *IETFSnmp_Snmp_Vacm_Group) GetOrCreateAccessMap() map[IETFSnmp_Snmp_Vacm_Group_Access_Key]*IETFSnmp_Snmp_Vacm_Group_Access {
	if t.Access == nil {
		t.Access = make(map[IETFSnmp_Snmp_Vacm_Group_Access_Key]*IETFSnmp_Snmp_Vacm_Group_Access)
	}
	return t.Access
}

// GetOrCreateAccess retrieves the value with the specified keys from
// the receiver IETFSnmp_Snmp_Vacm_Group. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *IETFSnmp_Snmp_Vacm_Group) GetOrCreateAccess(Context string, SecurityModel IETFSnmp_Snmp_Vacm_Group_Access_SecurityModel_Union, SecurityLevel E_IETFSnmp_SecurityLevel) (*IETFSnmp_Snmp_Vacm_Group_Access){

	key := IETFSnmp_Snmp_Vacm_Group_Access_Key{
		Context: Context,
		SecurityModel: SecurityModel,
		SecurityLevel: SecurityLevel,
	}

	if v, ok := t.Access[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAccess(Context, SecurityModel, SecurityLevel)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAccess got unexpected error: %v", err))
	}
	return v
}

// GetAccess retrieves the value with the specified key from
// the Access map field of IETFSnmp_Snmp_Vacm_Group. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *IETFSnmp_Snmp_Vacm_Group) GetAccess(Context string, SecurityModel IETFSnmp_Snmp_Vacm_Group_Access_SecurityModel_Union, SecurityLevel E_IETFSnmp_SecurityLevel) (*IETFSnmp_Snmp_Vacm_Group_Access){

	if t == nil {
		return nil
	}

  key := IETFSnmp_Snmp_Vacm_Group_Access_Key{
		Context: Context,
		SecurityModel: SecurityModel,
		SecurityLevel: SecurityLevel,
	}

  if lm, ok := t.Access[key]; ok {
    return lm
  }
  return nil
}

// AppendAccess appends the supplied IETFSnmp_Snmp_Vacm_Group_Access struct to the
// list Access of IETFSnmp_Snmp_Vacm_Group. If the key value(s) specified in
// the supplied IETFSnmp_Snmp_Vacm_Group_Access already exist in the list, an error is
// returned.
func (t *IETFSnmp_Snmp_Vacm_Group) AppendAccess(v *IETFSnmp_Snmp_Vacm_Group_Access) error {
	if v.Context == nil {
		return fmt.Errorf("invalid nil key for Context")
	}

	key := IETFSnmp_Snmp_Vacm_Group_Access_Key{
		Context: *v.Context,
		SecurityModel: v.SecurityModel,
		SecurityLevel: v.SecurityLevel,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Access == nil {
		t.Access = make(map[IETFSnmp_Snmp_Vacm_Group_Access_Key]*IETFSnmp_Snmp_Vacm_Group_Access)
	}

	if _, ok := t.Access[key]; ok {
		return fmt.Errorf("duplicate key for list Access %v", key)
	}

	t.Access[key] = v
	return nil
}

// NewMember creates a new entry in the Member list of the
// IETFSnmp_Snmp_Vacm_Group struct. The keys of the list are populated from the input
// arguments.
func (t *IETFSnmp_Snmp_Vacm_Group) NewMember(SecurityName string) (*IETFSnmp_Snmp_Vacm_Group_Member, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Member == nil {
		t.Member = make(map[string]*IETFSnmp_Snmp_Vacm_Group_Member)
	}

	key := SecurityName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Member[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Member", key)
	}

	t.Member[key] = &IETFSnmp_Snmp_Vacm_Group_Member{
		SecurityName: &SecurityName,
	}

	return t.Member[key], nil
}

// RenameMember renames an entry in the list Member within
// the IETFSnmp_Snmp_Vacm_Group struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *IETFSnmp_Snmp_Vacm_Group) RenameMember(oldK, newK string) error {
	if _, ok := t.Member[newK]; ok {
		return fmt.Errorf("key %v already exists in Member", newK)
	}

	e, ok := t.Member[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Member", oldK)
	}
	e.SecurityName = &newK

	t.Member[newK] = e
	delete(t.Member, oldK)
	return nil
}

// GetOrCreateMemberMap returns the list (map) from IETFSnmp_Snmp_Vacm_Group.
//
// It initializes the field if not already initialized.
func (t *IETFSnmp_Snmp_Vacm_Group) GetOrCreateMemberMap() map[string]*IETFSnmp_Snmp_Vacm_Group_Member {
	if t.Member == nil {
		t.Member = make(map[string]*IETFSnmp_Snmp_Vacm_Group_Member)
	}
	return t.Member
}

// GetOrCreateMember retrieves the value with the specified keys from
// the receiver IETFSnmp_Snmp_Vacm_Group. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *IETFSnmp_Snmp_Vacm_Group) GetOrCreateMember(SecurityName string) (*IETFSnmp_Snmp_Vacm_Group_Member){

	key := SecurityName

	if v, ok := t.Member[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMember(SecurityName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMember got unexpected error: %v", err))
	}
	return v
}

// GetMember retrieves the value with the specified key from
// the Member map field of IETFSnmp_Snmp_Vacm_Group. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *IETFSnmp_Snmp_Vacm_Group) GetMember(SecurityName string) (*IETFSnmp_Snmp_Vacm_Group_Member){

	if t == nil {
		return nil
	}

  key := SecurityName

  if lm, ok := t.Member[key]; ok {
    return lm
  }
  return nil
}

// AppendMember appends the supplied IETFSnmp_Snmp_Vacm_Group_Member struct to the
// list Member of IETFSnmp_Snmp_Vacm_Group. If the key value(s) specified in
// the supplied IETFSnmp_Snmp_Vacm_Group_Member already exist in the list, an error is
// returned.
func (t *IETFSnmp_Snmp_Vacm_Group) AppendMember(v *IETFSnmp_Snmp_Vacm_Group_Member) error {
	if v.SecurityName == nil {
		return fmt.Errorf("invalid nil key received for SecurityName")
	}

	key := *v.SecurityName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Member == nil {
		t.Member = make(map[string]*IETFSnmp_Snmp_Vacm_Group_Member)
	}

	if _, ok := t.Member[key]; ok {
		return fmt.Errorf("duplicate key for list Member %v", key)
	}

	t.Member[key] = v
	return nil
}

// GetName retrieves the value of the leaf Name from the IETFSnmp_Snmp_Vacm_Group
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Vacm_Group) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// ΛListKeyMap returns the keys of the IETFSnmp_Snmp_Vacm_Group struct, which is a YANG list entry.
func (t *IETFSnmp_Snmp_Vacm_Group) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Vacm_Group) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_Vacm_Group"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Vacm_Group) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_Vacm_Group) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_Vacm_Group.
func (*IETFSnmp_Snmp_Vacm_Group) ΛBelongingModule() string {
	return "ietf-snmp"
}


// IETFSnmp_Snmp_Vacm_Group_Access represents the /ietf-snmp/snmp/vacm/group/access YANG schema element.
type IETFSnmp_Snmp_Vacm_Group_Access struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Context	*string	`path:"context" module:"ietf-snmp"`
	ΛContext	[]ygot.Annotation	`path:"@context" ygotAnnotation:"true"`
	ContextMatch	E_IETFSnmp_Snmp_Vacm_Group_Access_ContextMatch	`path:"context-match" module:"ietf-snmp"`
	ΛContextMatch	[]ygot.Annotation	`path:"@context-match" ygotAnnotation:"true"`
	NotifyView	*string	`path:"notify-view" module:"ietf-snmp"`
	ΛNotifyView	[]ygot.Annotation	`path:"@notify-view" ygotAnnotation:"true"`
	ReadView	*string	`path:"read-view" module:"ietf-snmp"`
	ΛReadView	[]ygot.Annotation	`path:"@read-view" ygotAnnotation:"true"`
	SecurityLevel	E_IETFSnmp_SecurityLevel	`path:"security-level" module:"ietf-snmp"`
	ΛSecurityLevel	[]ygot.Annotation	`path:"@security-level" ygotAnnotation:"true"`
	SecurityModel	IETFSnmp_Snmp_Vacm_Group_Access_SecurityModel_Union	`path:"security-model" module:"ietf-snmp"`
	ΛSecurityModel	[]ygot.Annotation	`path:"@security-model" ygotAnnotation:"true"`
	WriteView	*string	`path:"write-view" module:"ietf-snmp"`
	ΛWriteView	[]ygot.Annotation	`path:"@write-view" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_Vacm_Group_Access implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_Vacm_Group_Access) IsYANGGoStruct() {}

// GetContext retrieves the value of the leaf Context from the IETFSnmp_Snmp_Vacm_Group_Access
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Context is set, it can
// safely use t.GetContext() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Context == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Vacm_Group_Access) GetContext() string {
	if t == nil || t.Context == nil {
		return ""
	}
	return *t.Context
}

// GetContextMatch retrieves the value of the leaf ContextMatch from the IETFSnmp_Snmp_Vacm_Group_Access
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ContextMatch is set, it can
// safely use t.GetContextMatch() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ContextMatch == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Vacm_Group_Access) GetContextMatch() E_IETFSnmp_Snmp_Vacm_Group_Access_ContextMatch {
	if t == nil || t.ContextMatch ==  0 {
		return IETFSnmp_Snmp_Vacm_Group_Access_ContextMatch_exact
	}
	return t.ContextMatch
}

// GetNotifyView retrieves the value of the leaf NotifyView from the IETFSnmp_Snmp_Vacm_Group_Access
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NotifyView is set, it can
// safely use t.GetNotifyView() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NotifyView == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Vacm_Group_Access) GetNotifyView() string {
	if t == nil || t.NotifyView == nil {
		return ""
	}
	return *t.NotifyView
}

// GetReadView retrieves the value of the leaf ReadView from the IETFSnmp_Snmp_Vacm_Group_Access
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ReadView is set, it can
// safely use t.GetReadView() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ReadView == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Vacm_Group_Access) GetReadView() string {
	if t == nil || t.ReadView == nil {
		return ""
	}
	return *t.ReadView
}

// GetSecurityLevel retrieves the value of the leaf SecurityLevel from the IETFSnmp_Snmp_Vacm_Group_Access
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SecurityLevel is set, it can
// safely use t.GetSecurityLevel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SecurityLevel == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Vacm_Group_Access) GetSecurityLevel() E_IETFSnmp_SecurityLevel {
	if t == nil || t.SecurityLevel ==  0 {
		return 0
	}
	return t.SecurityLevel
}

// GetSecurityModel retrieves the value of the leaf SecurityModel from the IETFSnmp_Snmp_Vacm_Group_Access
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SecurityModel is set, it can
// safely use t.GetSecurityModel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SecurityModel == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Vacm_Group_Access) GetSecurityModel() IETFSnmp_Snmp_Vacm_Group_Access_SecurityModel_Union {
	if t == nil || t.SecurityModel ==  nil {
		return nil
	}
	return t.SecurityModel
}

// GetWriteView retrieves the value of the leaf WriteView from the IETFSnmp_Snmp_Vacm_Group_Access
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if WriteView is set, it can
// safely use t.GetWriteView() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.WriteView == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Vacm_Group_Access) GetWriteView() string {
	if t == nil || t.WriteView == nil {
		return ""
	}
	return *t.WriteView
}

// ΛListKeyMap returns the keys of the IETFSnmp_Snmp_Vacm_Group_Access struct, which is a YANG list entry.
func (t *IETFSnmp_Snmp_Vacm_Group_Access) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Context == nil {
		return nil, fmt.Errorf("nil value for key Context")
	}



	return map[string]interface{}{
		"context": *t.Context,
		"security-level": t.SecurityLevel,
		"security-model": t.SecurityModel,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Vacm_Group_Access) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_Vacm_Group_Access"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Vacm_Group_Access) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_Vacm_Group_Access) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_Vacm_Group_Access.
func (*IETFSnmp_Snmp_Vacm_Group_Access) ΛBelongingModule() string {
	return "ietf-snmp"
}

// IETFSnmp_Snmp_Vacm_Group_Access_SecurityModel_Union is an interface that is implemented by valid types for the union
// for the leaf /ietf-snmp/snmp/vacm/group/access/security-model within the YANG schema.
// Union type can be one of [E_IETFSnmp_SecurityModelOrAny_Enum, E_IETFSnmp_SecurityModel_Enum, UnionInt32].
type IETFSnmp_Snmp_Vacm_Group_Access_SecurityModel_Union interface {
	// Union type can be one of [E_IETFSnmp_SecurityModelOrAny_Enum, E_IETFSnmp_SecurityModel_Enum, UnionInt32]
	Documentation_for_IETFSnmp_Snmp_Vacm_Group_Access_SecurityModel_Union()
}

// Documentation_for_IETFSnmp_Snmp_Vacm_Group_Access_SecurityModel_Union ensures that E_IETFSnmp_SecurityModelOrAny_Enum
// implements the IETFSnmp_Snmp_Vacm_Group_Access_SecurityModel_Union interface.
func (E_IETFSnmp_SecurityModelOrAny_Enum) Documentation_for_IETFSnmp_Snmp_Vacm_Group_Access_SecurityModel_Union() {}

// Documentation_for_IETFSnmp_Snmp_Vacm_Group_Access_SecurityModel_Union ensures that E_IETFSnmp_SecurityModel_Enum
// implements the IETFSnmp_Snmp_Vacm_Group_Access_SecurityModel_Union interface.
func (E_IETFSnmp_SecurityModel_Enum) Documentation_for_IETFSnmp_Snmp_Vacm_Group_Access_SecurityModel_Union() {}

// Documentation_for_IETFSnmp_Snmp_Vacm_Group_Access_SecurityModel_Union ensures that UnionInt32
// implements the IETFSnmp_Snmp_Vacm_Group_Access_SecurityModel_Union interface.
func (UnionInt32) Documentation_for_IETFSnmp_Snmp_Vacm_Group_Access_SecurityModel_Union() {}

// To_IETFSnmp_Snmp_Vacm_Group_Access_SecurityModel_Union takes an input interface{} and attempts to convert it to a struct
// which implements the IETFSnmp_Snmp_Vacm_Group_Access_SecurityModel_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *IETFSnmp_Snmp_Vacm_Group_Access) To_IETFSnmp_Snmp_Vacm_Group_Access_SecurityModel_Union(i interface{}) (IETFSnmp_Snmp_Vacm_Group_Access_SecurityModel_Union, error) {
	if v, ok := i.(IETFSnmp_Snmp_Vacm_Group_Access_SecurityModel_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case int32:
		return UnionInt32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to IETFSnmp_Snmp_Vacm_Group_Access_SecurityModel_Union, unknown union type, got: %T, want any of [E_IETFSnmp_SecurityModelOrAny_Enum, E_IETFSnmp_SecurityModel_Enum, int32]", i, i)
}


// IETFSnmp_Snmp_Vacm_Group_Member represents the /ietf-snmp/snmp/vacm/group/member YANG schema element.
type IETFSnmp_Snmp_Vacm_Group_Member struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	SecurityModel	[]IETFSnmp_Snmp_Vacm_Group_Member_SecurityModel_Union	`path:"security-model" module:"ietf-snmp"`
	ΛSecurityModel	[]ygot.Annotation	`path:"@security-model" ygotAnnotation:"true"`
	SecurityName	*string	`path:"security-name" module:"ietf-snmp"`
	ΛSecurityName	[]ygot.Annotation	`path:"@security-name" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_Vacm_Group_Member implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_Vacm_Group_Member) IsYANGGoStruct() {}

// GetSecurityModel retrieves the value of the leaf SecurityModel from the IETFSnmp_Snmp_Vacm_Group_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SecurityModel is set, it can
// safely use t.GetSecurityModel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SecurityModel == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Vacm_Group_Member) GetSecurityModel() []IETFSnmp_Snmp_Vacm_Group_Member_SecurityModel_Union {
	if t == nil || t.SecurityModel ==  nil {
		return nil
	}
	return t.SecurityModel
}

// GetSecurityName retrieves the value of the leaf SecurityName from the IETFSnmp_Snmp_Vacm_Group_Member
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SecurityName is set, it can
// safely use t.GetSecurityName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SecurityName == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Vacm_Group_Member) GetSecurityName() string {
	if t == nil || t.SecurityName == nil {
		return ""
	}
	return *t.SecurityName
}

// ΛListKeyMap returns the keys of the IETFSnmp_Snmp_Vacm_Group_Member struct, which is a YANG list entry.
func (t *IETFSnmp_Snmp_Vacm_Group_Member) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SecurityName == nil {
		return nil, fmt.Errorf("nil value for key SecurityName")
	}

	return map[string]interface{}{
		"security-name": *t.SecurityName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Vacm_Group_Member) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_Vacm_Group_Member"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Vacm_Group_Member) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_Vacm_Group_Member) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_Vacm_Group_Member.
func (*IETFSnmp_Snmp_Vacm_Group_Member) ΛBelongingModule() string {
	return "ietf-snmp"
}

// IETFSnmp_Snmp_Vacm_Group_Member_SecurityModel_Union is an interface that is implemented by valid types for the union
// for the leaf /ietf-snmp/snmp/vacm/group/member/security-model within the YANG schema.
// Union type can be one of [E_IETFSnmp_SecurityModel_Enum, UnionInt32].
type IETFSnmp_Snmp_Vacm_Group_Member_SecurityModel_Union interface {
	// Union type can be one of [E_IETFSnmp_SecurityModel_Enum, UnionInt32]
	Documentation_for_IETFSnmp_Snmp_Vacm_Group_Member_SecurityModel_Union()
}

// Documentation_for_IETFSnmp_Snmp_Vacm_Group_Member_SecurityModel_Union ensures that E_IETFSnmp_SecurityModel_Enum
// implements the IETFSnmp_Snmp_Vacm_Group_Member_SecurityModel_Union interface.
func (E_IETFSnmp_SecurityModel_Enum) Documentation_for_IETFSnmp_Snmp_Vacm_Group_Member_SecurityModel_Union() {}

// Documentation_for_IETFSnmp_Snmp_Vacm_Group_Member_SecurityModel_Union ensures that UnionInt32
// implements the IETFSnmp_Snmp_Vacm_Group_Member_SecurityModel_Union interface.
func (UnionInt32) Documentation_for_IETFSnmp_Snmp_Vacm_Group_Member_SecurityModel_Union() {}

// To_IETFSnmp_Snmp_Vacm_Group_Member_SecurityModel_Union takes an input interface{} and attempts to convert it to a struct
// which implements the IETFSnmp_Snmp_Vacm_Group_Member_SecurityModel_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *IETFSnmp_Snmp_Vacm_Group_Member) To_IETFSnmp_Snmp_Vacm_Group_Member_SecurityModel_Union(i interface{}) (IETFSnmp_Snmp_Vacm_Group_Member_SecurityModel_Union, error) {
	if v, ok := i.(IETFSnmp_Snmp_Vacm_Group_Member_SecurityModel_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case int32:
		return UnionInt32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to IETFSnmp_Snmp_Vacm_Group_Member_SecurityModel_Union, unknown union type, got: %T, want any of [E_IETFSnmp_SecurityModel_Enum, int32]", i, i)
}


// IETFSnmp_Snmp_Vacm_View represents the /ietf-snmp/snmp/vacm/view YANG schema element.
type IETFSnmp_Snmp_Vacm_View struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Exclude	[]string	`path:"exclude" module:"ietf-snmp"`
	ΛExclude	[]ygot.Annotation	`path:"@exclude" ygotAnnotation:"true"`
	Include	[]string	`path:"include" module:"ietf-snmp"`
	ΛInclude	[]ygot.Annotation	`path:"@include" ygotAnnotation:"true"`
	Name	*string	`path:"name" module:"ietf-snmp"`
	ΛName	[]ygot.Annotation	`path:"@name" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSnmp_Snmp_Vacm_View implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSnmp_Snmp_Vacm_View) IsYANGGoStruct() {}

// GetExclude retrieves the value of the leaf Exclude from the IETFSnmp_Snmp_Vacm_View
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Exclude is set, it can
// safely use t.GetExclude() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Exclude == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Vacm_View) GetExclude() []string {
	if t == nil || t.Exclude ==  nil {
		return nil
	}
	return t.Exclude
}

// GetInclude retrieves the value of the leaf Include from the IETFSnmp_Snmp_Vacm_View
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Include is set, it can
// safely use t.GetInclude() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Include == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Vacm_View) GetInclude() []string {
	if t == nil || t.Include ==  nil {
		return nil
	}
	return t.Include
}

// GetName retrieves the value of the leaf Name from the IETFSnmp_Snmp_Vacm_View
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *IETFSnmp_Snmp_Vacm_View) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// ΛListKeyMap returns the keys of the IETFSnmp_Snmp_Vacm_View struct, which is a YANG list entry.
func (t *IETFSnmp_Snmp_Vacm_View) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Vacm_View) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSnmp_Snmp_Vacm_View"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSnmp_Snmp_Vacm_View) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSnmp_Snmp_Vacm_View) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSnmp_Snmp_Vacm_View.
func (*IETFSnmp_Snmp_Vacm_View) ΛBelongingModule() string {
	return "ietf-snmp"
}


// IETFSystem_System represents the /ietf-system/system YANG schema element.
type IETFSystem_System struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Authentication	*IETFSystem_System_Authentication	`path:"authentication" module:"ietf-system"`
	ΛAuthentication	[]ygot.Annotation	`path:"@authentication" ygotAnnotation:"true"`
	Clock	*IETFSystem_System_Clock	`path:"clock" module:"ietf-system"`
	ΛClock	[]ygot.Annotation	`path:"@clock" ygotAnnotation:"true"`
	Contact	*string	`path:"contact" module:"ietf-system"`
	ΛContact	[]ygot.Annotation	`path:"@contact" ygotAnnotation:"true"`
	DnsResolver	*IETFSystem_System_DnsResolver	`path:"dns-resolver" module:"ietf-system"`
	ΛDnsResolver	[]ygot.Annotation	`path:"@dns-resolver" ygotAnnotation:"true"`
	Hostname	*string	`path:"hostname" module:"ietf-system"`
	ΛHostname	[]ygot.Annotation	`path:"@hostname" ygotAnnotation:"true"`
	Location	*string	`path:"location" module:"ietf-system"`
	ΛLocation	[]ygot.Annotation	`path:"@location" ygotAnnotation:"true"`
	Ntp	*IETFSystem_System_Ntp	`path:"ntp" module:"ietf-system"`
	ΛNtp	[]ygot.Annotation	`path:"@ntp" ygotAnnotation:"true"`
	Radius	*IETFSystem_System_Radius	`path:"radius" module:"ietf-system"`
	ΛRadius	[]ygot.Annotation	`path:"@radius" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSystem_System implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSystem_System) IsYANGGoStruct() {}

// GetOrCreateAuthentication retrieves the value of the Authentication field
// or returns the existing field if it already exists.
func (t *IETFSystem_System) GetOrCreateAuthentication() *IETFSystem_System_Authentication {
	if t.Authentication != nil {
		return t.Authentication
	}
	t.Authentication = &IETFSystem_System_Authentication{}
	return t.Authentication
}

// GetOrCreateClock retrieves the value of the Clock field
// or returns the existing field if it already exists.
func (t *IETFSystem_System) GetOrCreateClock() *IETFSystem_System_Clock {
	if t.Clock != nil {
		return t.Clock
	}
	t.Clock = &IETFSystem_System_Clock{}
	return t.Clock
}

// GetOrCreateDnsResolver retrieves the value of the DnsResolver field
// or returns the existing field if it already exists.
func (t *IETFSystem_System) GetOrCreateDnsResolver() *IETFSystem_System_DnsResolver {
	if t.DnsResolver != nil {
		return t.DnsResolver
	}
	t.DnsResolver = &IETFSystem_System_DnsResolver{}
	return t.DnsResolver
}

// GetOrCreateNtp retrieves the value of the Ntp field
// or returns the existing field if it already exists.
func (t *IETFSystem_System) GetOrCreateNtp() *IETFSystem_System_Ntp {
	if t.Ntp != nil {
		return t.Ntp
	}
	t.Ntp = &IETFSystem_System_Ntp{}
	return t.Ntp
}

// GetOrCreateRadius retrieves the value of the Radius field
// or returns the existing field if it already exists.
func (t *IETFSystem_System) GetOrCreateRadius() *IETFSystem_System_Radius {
	if t.Radius != nil {
		return t.Radius
	}
	t.Radius = &IETFSystem_System_Radius{}
	return t.Radius
}

// GetAuthentication returns the value of the Authentication struct pointer
// from IETFSystem_System. If the receiver or the field Authentication is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IETFSystem_System) GetAuthentication() *IETFSystem_System_Authentication {
	if t != nil && t.Authentication != nil {
		return t.Authentication
	}
	return nil
}

// GetClock returns the value of the Clock struct pointer
// from IETFSystem_System. If the receiver or the field Clock is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IETFSystem_System) GetClock() *IETFSystem_System_Clock {
	if t != nil && t.Clock != nil {
		return t.Clock
	}
	return nil
}

// GetDnsResolver returns the value of the DnsResolver struct pointer
// from IETFSystem_System. If the receiver or the field DnsResolver is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IETFSystem_System) GetDnsResolver() *IETFSystem_System_DnsResolver {
	if t != nil && t.DnsResolver != nil {
		return t.DnsResolver
	}
	return nil
}

// GetNtp returns the value of the Ntp struct pointer
// from IETFSystem_System. If the receiver or the field Ntp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IETFSystem_System) GetNtp() *IETFSystem_System_Ntp {
	if t != nil && t.Ntp != nil {
		return t.Ntp
	}
	return nil
}

// GetRadius returns the value of the Radius struct pointer
// from IETFSystem_System. If the receiver or the field Radius is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IETFSystem_System) GetRadius() *IETFSystem_System_Radius {
	if t != nil && t.Radius != nil {
		return t.Radius
	}
	return nil
}

// GetContact retrieves the value of the leaf Contact from the IETFSystem_System
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Contact is set, it can
// safely use t.GetContact() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Contact == nil' before retrieving the leaf's value.
func (t *IETFSystem_System) GetContact() string {
	if t == nil || t.Contact == nil {
		return ""
	}
	return *t.Contact
}

// GetHostname retrieves the value of the leaf Hostname from the IETFSystem_System
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Hostname is set, it can
// safely use t.GetHostname() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Hostname == nil' before retrieving the leaf's value.
func (t *IETFSystem_System) GetHostname() string {
	if t == nil || t.Hostname == nil {
		return ""
	}
	return *t.Hostname
}

// GetLocation retrieves the value of the leaf Location from the IETFSystem_System
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Location is set, it can
// safely use t.GetLocation() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Location == nil' before retrieving the leaf's value.
func (t *IETFSystem_System) GetLocation() string {
	if t == nil || t.Location == nil {
		return ""
	}
	return *t.Location
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSystem_System) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSystem_System"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSystem_System) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSystem_System) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSystem_System.
func (*IETFSystem_System) ΛBelongingModule() string {
	return "ietf-system"
}


// IETFSystem_SystemState represents the /ietf-system/system-state YANG schema element.
type IETFSystem_SystemState struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Clock	*IETFSystem_SystemState_Clock	`path:"clock" module:"ietf-system"`
	ΛClock	[]ygot.Annotation	`path:"@clock" ygotAnnotation:"true"`
	Platform	*IETFSystem_SystemState_Platform	`path:"platform" module:"ietf-system"`
	ΛPlatform	[]ygot.Annotation	`path:"@platform" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSystem_SystemState implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSystem_SystemState) IsYANGGoStruct() {}

// GetOrCreateClock retrieves the value of the Clock field
// or returns the existing field if it already exists.
func (t *IETFSystem_SystemState) GetOrCreateClock() *IETFSystem_SystemState_Clock {
	if t.Clock != nil {
		return t.Clock
	}
	t.Clock = &IETFSystem_SystemState_Clock{}
	return t.Clock
}

// GetOrCreatePlatform retrieves the value of the Platform field
// or returns the existing field if it already exists.
func (t *IETFSystem_SystemState) GetOrCreatePlatform() *IETFSystem_SystemState_Platform {
	if t.Platform != nil {
		return t.Platform
	}
	t.Platform = &IETFSystem_SystemState_Platform{}
	return t.Platform
}

// GetClock returns the value of the Clock struct pointer
// from IETFSystem_SystemState. If the receiver or the field Clock is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IETFSystem_SystemState) GetClock() *IETFSystem_SystemState_Clock {
	if t != nil && t.Clock != nil {
		return t.Clock
	}
	return nil
}

// GetPlatform returns the value of the Platform struct pointer
// from IETFSystem_SystemState. If the receiver or the field Platform is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IETFSystem_SystemState) GetPlatform() *IETFSystem_SystemState_Platform {
	if t != nil && t.Platform != nil {
		return t.Platform
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSystem_SystemState) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSystem_SystemState"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSystem_SystemState) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSystem_SystemState) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSystem_SystemState.
func (*IETFSystem_SystemState) ΛBelongingModule() string {
	return "ietf-system"
}


// IETFSystem_SystemState_Clock represents the /ietf-system/system-state/clock YANG schema element.
type IETFSystem_SystemState_Clock struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	BootDatetime	*string	`path:"boot-datetime" module:"ietf-system"`
	ΛBootDatetime	[]ygot.Annotation	`path:"@boot-datetime" ygotAnnotation:"true"`
	CurrentDatetime	*string	`path:"current-datetime" module:"ietf-system"`
	ΛCurrentDatetime	[]ygot.Annotation	`path:"@current-datetime" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSystem_SystemState_Clock implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSystem_SystemState_Clock) IsYANGGoStruct() {}

// GetBootDatetime retrieves the value of the leaf BootDatetime from the IETFSystem_SystemState_Clock
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BootDatetime is set, it can
// safely use t.GetBootDatetime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BootDatetime == nil' before retrieving the leaf's value.
func (t *IETFSystem_SystemState_Clock) GetBootDatetime() string {
	if t == nil || t.BootDatetime == nil {
		return ""
	}
	return *t.BootDatetime
}

// GetCurrentDatetime retrieves the value of the leaf CurrentDatetime from the IETFSystem_SystemState_Clock
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CurrentDatetime is set, it can
// safely use t.GetCurrentDatetime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CurrentDatetime == nil' before retrieving the leaf's value.
func (t *IETFSystem_SystemState_Clock) GetCurrentDatetime() string {
	if t == nil || t.CurrentDatetime == nil {
		return ""
	}
	return *t.CurrentDatetime
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSystem_SystemState_Clock) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSystem_SystemState_Clock"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSystem_SystemState_Clock) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSystem_SystemState_Clock) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSystem_SystemState_Clock.
func (*IETFSystem_SystemState_Clock) ΛBelongingModule() string {
	return "ietf-system"
}


// IETFSystem_SystemState_Platform represents the /ietf-system/system-state/platform YANG schema element.
type IETFSystem_SystemState_Platform struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Machine	*string	`path:"machine" module:"ietf-system"`
	ΛMachine	[]ygot.Annotation	`path:"@machine" ygotAnnotation:"true"`
	OsName	*string	`path:"os-name" module:"ietf-system"`
	ΛOsName	[]ygot.Annotation	`path:"@os-name" ygotAnnotation:"true"`
	OsRelease	*string	`path:"os-release" module:"ietf-system"`
	ΛOsRelease	[]ygot.Annotation	`path:"@os-release" ygotAnnotation:"true"`
	OsVersion	*string	`path:"os-version" module:"ietf-system"`
	ΛOsVersion	[]ygot.Annotation	`path:"@os-version" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSystem_SystemState_Platform implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSystem_SystemState_Platform) IsYANGGoStruct() {}

// GetMachine retrieves the value of the leaf Machine from the IETFSystem_SystemState_Platform
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Machine is set, it can
// safely use t.GetMachine() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Machine == nil' before retrieving the leaf's value.
func (t *IETFSystem_SystemState_Platform) GetMachine() string {
	if t == nil || t.Machine == nil {
		return ""
	}
	return *t.Machine
}

// GetOsName retrieves the value of the leaf OsName from the IETFSystem_SystemState_Platform
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OsName is set, it can
// safely use t.GetOsName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OsName == nil' before retrieving the leaf's value.
func (t *IETFSystem_SystemState_Platform) GetOsName() string {
	if t == nil || t.OsName == nil {
		return ""
	}
	return *t.OsName
}

// GetOsRelease retrieves the value of the leaf OsRelease from the IETFSystem_SystemState_Platform
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OsRelease is set, it can
// safely use t.GetOsRelease() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OsRelease == nil' before retrieving the leaf's value.
func (t *IETFSystem_SystemState_Platform) GetOsRelease() string {
	if t == nil || t.OsRelease == nil {
		return ""
	}
	return *t.OsRelease
}

// GetOsVersion retrieves the value of the leaf OsVersion from the IETFSystem_SystemState_Platform
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OsVersion is set, it can
// safely use t.GetOsVersion() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OsVersion == nil' before retrieving the leaf's value.
func (t *IETFSystem_SystemState_Platform) GetOsVersion() string {
	if t == nil || t.OsVersion == nil {
		return ""
	}
	return *t.OsVersion
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSystem_SystemState_Platform) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSystem_SystemState_Platform"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSystem_SystemState_Platform) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSystem_SystemState_Platform) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSystem_SystemState_Platform.
func (*IETFSystem_SystemState_Platform) ΛBelongingModule() string {
	return "ietf-system"
}


// IETFSystem_System_Authentication represents the /ietf-system/system/authentication YANG schema element.
type IETFSystem_System_Authentication struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	User	map[string]*IETFSystem_System_Authentication_User	`path:"user" module:"ietf-system"`
	ΛUser	[]ygot.Annotation	`path:"@user" ygotAnnotation:"true"`
	UserAuthenticationOrder	[]E_IETFSystem_AuthenticationMethod	`path:"user-authentication-order" module:"ietf-system"`
	ΛUserAuthenticationOrder	[]ygot.Annotation	`path:"@user-authentication-order" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSystem_System_Authentication implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSystem_System_Authentication) IsYANGGoStruct() {}

// NewUser creates a new entry in the User list of the
// IETFSystem_System_Authentication struct. The keys of the list are populated from the input
// arguments.
func (t *IETFSystem_System_Authentication) NewUser(Name string) (*IETFSystem_System_Authentication_User, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.User == nil {
		t.User = make(map[string]*IETFSystem_System_Authentication_User)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.User[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list User", key)
	}

	t.User[key] = &IETFSystem_System_Authentication_User{
		Name: &Name,
	}

	return t.User[key], nil
}

// RenameUser renames an entry in the list User within
// the IETFSystem_System_Authentication struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *IETFSystem_System_Authentication) RenameUser(oldK, newK string) error {
	if _, ok := t.User[newK]; ok {
		return fmt.Errorf("key %v already exists in User", newK)
	}

	e, ok := t.User[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in User", oldK)
	}
	e.Name = &newK

	t.User[newK] = e
	delete(t.User, oldK)
	return nil
}

// GetOrCreateUserMap returns the list (map) from IETFSystem_System_Authentication.
//
// It initializes the field if not already initialized.
func (t *IETFSystem_System_Authentication) GetOrCreateUserMap() map[string]*IETFSystem_System_Authentication_User {
	if t.User == nil {
		t.User = make(map[string]*IETFSystem_System_Authentication_User)
	}
	return t.User
}

// GetOrCreateUser retrieves the value with the specified keys from
// the receiver IETFSystem_System_Authentication. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *IETFSystem_System_Authentication) GetOrCreateUser(Name string) (*IETFSystem_System_Authentication_User){

	key := Name

	if v, ok := t.User[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewUser(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateUser got unexpected error: %v", err))
	}
	return v
}

// GetUser retrieves the value with the specified key from
// the User map field of IETFSystem_System_Authentication. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *IETFSystem_System_Authentication) GetUser(Name string) (*IETFSystem_System_Authentication_User){

	if t == nil {
		return nil
	}

  key := Name

  if lm, ok := t.User[key]; ok {
    return lm
  }
  return nil
}

// AppendUser appends the supplied IETFSystem_System_Authentication_User struct to the
// list User of IETFSystem_System_Authentication. If the key value(s) specified in
// the supplied IETFSystem_System_Authentication_User already exist in the list, an error is
// returned.
func (t *IETFSystem_System_Authentication) AppendUser(v *IETFSystem_System_Authentication_User) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.User == nil {
		t.User = make(map[string]*IETFSystem_System_Authentication_User)
	}

	if _, ok := t.User[key]; ok {
		return fmt.Errorf("duplicate key for list User %v", key)
	}

	t.User[key] = v
	return nil
}

// GetUserAuthenticationOrder retrieves the value of the leaf UserAuthenticationOrder from the IETFSystem_System_Authentication
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UserAuthenticationOrder is set, it can
// safely use t.GetUserAuthenticationOrder() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UserAuthenticationOrder == nil' before retrieving the leaf's value.
func (t *IETFSystem_System_Authentication) GetUserAuthenticationOrder() []E_IETFSystem_AuthenticationMethod {
	if t == nil || t.UserAuthenticationOrder ==  nil {
		return nil
	}
	return t.UserAuthenticationOrder
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSystem_System_Authentication) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSystem_System_Authentication"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSystem_System_Authentication) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSystem_System_Authentication) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSystem_System_Authentication.
func (*IETFSystem_System_Authentication) ΛBelongingModule() string {
	return "ietf-system"
}


// IETFSystem_System_Authentication_User represents the /ietf-system/system/authentication/user YANG schema element.
type IETFSystem_System_Authentication_User struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	AuthorizedKey	map[string]*IETFSystem_System_Authentication_User_AuthorizedKey	`path:"authorized-key" module:"ietf-system"`
	ΛAuthorizedKey	[]ygot.Annotation	`path:"@authorized-key" ygotAnnotation:"true"`
	Name	*string	`path:"name" module:"ietf-system"`
	ΛName	[]ygot.Annotation	`path:"@name" ygotAnnotation:"true"`
	Password	*string	`path:"password" module:"ietf-system"`
	ΛPassword	[]ygot.Annotation	`path:"@password" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSystem_System_Authentication_User implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSystem_System_Authentication_User) IsYANGGoStruct() {}

// NewAuthorizedKey creates a new entry in the AuthorizedKey list of the
// IETFSystem_System_Authentication_User struct. The keys of the list are populated from the input
// arguments.
func (t *IETFSystem_System_Authentication_User) NewAuthorizedKey(Name string) (*IETFSystem_System_Authentication_User_AuthorizedKey, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AuthorizedKey == nil {
		t.AuthorizedKey = make(map[string]*IETFSystem_System_Authentication_User_AuthorizedKey)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AuthorizedKey[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AuthorizedKey", key)
	}

	t.AuthorizedKey[key] = &IETFSystem_System_Authentication_User_AuthorizedKey{
		Name: &Name,
	}

	return t.AuthorizedKey[key], nil
}

// RenameAuthorizedKey renames an entry in the list AuthorizedKey within
// the IETFSystem_System_Authentication_User struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *IETFSystem_System_Authentication_User) RenameAuthorizedKey(oldK, newK string) error {
	if _, ok := t.AuthorizedKey[newK]; ok {
		return fmt.Errorf("key %v already exists in AuthorizedKey", newK)
	}

	e, ok := t.AuthorizedKey[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AuthorizedKey", oldK)
	}
	e.Name = &newK

	t.AuthorizedKey[newK] = e
	delete(t.AuthorizedKey, oldK)
	return nil
}

// GetOrCreateAuthorizedKeyMap returns the list (map) from IETFSystem_System_Authentication_User.
//
// It initializes the field if not already initialized.
func (t *IETFSystem_System_Authentication_User) GetOrCreateAuthorizedKeyMap() map[string]*IETFSystem_System_Authentication_User_AuthorizedKey {
	if t.AuthorizedKey == nil {
		t.AuthorizedKey = make(map[string]*IETFSystem_System_Authentication_User_AuthorizedKey)
	}
	return t.AuthorizedKey
}

// GetOrCreateAuthorizedKey retrieves the value with the specified keys from
// the receiver IETFSystem_System_Authentication_User. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *IETFSystem_System_Authentication_User) GetOrCreateAuthorizedKey(Name string) (*IETFSystem_System_Authentication_User_AuthorizedKey){

	key := Name

	if v, ok := t.AuthorizedKey[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAuthorizedKey(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAuthorizedKey got unexpected error: %v", err))
	}
	return v
}

// GetAuthorizedKey retrieves the value with the specified key from
// the AuthorizedKey map field of IETFSystem_System_Authentication_User. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *IETFSystem_System_Authentication_User) GetAuthorizedKey(Name string) (*IETFSystem_System_Authentication_User_AuthorizedKey){

	if t == nil {
		return nil
	}

  key := Name

  if lm, ok := t.AuthorizedKey[key]; ok {
    return lm
  }
  return nil
}

// AppendAuthorizedKey appends the supplied IETFSystem_System_Authentication_User_AuthorizedKey struct to the
// list AuthorizedKey of IETFSystem_System_Authentication_User. If the key value(s) specified in
// the supplied IETFSystem_System_Authentication_User_AuthorizedKey already exist in the list, an error is
// returned.
func (t *IETFSystem_System_Authentication_User) AppendAuthorizedKey(v *IETFSystem_System_Authentication_User_AuthorizedKey) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AuthorizedKey == nil {
		t.AuthorizedKey = make(map[string]*IETFSystem_System_Authentication_User_AuthorizedKey)
	}

	if _, ok := t.AuthorizedKey[key]; ok {
		return fmt.Errorf("duplicate key for list AuthorizedKey %v", key)
	}

	t.AuthorizedKey[key] = v
	return nil
}

// GetName retrieves the value of the leaf Name from the IETFSystem_System_Authentication_User
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *IETFSystem_System_Authentication_User) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetPassword retrieves the value of the leaf Password from the IETFSystem_System_Authentication_User
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Password is set, it can
// safely use t.GetPassword() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Password == nil' before retrieving the leaf's value.
func (t *IETFSystem_System_Authentication_User) GetPassword() string {
	if t == nil || t.Password == nil {
		return ""
	}
	return *t.Password
}

// ΛListKeyMap returns the keys of the IETFSystem_System_Authentication_User struct, which is a YANG list entry.
func (t *IETFSystem_System_Authentication_User) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSystem_System_Authentication_User) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSystem_System_Authentication_User"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSystem_System_Authentication_User) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSystem_System_Authentication_User) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSystem_System_Authentication_User.
func (*IETFSystem_System_Authentication_User) ΛBelongingModule() string {
	return "ietf-system"
}


// IETFSystem_System_Authentication_User_AuthorizedKey represents the /ietf-system/system/authentication/user/authorized-key YANG schema element.
type IETFSystem_System_Authentication_User_AuthorizedKey struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Algorithm	*string	`path:"algorithm" module:"ietf-system"`
	ΛAlgorithm	[]ygot.Annotation	`path:"@algorithm" ygotAnnotation:"true"`
	KeyData	Binary	`path:"key-data" module:"ietf-system"`
	ΛKeyData	[]ygot.Annotation	`path:"@key-data" ygotAnnotation:"true"`
	Name	*string	`path:"name" module:"ietf-system"`
	ΛName	[]ygot.Annotation	`path:"@name" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSystem_System_Authentication_User_AuthorizedKey implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSystem_System_Authentication_User_AuthorizedKey) IsYANGGoStruct() {}

// GetAlgorithm retrieves the value of the leaf Algorithm from the IETFSystem_System_Authentication_User_AuthorizedKey
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Algorithm is set, it can
// safely use t.GetAlgorithm() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Algorithm == nil' before retrieving the leaf's value.
func (t *IETFSystem_System_Authentication_User_AuthorizedKey) GetAlgorithm() string {
	if t == nil || t.Algorithm == nil {
		return ""
	}
	return *t.Algorithm
}

// GetKeyData retrieves the value of the leaf KeyData from the IETFSystem_System_Authentication_User_AuthorizedKey
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if KeyData is set, it can
// safely use t.GetKeyData() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.KeyData == nil' before retrieving the leaf's value.
func (t *IETFSystem_System_Authentication_User_AuthorizedKey) GetKeyData() Binary {
	if t == nil || t.KeyData ==  nil {
		return nil
	}
	return t.KeyData
}

// GetName retrieves the value of the leaf Name from the IETFSystem_System_Authentication_User_AuthorizedKey
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *IETFSystem_System_Authentication_User_AuthorizedKey) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// ΛListKeyMap returns the keys of the IETFSystem_System_Authentication_User_AuthorizedKey struct, which is a YANG list entry.
func (t *IETFSystem_System_Authentication_User_AuthorizedKey) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSystem_System_Authentication_User_AuthorizedKey) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSystem_System_Authentication_User_AuthorizedKey"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSystem_System_Authentication_User_AuthorizedKey) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSystem_System_Authentication_User_AuthorizedKey) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSystem_System_Authentication_User_AuthorizedKey.
func (*IETFSystem_System_Authentication_User_AuthorizedKey) ΛBelongingModule() string {
	return "ietf-system"
}


// IETFSystem_System_Clock represents the /ietf-system/system/clock YANG schema element.
type IETFSystem_System_Clock struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	TimezoneName	*string	`path:"timezone-name" module:"ietf-system"`
	ΛTimezoneName	[]ygot.Annotation	`path:"@timezone-name" ygotAnnotation:"true"`
	TimezoneUtcOffset	*int16	`path:"timezone-utc-offset" module:"ietf-system"`
	ΛTimezoneUtcOffset	[]ygot.Annotation	`path:"@timezone-utc-offset" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSystem_System_Clock implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSystem_System_Clock) IsYANGGoStruct() {}

// GetTimezoneName retrieves the value of the leaf TimezoneName from the IETFSystem_System_Clock
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TimezoneName is set, it can
// safely use t.GetTimezoneName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TimezoneName == nil' before retrieving the leaf's value.
func (t *IETFSystem_System_Clock) GetTimezoneName() string {
	if t == nil || t.TimezoneName == nil {
		return ""
	}
	return *t.TimezoneName
}

// GetTimezoneUtcOffset retrieves the value of the leaf TimezoneUtcOffset from the IETFSystem_System_Clock
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TimezoneUtcOffset is set, it can
// safely use t.GetTimezoneUtcOffset() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TimezoneUtcOffset == nil' before retrieving the leaf's value.
func (t *IETFSystem_System_Clock) GetTimezoneUtcOffset() int16 {
	if t == nil || t.TimezoneUtcOffset == nil {
		return 0
	}
	return *t.TimezoneUtcOffset
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSystem_System_Clock) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSystem_System_Clock"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSystem_System_Clock) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSystem_System_Clock) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSystem_System_Clock.
func (*IETFSystem_System_Clock) ΛBelongingModule() string {
	return "ietf-system"
}


// IETFSystem_System_DnsResolver represents the /ietf-system/system/dns-resolver YANG schema element.
type IETFSystem_System_DnsResolver struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Options	*IETFSystem_System_DnsResolver_Options	`path:"options" module:"ietf-system"`
	ΛOptions	[]ygot.Annotation	`path:"@options" ygotAnnotation:"true"`
	Search	[]string	`path:"search" module:"ietf-system"`
	ΛSearch	[]ygot.Annotation	`path:"@search" ygotAnnotation:"true"`
	Server	*IETFSystem_System_DnsResolver_Server_OrderedMap	`path:"server" module:"ietf-system"`
	ΛServer	[]ygot.Annotation	`path:"@server" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSystem_System_DnsResolver implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSystem_System_DnsResolver) IsYANGGoStruct() {}

// GetOrCreateOptions retrieves the value of the Options field
// or returns the existing field if it already exists.
func (t *IETFSystem_System_DnsResolver) GetOrCreateOptions() *IETFSystem_System_DnsResolver_Options {
	if t.Options != nil {
		return t.Options
	}
	t.Options = &IETFSystem_System_DnsResolver_Options{}
	return t.Options
}

// GetOptions returns the value of the Options struct pointer
// from IETFSystem_System_DnsResolver. If the receiver or the field Options is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IETFSystem_System_DnsResolver) GetOptions() *IETFSystem_System_DnsResolver_Options {
	if t != nil && t.Options != nil {
		return t.Options
	}
	return nil
}

// GetSearch retrieves the value of the leaf Search from the IETFSystem_System_DnsResolver
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Search is set, it can
// safely use t.GetSearch() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Search == nil' before retrieving the leaf's value.
func (t *IETFSystem_System_DnsResolver) GetSearch() []string {
	if t == nil || t.Search ==  nil {
		return nil
	}
	return t.Search
}

// GetOrCreateServerMap returns the ordered map field
// Server from IETFSystem_System_DnsResolver.
//
// It initializes the field if not already initialized.
func (s *IETFSystem_System_DnsResolver) GetOrCreateServerMap() *IETFSystem_System_DnsResolver_Server_OrderedMap {
	if s.Server == nil {
		s.Server = &IETFSystem_System_DnsResolver_Server_OrderedMap{}
	}
	return s.Server
}

// AppendNewServer creates a new entry in the Server
// ordered map of the IETFSystem_System_DnsResolver struct. The keys of the list are
// populated from the input arguments.
func (s *IETFSystem_System_DnsResolver) AppendNewServer(Name string) (*IETFSystem_System_DnsResolver_Server, error) {
	if s.Server == nil {
		s.Server = &IETFSystem_System_DnsResolver_Server_OrderedMap{}
	}
	return s.Server.AppendNew(Name)
}

// AppendServer appends the supplied IETFSystem_System_DnsResolver_Server struct
// to the list Server of IETFSystem_System_DnsResolver. If the key value(s)
// specified in the supplied IETFSystem_System_DnsResolver_Server already exist in the list, an
// error is returned.
func (s *IETFSystem_System_DnsResolver) AppendServer(v *IETFSystem_System_DnsResolver_Server) error {
	if s.Server == nil {
		s.Server = &IETFSystem_System_DnsResolver_Server_OrderedMap{}
	}
	return s.Server.Append(v)
}

// GetServer retrieves the value with the specified key from the
// Server map field of IETFSystem_System_DnsResolver. If the receiver
// is nil, or the specified key is not present in the list, nil is returned
// such that Get* methods may be safely chained.
func (s *IETFSystem_System_DnsResolver) GetServer(Name string) *IETFSystem_System_DnsResolver_Server {
	if s == nil {
		return nil
	}
	key := Name
	return s.Server.Get(key)
}

// DeleteServer deletes the value with the specified keys from
// the receiver IETFSystem_System_DnsResolver. If there is no such element, the
// function is a no-op.
func (s *IETFSystem_System_DnsResolver) DeleteServer(Name string) bool {
	key := Name
	return s.Server.Delete(key)
}

// IETFSystem_System_DnsResolver_Server_OrderedMap is an ordered map that represents the "ordered-by user"
// list elements at /ietf-system/system/dns-resolver/server.
type IETFSystem_System_DnsResolver_Server_OrderedMap struct {
	keys []string
	valueMap map[string]*IETFSystem_System_DnsResolver_Server
}

// IsYANGOrderedList ensures that IETFSystem_System_DnsResolver_Server_OrderedMap implements the
// ygot.GoOrderedMap interface.
func (*IETFSystem_System_DnsResolver_Server_OrderedMap) IsYANGOrderedList() {}

// init initializes any uninitialized values.
func (o *IETFSystem_System_DnsResolver_Server_OrderedMap) init() {
	if o == nil {
		return
	}
	if o.valueMap == nil {
		o.valueMap = map[string]*IETFSystem_System_DnsResolver_Server{}
	}
}

// Keys returns a copy of the list's keys.
func (o *IETFSystem_System_DnsResolver_Server_OrderedMap) Keys() []string {
	if o == nil {
		return nil
	}
	return append([]string{}, o.keys...)
}

// Values returns the current set of the list's values in order.
func (o *IETFSystem_System_DnsResolver_Server_OrderedMap) Values() []*IETFSystem_System_DnsResolver_Server {
	if o == nil {
		return nil
	}
	var values []*IETFSystem_System_DnsResolver_Server
	for _, key := range o.keys {
		values = append(values, o.valueMap[key])
	}
	return values
}

// Len returns a size of IETFSystem_System_DnsResolver_Server_OrderedMap
func (o *IETFSystem_System_DnsResolver_Server_OrderedMap) Len() int {
	if o == nil {
		return 0
	}
	return len(o.keys)
}

// Get returns the value corresponding to the key. If the key is not found, nil
// is returned.
func (o *IETFSystem_System_DnsResolver_Server_OrderedMap) Get(key string) *IETFSystem_System_DnsResolver_Server {
	if o == nil {
		return nil
	}
	val, _ := o.valueMap[key]
	return val
}

// Delete deletes an element.
func (o *IETFSystem_System_DnsResolver_Server_OrderedMap) Delete(key string) bool {
	if o == nil {
		return false
	}
	if _, ok := o.valueMap[key]; !ok {
		return false
	}
	for i, k := range o.keys {
		if k == key {
			o.keys = append(o.keys[:i], o.keys[i+1:]...)
			delete(o.valueMap, key)
			return true
		}
	}
	return false
}

// Append appends a IETFSystem_System_DnsResolver_Server, returning an error if the key
// already exists in the ordered list or if the key is unspecified.
func (o *IETFSystem_System_DnsResolver_Server_OrderedMap) Append(v *IETFSystem_System_DnsResolver_Server) error {
	if o == nil {
		return fmt.Errorf("nil ordered map, cannot append IETFSystem_System_DnsResolver_Server")
	}
	if v == nil {
		return fmt.Errorf("nil IETFSystem_System_DnsResolver_Server")
	}
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	if _, ok := o.valueMap[key]; ok {
		return fmt.Errorf("duplicate key for list Statement %v", key)
	}
	o.keys = append(o.keys, key)
	o.init()
	o.valueMap[key] = v
	return nil
}

// AppendNew creates and appends a new IETFSystem_System_DnsResolver_Server, returning the
// newly-initialized v. It returns an error if the v already exists.
func (o *IETFSystem_System_DnsResolver_Server_OrderedMap) AppendNew(Name string) (*IETFSystem_System_DnsResolver_Server, error) {
	if o == nil {
		return nil, fmt.Errorf("nil ordered map, cannot append IETFSystem_System_DnsResolver_Server")
	}
	key := Name

	if _, ok := o.valueMap[key]; ok {
		return nil, fmt.Errorf("duplicate key for list Statement %v", key)
	}
	o.keys = append(o.keys, key)
	newElement := &IETFSystem_System_DnsResolver_Server{
		Name: &Name,
	}
	o.init()
	o.valueMap[key] = newElement
	return newElement, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSystem_System_DnsResolver) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSystem_System_DnsResolver"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSystem_System_DnsResolver) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSystem_System_DnsResolver) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSystem_System_DnsResolver.
func (*IETFSystem_System_DnsResolver) ΛBelongingModule() string {
	return "ietf-system"
}


// IETFSystem_System_DnsResolver_Options represents the /ietf-system/system/dns-resolver/options YANG schema element.
type IETFSystem_System_DnsResolver_Options struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Attempts	*uint8	`path:"attempts" module:"ietf-system"`
	ΛAttempts	[]ygot.Annotation	`path:"@attempts" ygotAnnotation:"true"`
	Timeout	*uint8	`path:"timeout" module:"ietf-system"`
	ΛTimeout	[]ygot.Annotation	`path:"@timeout" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSystem_System_DnsResolver_Options implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSystem_System_DnsResolver_Options) IsYANGGoStruct() {}

// GetAttempts retrieves the value of the leaf Attempts from the IETFSystem_System_DnsResolver_Options
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Attempts is set, it can
// safely use t.GetAttempts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Attempts == nil' before retrieving the leaf's value.
func (t *IETFSystem_System_DnsResolver_Options) GetAttempts() uint8 {
	if t == nil || t.Attempts == nil {
		return 2
	}
	return *t.Attempts
}

// GetTimeout retrieves the value of the leaf Timeout from the IETFSystem_System_DnsResolver_Options
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Timeout is set, it can
// safely use t.GetTimeout() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Timeout == nil' before retrieving the leaf's value.
func (t *IETFSystem_System_DnsResolver_Options) GetTimeout() uint8 {
	if t == nil || t.Timeout == nil {
		return 5
	}
	return *t.Timeout
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSystem_System_DnsResolver_Options) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSystem_System_DnsResolver_Options"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSystem_System_DnsResolver_Options) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSystem_System_DnsResolver_Options) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSystem_System_DnsResolver_Options.
func (*IETFSystem_System_DnsResolver_Options) ΛBelongingModule() string {
	return "ietf-system"
}


// IETFSystem_System_DnsResolver_Server represents the /ietf-system/system/dns-resolver/server YANG schema element.
type IETFSystem_System_DnsResolver_Server struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Name	*string	`path:"name" module:"ietf-system"`
	ΛName	[]ygot.Annotation	`path:"@name" ygotAnnotation:"true"`
	UdpAndTcp	*IETFSystem_System_DnsResolver_Server_UdpAndTcp	`path:"udp-and-tcp" module:"ietf-system"`
	ΛUdpAndTcp	[]ygot.Annotation	`path:"@udp-and-tcp" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSystem_System_DnsResolver_Server implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSystem_System_DnsResolver_Server) IsYANGGoStruct() {}

// GetOrCreateUdpAndTcp retrieves the value of the UdpAndTcp field
// or returns the existing field if it already exists.
func (t *IETFSystem_System_DnsResolver_Server) GetOrCreateUdpAndTcp() *IETFSystem_System_DnsResolver_Server_UdpAndTcp {
	if t.UdpAndTcp != nil {
		return t.UdpAndTcp
	}
	t.UdpAndTcp = &IETFSystem_System_DnsResolver_Server_UdpAndTcp{}
	return t.UdpAndTcp
}

// GetUdpAndTcp returns the value of the UdpAndTcp struct pointer
// from IETFSystem_System_DnsResolver_Server. If the receiver or the field UdpAndTcp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IETFSystem_System_DnsResolver_Server) GetUdpAndTcp() *IETFSystem_System_DnsResolver_Server_UdpAndTcp {
	if t != nil && t.UdpAndTcp != nil {
		return t.UdpAndTcp
	}
	return nil
}

// GetName retrieves the value of the leaf Name from the IETFSystem_System_DnsResolver_Server
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *IETFSystem_System_DnsResolver_Server) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// ΛListKeyMap returns the keys of the IETFSystem_System_DnsResolver_Server struct, which is a YANG list entry.
func (t *IETFSystem_System_DnsResolver_Server) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSystem_System_DnsResolver_Server) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSystem_System_DnsResolver_Server"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSystem_System_DnsResolver_Server) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSystem_System_DnsResolver_Server) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSystem_System_DnsResolver_Server.
func (*IETFSystem_System_DnsResolver_Server) ΛBelongingModule() string {
	return "ietf-system"
}


// IETFSystem_System_DnsResolver_Server_UdpAndTcp represents the /ietf-system/system/dns-resolver/server/udp-and-tcp YANG schema element.
type IETFSystem_System_DnsResolver_Server_UdpAndTcp struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Address	*string	`path:"address" module:"ietf-system"`
	ΛAddress	[]ygot.Annotation	`path:"@address" ygotAnnotation:"true"`
	Port	*uint16	`path:"port" module:"ietf-system"`
	ΛPort	[]ygot.Annotation	`path:"@port" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSystem_System_DnsResolver_Server_UdpAndTcp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSystem_System_DnsResolver_Server_UdpAndTcp) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the IETFSystem_System_DnsResolver_Server_UdpAndTcp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *IETFSystem_System_DnsResolver_Server_UdpAndTcp) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetPort retrieves the value of the leaf Port from the IETFSystem_System_DnsResolver_Server_UdpAndTcp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Port is set, it can
// safely use t.GetPort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Port == nil' before retrieving the leaf's value.
func (t *IETFSystem_System_DnsResolver_Server_UdpAndTcp) GetPort() uint16 {
	if t == nil || t.Port == nil {
		return 53
	}
	return *t.Port
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSystem_System_DnsResolver_Server_UdpAndTcp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSystem_System_DnsResolver_Server_UdpAndTcp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSystem_System_DnsResolver_Server_UdpAndTcp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSystem_System_DnsResolver_Server_UdpAndTcp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSystem_System_DnsResolver_Server_UdpAndTcp.
func (*IETFSystem_System_DnsResolver_Server_UdpAndTcp) ΛBelongingModule() string {
	return "ietf-system"
}


// IETFSystem_System_Ntp represents the /ietf-system/system/ntp YANG schema element.
type IETFSystem_System_Ntp struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Enabled	*bool	`path:"enabled" module:"ietf-system"`
	ΛEnabled	[]ygot.Annotation	`path:"@enabled" ygotAnnotation:"true"`
	Server	map[string]*IETFSystem_System_Ntp_Server	`path:"server" module:"ietf-system"`
	ΛServer	[]ygot.Annotation	`path:"@server" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSystem_System_Ntp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSystem_System_Ntp) IsYANGGoStruct() {}

// NewServer creates a new entry in the Server list of the
// IETFSystem_System_Ntp struct. The keys of the list are populated from the input
// arguments.
func (t *IETFSystem_System_Ntp) NewServer(Name string) (*IETFSystem_System_Ntp_Server, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Server == nil {
		t.Server = make(map[string]*IETFSystem_System_Ntp_Server)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Server[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Server", key)
	}

	t.Server[key] = &IETFSystem_System_Ntp_Server{
		Name: &Name,
	}

	return t.Server[key], nil
}

// RenameServer renames an entry in the list Server within
// the IETFSystem_System_Ntp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *IETFSystem_System_Ntp) RenameServer(oldK, newK string) error {
	if _, ok := t.Server[newK]; ok {
		return fmt.Errorf("key %v already exists in Server", newK)
	}

	e, ok := t.Server[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Server", oldK)
	}
	e.Name = &newK

	t.Server[newK] = e
	delete(t.Server, oldK)
	return nil
}

// GetOrCreateServerMap returns the list (map) from IETFSystem_System_Ntp.
//
// It initializes the field if not already initialized.
func (t *IETFSystem_System_Ntp) GetOrCreateServerMap() map[string]*IETFSystem_System_Ntp_Server {
	if t.Server == nil {
		t.Server = make(map[string]*IETFSystem_System_Ntp_Server)
	}
	return t.Server
}

// GetOrCreateServer retrieves the value with the specified keys from
// the receiver IETFSystem_System_Ntp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *IETFSystem_System_Ntp) GetOrCreateServer(Name string) (*IETFSystem_System_Ntp_Server){

	key := Name

	if v, ok := t.Server[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewServer(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateServer got unexpected error: %v", err))
	}
	return v
}

// GetServer retrieves the value with the specified key from
// the Server map field of IETFSystem_System_Ntp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *IETFSystem_System_Ntp) GetServer(Name string) (*IETFSystem_System_Ntp_Server){

	if t == nil {
		return nil
	}

  key := Name

  if lm, ok := t.Server[key]; ok {
    return lm
  }
  return nil
}

// AppendServer appends the supplied IETFSystem_System_Ntp_Server struct to the
// list Server of IETFSystem_System_Ntp. If the key value(s) specified in
// the supplied IETFSystem_System_Ntp_Server already exist in the list, an error is
// returned.
func (t *IETFSystem_System_Ntp) AppendServer(v *IETFSystem_System_Ntp_Server) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Server == nil {
		t.Server = make(map[string]*IETFSystem_System_Ntp_Server)
	}

	if _, ok := t.Server[key]; ok {
		return fmt.Errorf("duplicate key for list Server %v", key)
	}

	t.Server[key] = v
	return nil
}

// GetEnabled retrieves the value of the leaf Enabled from the IETFSystem_System_Ntp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Enabled is set, it can
// safely use t.GetEnabled() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Enabled == nil' before retrieving the leaf's value.
func (t *IETFSystem_System_Ntp) GetEnabled() bool {
	if t == nil || t.Enabled == nil {
		return true
	}
	return *t.Enabled
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSystem_System_Ntp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSystem_System_Ntp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSystem_System_Ntp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSystem_System_Ntp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSystem_System_Ntp.
func (*IETFSystem_System_Ntp) ΛBelongingModule() string {
	return "ietf-system"
}


// IETFSystem_System_Ntp_Server represents the /ietf-system/system/ntp/server YANG schema element.
type IETFSystem_System_Ntp_Server struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	AssociationType	E_IETFSystem_System_Ntp_Server_AssociationType	`path:"association-type" module:"ietf-system"`
	ΛAssociationType	[]ygot.Annotation	`path:"@association-type" ygotAnnotation:"true"`
	Iburst	*bool	`path:"iburst" module:"ietf-system"`
	ΛIburst	[]ygot.Annotation	`path:"@iburst" ygotAnnotation:"true"`
	Name	*string	`path:"name" module:"ietf-system"`
	ΛName	[]ygot.Annotation	`path:"@name" ygotAnnotation:"true"`
	Prefer	*bool	`path:"prefer" module:"ietf-system"`
	ΛPrefer	[]ygot.Annotation	`path:"@prefer" ygotAnnotation:"true"`
	Udp	*IETFSystem_System_Ntp_Server_Udp	`path:"udp" module:"ietf-system"`
	ΛUdp	[]ygot.Annotation	`path:"@udp" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSystem_System_Ntp_Server implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSystem_System_Ntp_Server) IsYANGGoStruct() {}

// GetOrCreateUdp retrieves the value of the Udp field
// or returns the existing field if it already exists.
func (t *IETFSystem_System_Ntp_Server) GetOrCreateUdp() *IETFSystem_System_Ntp_Server_Udp {
	if t.Udp != nil {
		return t.Udp
	}
	t.Udp = &IETFSystem_System_Ntp_Server_Udp{}
	return t.Udp
}

// GetUdp returns the value of the Udp struct pointer
// from IETFSystem_System_Ntp_Server. If the receiver or the field Udp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IETFSystem_System_Ntp_Server) GetUdp() *IETFSystem_System_Ntp_Server_Udp {
	if t != nil && t.Udp != nil {
		return t.Udp
	}
	return nil
}

// GetAssociationType retrieves the value of the leaf AssociationType from the IETFSystem_System_Ntp_Server
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AssociationType is set, it can
// safely use t.GetAssociationType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AssociationType == nil' before retrieving the leaf's value.
func (t *IETFSystem_System_Ntp_Server) GetAssociationType() E_IETFSystem_System_Ntp_Server_AssociationType {
	if t == nil || t.AssociationType ==  0 {
		return IETFSystem_System_Ntp_Server_AssociationType_server
	}
	return t.AssociationType
}

// GetIburst retrieves the value of the leaf Iburst from the IETFSystem_System_Ntp_Server
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Iburst is set, it can
// safely use t.GetIburst() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Iburst == nil' before retrieving the leaf's value.
func (t *IETFSystem_System_Ntp_Server) GetIburst() bool {
	if t == nil || t.Iburst == nil {
		return false
	}
	return *t.Iburst
}

// GetName retrieves the value of the leaf Name from the IETFSystem_System_Ntp_Server
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *IETFSystem_System_Ntp_Server) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetPrefer retrieves the value of the leaf Prefer from the IETFSystem_System_Ntp_Server
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefer is set, it can
// safely use t.GetPrefer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefer == nil' before retrieving the leaf's value.
func (t *IETFSystem_System_Ntp_Server) GetPrefer() bool {
	if t == nil || t.Prefer == nil {
		return false
	}
	return *t.Prefer
}

// ΛListKeyMap returns the keys of the IETFSystem_System_Ntp_Server struct, which is a YANG list entry.
func (t *IETFSystem_System_Ntp_Server) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSystem_System_Ntp_Server) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSystem_System_Ntp_Server"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSystem_System_Ntp_Server) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSystem_System_Ntp_Server) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSystem_System_Ntp_Server.
func (*IETFSystem_System_Ntp_Server) ΛBelongingModule() string {
	return "ietf-system"
}


// IETFSystem_System_Ntp_Server_Udp represents the /ietf-system/system/ntp/server/udp YANG schema element.
type IETFSystem_System_Ntp_Server_Udp struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Address	*string	`path:"address" module:"ietf-system"`
	ΛAddress	[]ygot.Annotation	`path:"@address" ygotAnnotation:"true"`
	Port	*uint16	`path:"port" module:"ietf-system"`
	ΛPort	[]ygot.Annotation	`path:"@port" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSystem_System_Ntp_Server_Udp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSystem_System_Ntp_Server_Udp) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the IETFSystem_System_Ntp_Server_Udp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *IETFSystem_System_Ntp_Server_Udp) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetPort retrieves the value of the leaf Port from the IETFSystem_System_Ntp_Server_Udp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Port is set, it can
// safely use t.GetPort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Port == nil' before retrieving the leaf's value.
func (t *IETFSystem_System_Ntp_Server_Udp) GetPort() uint16 {
	if t == nil || t.Port == nil {
		return 123
	}
	return *t.Port
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSystem_System_Ntp_Server_Udp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSystem_System_Ntp_Server_Udp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSystem_System_Ntp_Server_Udp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSystem_System_Ntp_Server_Udp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSystem_System_Ntp_Server_Udp.
func (*IETFSystem_System_Ntp_Server_Udp) ΛBelongingModule() string {
	return "ietf-system"
}


// IETFSystem_System_Radius represents the /ietf-system/system/radius YANG schema element.
type IETFSystem_System_Radius struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Options	*IETFSystem_System_Radius_Options	`path:"options" module:"ietf-system"`
	ΛOptions	[]ygot.Annotation	`path:"@options" ygotAnnotation:"true"`
	Server	*IETFSystem_System_Radius_Server_OrderedMap	`path:"server" module:"ietf-system"`
	ΛServer	[]ygot.Annotation	`path:"@server" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSystem_System_Radius implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSystem_System_Radius) IsYANGGoStruct() {}

// GetOrCreateOptions retrieves the value of the Options field
// or returns the existing field if it already exists.
func (t *IETFSystem_System_Radius) GetOrCreateOptions() *IETFSystem_System_Radius_Options {
	if t.Options != nil {
		return t.Options
	}
	t.Options = &IETFSystem_System_Radius_Options{}
	return t.Options
}

// GetOptions returns the value of the Options struct pointer
// from IETFSystem_System_Radius. If the receiver or the field Options is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IETFSystem_System_Radius) GetOptions() *IETFSystem_System_Radius_Options {
	if t != nil && t.Options != nil {
		return t.Options
	}
	return nil
}

// GetOrCreateServerMap returns the ordered map field
// Server from IETFSystem_System_Radius.
//
// It initializes the field if not already initialized.
func (s *IETFSystem_System_Radius) GetOrCreateServerMap() *IETFSystem_System_Radius_Server_OrderedMap {
	if s.Server == nil {
		s.Server = &IETFSystem_System_Radius_Server_OrderedMap{}
	}
	return s.Server
}

// AppendNewServer creates a new entry in the Server
// ordered map of the IETFSystem_System_Radius struct. The keys of the list are
// populated from the input arguments.
func (s *IETFSystem_System_Radius) AppendNewServer(Name string) (*IETFSystem_System_Radius_Server, error) {
	if s.Server == nil {
		s.Server = &IETFSystem_System_Radius_Server_OrderedMap{}
	}
	return s.Server.AppendNew(Name)
}

// AppendServer appends the supplied IETFSystem_System_Radius_Server struct
// to the list Server of IETFSystem_System_Radius. If the key value(s)
// specified in the supplied IETFSystem_System_Radius_Server already exist in the list, an
// error is returned.
func (s *IETFSystem_System_Radius) AppendServer(v *IETFSystem_System_Radius_Server) error {
	if s.Server == nil {
		s.Server = &IETFSystem_System_Radius_Server_OrderedMap{}
	}
	return s.Server.Append(v)
}

// GetServer retrieves the value with the specified key from the
// Server map field of IETFSystem_System_Radius. If the receiver
// is nil, or the specified key is not present in the list, nil is returned
// such that Get* methods may be safely chained.
func (s *IETFSystem_System_Radius) GetServer(Name string) *IETFSystem_System_Radius_Server {
	if s == nil {
		return nil
	}
	key := Name
	return s.Server.Get(key)
}

// DeleteServer deletes the value with the specified keys from
// the receiver IETFSystem_System_Radius. If there is no such element, the
// function is a no-op.
func (s *IETFSystem_System_Radius) DeleteServer(Name string) bool {
	key := Name
	return s.Server.Delete(key)
}

// IETFSystem_System_Radius_Server_OrderedMap is an ordered map that represents the "ordered-by user"
// list elements at /ietf-system/system/radius/server.
type IETFSystem_System_Radius_Server_OrderedMap struct {
	keys []string
	valueMap map[string]*IETFSystem_System_Radius_Server
}

// IsYANGOrderedList ensures that IETFSystem_System_Radius_Server_OrderedMap implements the
// ygot.GoOrderedMap interface.
func (*IETFSystem_System_Radius_Server_OrderedMap) IsYANGOrderedList() {}

// init initializes any uninitialized values.
func (o *IETFSystem_System_Radius_Server_OrderedMap) init() {
	if o == nil {
		return
	}
	if o.valueMap == nil {
		o.valueMap = map[string]*IETFSystem_System_Radius_Server{}
	}
}

// Keys returns a copy of the list's keys.
func (o *IETFSystem_System_Radius_Server_OrderedMap) Keys() []string {
	if o == nil {
		return nil
	}
	return append([]string{}, o.keys...)
}

// Values returns the current set of the list's values in order.
func (o *IETFSystem_System_Radius_Server_OrderedMap) Values() []*IETFSystem_System_Radius_Server {
	if o == nil {
		return nil
	}
	var values []*IETFSystem_System_Radius_Server
	for _, key := range o.keys {
		values = append(values, o.valueMap[key])
	}
	return values
}

// Len returns a size of IETFSystem_System_Radius_Server_OrderedMap
func (o *IETFSystem_System_Radius_Server_OrderedMap) Len() int {
	if o == nil {
		return 0
	}
	return len(o.keys)
}

// Get returns the value corresponding to the key. If the key is not found, nil
// is returned.
func (o *IETFSystem_System_Radius_Server_OrderedMap) Get(key string) *IETFSystem_System_Radius_Server {
	if o == nil {
		return nil
	}
	val, _ := o.valueMap[key]
	return val
}

// Delete deletes an element.
func (o *IETFSystem_System_Radius_Server_OrderedMap) Delete(key string) bool {
	if o == nil {
		return false
	}
	if _, ok := o.valueMap[key]; !ok {
		return false
	}
	for i, k := range o.keys {
		if k == key {
			o.keys = append(o.keys[:i], o.keys[i+1:]...)
			delete(o.valueMap, key)
			return true
		}
	}
	return false
}

// Append appends a IETFSystem_System_Radius_Server, returning an error if the key
// already exists in the ordered list or if the key is unspecified.
func (o *IETFSystem_System_Radius_Server_OrderedMap) Append(v *IETFSystem_System_Radius_Server) error {
	if o == nil {
		return fmt.Errorf("nil ordered map, cannot append IETFSystem_System_Radius_Server")
	}
	if v == nil {
		return fmt.Errorf("nil IETFSystem_System_Radius_Server")
	}
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	if _, ok := o.valueMap[key]; ok {
		return fmt.Errorf("duplicate key for list Statement %v", key)
	}
	o.keys = append(o.keys, key)
	o.init()
	o.valueMap[key] = v
	return nil
}

// AppendNew creates and appends a new IETFSystem_System_Radius_Server, returning the
// newly-initialized v. It returns an error if the v already exists.
func (o *IETFSystem_System_Radius_Server_OrderedMap) AppendNew(Name string) (*IETFSystem_System_Radius_Server, error) {
	if o == nil {
		return nil, fmt.Errorf("nil ordered map, cannot append IETFSystem_System_Radius_Server")
	}
	key := Name

	if _, ok := o.valueMap[key]; ok {
		return nil, fmt.Errorf("duplicate key for list Statement %v", key)
	}
	o.keys = append(o.keys, key)
	newElement := &IETFSystem_System_Radius_Server{
		Name: &Name,
	}
	o.init()
	o.valueMap[key] = newElement
	return newElement, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSystem_System_Radius) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSystem_System_Radius"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSystem_System_Radius) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSystem_System_Radius) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSystem_System_Radius.
func (*IETFSystem_System_Radius) ΛBelongingModule() string {
	return "ietf-system"
}


// IETFSystem_System_Radius_Options represents the /ietf-system/system/radius/options YANG schema element.
type IETFSystem_System_Radius_Options struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Attempts	*uint8	`path:"attempts" module:"ietf-system"`
	ΛAttempts	[]ygot.Annotation	`path:"@attempts" ygotAnnotation:"true"`
	Timeout	*uint8	`path:"timeout" module:"ietf-system"`
	ΛTimeout	[]ygot.Annotation	`path:"@timeout" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSystem_System_Radius_Options implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSystem_System_Radius_Options) IsYANGGoStruct() {}

// GetAttempts retrieves the value of the leaf Attempts from the IETFSystem_System_Radius_Options
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Attempts is set, it can
// safely use t.GetAttempts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Attempts == nil' before retrieving the leaf's value.
func (t *IETFSystem_System_Radius_Options) GetAttempts() uint8 {
	if t == nil || t.Attempts == nil {
		return 2
	}
	return *t.Attempts
}

// GetTimeout retrieves the value of the leaf Timeout from the IETFSystem_System_Radius_Options
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Timeout is set, it can
// safely use t.GetTimeout() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Timeout == nil' before retrieving the leaf's value.
func (t *IETFSystem_System_Radius_Options) GetTimeout() uint8 {
	if t == nil || t.Timeout == nil {
		return 5
	}
	return *t.Timeout
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSystem_System_Radius_Options) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSystem_System_Radius_Options"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSystem_System_Radius_Options) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSystem_System_Radius_Options) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSystem_System_Radius_Options.
func (*IETFSystem_System_Radius_Options) ΛBelongingModule() string {
	return "ietf-system"
}


// IETFSystem_System_Radius_Server represents the /ietf-system/system/radius/server YANG schema element.
type IETFSystem_System_Radius_Server struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	AuthenticationType	E_IETFSystem_RadiusAuthenticationType	`path:"authentication-type" module:"ietf-system"`
	ΛAuthenticationType	[]ygot.Annotation	`path:"@authentication-type" ygotAnnotation:"true"`
	Name	*string	`path:"name" module:"ietf-system"`
	ΛName	[]ygot.Annotation	`path:"@name" ygotAnnotation:"true"`
	Udp	*IETFSystem_System_Radius_Server_Udp	`path:"udp" module:"ietf-system"`
	ΛUdp	[]ygot.Annotation	`path:"@udp" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSystem_System_Radius_Server implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSystem_System_Radius_Server) IsYANGGoStruct() {}

// GetOrCreateUdp retrieves the value of the Udp field
// or returns the existing field if it already exists.
func (t *IETFSystem_System_Radius_Server) GetOrCreateUdp() *IETFSystem_System_Radius_Server_Udp {
	if t.Udp != nil {
		return t.Udp
	}
	t.Udp = &IETFSystem_System_Radius_Server_Udp{}
	return t.Udp
}

// GetUdp returns the value of the Udp struct pointer
// from IETFSystem_System_Radius_Server. If the receiver or the field Udp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IETFSystem_System_Radius_Server) GetUdp() *IETFSystem_System_Radius_Server_Udp {
	if t != nil && t.Udp != nil {
		return t.Udp
	}
	return nil
}

// GetAuthenticationType retrieves the value of the leaf AuthenticationType from the IETFSystem_System_Radius_Server
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AuthenticationType is set, it can
// safely use t.GetAuthenticationType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AuthenticationType == nil' before retrieving the leaf's value.
func (t *IETFSystem_System_Radius_Server) GetAuthenticationType() E_IETFSystem_RadiusAuthenticationType {
	if t == nil || t.AuthenticationType ==  0 {
		return IETFSystem_RadiusAuthenticationType_radius_pap
	}
	return t.AuthenticationType
}

// GetName retrieves the value of the leaf Name from the IETFSystem_System_Radius_Server
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *IETFSystem_System_Radius_Server) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// ΛListKeyMap returns the keys of the IETFSystem_System_Radius_Server struct, which is a YANG list entry.
func (t *IETFSystem_System_Radius_Server) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSystem_System_Radius_Server) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSystem_System_Radius_Server"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSystem_System_Radius_Server) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSystem_System_Radius_Server) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSystem_System_Radius_Server.
func (*IETFSystem_System_Radius_Server) ΛBelongingModule() string {
	return "ietf-system"
}


// IETFSystem_System_Radius_Server_Udp represents the /ietf-system/system/radius/server/udp YANG schema element.
type IETFSystem_System_Radius_Server_Udp struct {
	ΛMetadata	[]ygot.Annotation	`path:"@" ygotAnnotation:"true"`
	Address	*string	`path:"address" module:"ietf-system"`
	ΛAddress	[]ygot.Annotation	`path:"@address" ygotAnnotation:"true"`
	AuthenticationPort	*uint16	`path:"authentication-port" module:"ietf-system"`
	ΛAuthenticationPort	[]ygot.Annotation	`path:"@authentication-port" ygotAnnotation:"true"`
	SharedSecret	*string	`path:"shared-secret" module:"ietf-system"`
	ΛSharedSecret	[]ygot.Annotation	`path:"@shared-secret" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that IETFSystem_System_Radius_Server_Udp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IETFSystem_System_Radius_Server_Udp) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the IETFSystem_System_Radius_Server_Udp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *IETFSystem_System_Radius_Server_Udp) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetAuthenticationPort retrieves the value of the leaf AuthenticationPort from the IETFSystem_System_Radius_Server_Udp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AuthenticationPort is set, it can
// safely use t.GetAuthenticationPort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AuthenticationPort == nil' before retrieving the leaf's value.
func (t *IETFSystem_System_Radius_Server_Udp) GetAuthenticationPort() uint16 {
	if t == nil || t.AuthenticationPort == nil {
		return 1812
	}
	return *t.AuthenticationPort
}

// GetSharedSecret retrieves the value of the leaf SharedSecret from the IETFSystem_System_Radius_Server_Udp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SharedSecret is set, it can
// safely use t.GetSharedSecret() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SharedSecret == nil' before retrieving the leaf's value.
func (t *IETFSystem_System_Radius_Server_Udp) GetSharedSecret() string {
	if t == nil || t.SharedSecret == nil {
		return ""
	}
	return *t.SharedSecret
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSystem_System_Radius_Server_Udp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IETFSystem_System_Radius_Server_Udp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IETFSystem_System_Radius_Server_Udp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IETFSystem_System_Radius_Server_Udp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IETFSystem_System_Radius_Server_Udp.
func (*IETFSystem_System_Radius_Server_Udp) ΛBelongingModule() string {
	return "ietf-system"
}


// E_IETFNetconfAcm_ActionType is a derived int64 type which is used to represent
// the enumerated node IETFNetconfAcm_ActionType. An additional value named
// IETFNetconfAcm_ActionType_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_IETFNetconfAcm_ActionType int64

// IsYANGGoEnum ensures that IETFNetconfAcm_ActionType implements the yang.GoEnum
// interface. This ensures that IETFNetconfAcm_ActionType can be identified as a
// mapped type for a YANG enumeration.
func (E_IETFNetconfAcm_ActionType) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  IETFNetconfAcm_ActionType.
func (E_IETFNetconfAcm_ActionType) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_IETFNetconfAcm_ActionType.
func (e E_IETFNetconfAcm_ActionType) String() string {
	return ygot.EnumLogString(e, int64(e), "E_IETFNetconfAcm_ActionType")
}

const (
	// IETFNetconfAcm_ActionType_UNSET corresponds to the value UNSET of IETFNetconfAcm_ActionType
	IETFNetconfAcm_ActionType_UNSET E_IETFNetconfAcm_ActionType = 0
	// IETFNetconfAcm_ActionType_permit corresponds to the value permit of IETFNetconfAcm_ActionType
	IETFNetconfAcm_ActionType_permit E_IETFNetconfAcm_ActionType = 1
	// IETFNetconfAcm_ActionType_deny corresponds to the value deny of IETFNetconfAcm_ActionType
	IETFNetconfAcm_ActionType_deny E_IETFNetconfAcm_ActionType = 2
)


// E_IETFSnmp_SecurityLevel is a derived int64 type which is used to represent
// the enumerated node IETFSnmp_SecurityLevel. An additional value named
// IETFSnmp_SecurityLevel_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_IETFSnmp_SecurityLevel int64

// IsYANGGoEnum ensures that IETFSnmp_SecurityLevel implements the yang.GoEnum
// interface. This ensures that IETFSnmp_SecurityLevel can be identified as a
// mapped type for a YANG enumeration.
func (E_IETFSnmp_SecurityLevel) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  IETFSnmp_SecurityLevel.
func (E_IETFSnmp_SecurityLevel) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_IETFSnmp_SecurityLevel.
func (e E_IETFSnmp_SecurityLevel) String() string {
	return ygot.EnumLogString(e, int64(e), "E_IETFSnmp_SecurityLevel")
}

const (
	// IETFSnmp_SecurityLevel_UNSET corresponds to the value UNSET of IETFSnmp_SecurityLevel
	IETFSnmp_SecurityLevel_UNSET E_IETFSnmp_SecurityLevel = 0
	// IETFSnmp_SecurityLevel_no_auth_no_priv corresponds to the value no_auth_no_priv of IETFSnmp_SecurityLevel
	IETFSnmp_SecurityLevel_no_auth_no_priv E_IETFSnmp_SecurityLevel = 2
	// IETFSnmp_SecurityLevel_auth_no_priv corresponds to the value auth_no_priv of IETFSnmp_SecurityLevel
	IETFSnmp_SecurityLevel_auth_no_priv E_IETFSnmp_SecurityLevel = 3
	// IETFSnmp_SecurityLevel_auth_priv corresponds to the value auth_priv of IETFSnmp_SecurityLevel
	IETFSnmp_SecurityLevel_auth_priv E_IETFSnmp_SecurityLevel = 4
)


// E_IETFSnmp_SecurityModelOrAny_Enum is a derived int64 type which is used to represent
// the enumerated node IETFSnmp_SecurityModelOrAny_Enum. An additional value named
// IETFSnmp_SecurityModelOrAny_Enum_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_IETFSnmp_SecurityModelOrAny_Enum int64

// IsYANGGoEnum ensures that IETFSnmp_SecurityModelOrAny_Enum implements the yang.GoEnum
// interface. This ensures that IETFSnmp_SecurityModelOrAny_Enum can be identified as a
// mapped type for a YANG enumeration.
func (E_IETFSnmp_SecurityModelOrAny_Enum) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  IETFSnmp_SecurityModelOrAny_Enum.
func (E_IETFSnmp_SecurityModelOrAny_Enum) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_IETFSnmp_SecurityModelOrAny_Enum.
func (e E_IETFSnmp_SecurityModelOrAny_Enum) String() string {
	return ygot.EnumLogString(e, int64(e), "E_IETFSnmp_SecurityModelOrAny_Enum")
}

const (
	// IETFSnmp_SecurityModelOrAny_Enum_UNSET corresponds to the value UNSET of IETFSnmp_SecurityModelOrAny_Enum
	IETFSnmp_SecurityModelOrAny_Enum_UNSET E_IETFSnmp_SecurityModelOrAny_Enum = 0
	// IETFSnmp_SecurityModelOrAny_Enum_any corresponds to the value any of IETFSnmp_SecurityModelOrAny_Enum
	IETFSnmp_SecurityModelOrAny_Enum_any E_IETFSnmp_SecurityModelOrAny_Enum = 1
)


// E_IETFSnmp_SecurityModel_Enum is a derived int64 type which is used to represent
// the enumerated node IETFSnmp_SecurityModel_Enum. An additional value named
// IETFSnmp_SecurityModel_Enum_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_IETFSnmp_SecurityModel_Enum int64

// IsYANGGoEnum ensures that IETFSnmp_SecurityModel_Enum implements the yang.GoEnum
// interface. This ensures that IETFSnmp_SecurityModel_Enum can be identified as a
// mapped type for a YANG enumeration.
func (E_IETFSnmp_SecurityModel_Enum) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  IETFSnmp_SecurityModel_Enum.
func (E_IETFSnmp_SecurityModel_Enum) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_IETFSnmp_SecurityModel_Enum.
func (e E_IETFSnmp_SecurityModel_Enum) String() string {
	return ygot.EnumLogString(e, int64(e), "E_IETFSnmp_SecurityModel_Enum")
}

const (
	// IETFSnmp_SecurityModel_Enum_UNSET corresponds to the value UNSET of IETFSnmp_SecurityModel_Enum
	IETFSnmp_SecurityModel_Enum_UNSET E_IETFSnmp_SecurityModel_Enum = 0
	// IETFSnmp_SecurityModel_Enum_v1 corresponds to the value v1 of IETFSnmp_SecurityModel_Enum
	IETFSnmp_SecurityModel_Enum_v1 E_IETFSnmp_SecurityModel_Enum = 2
	// IETFSnmp_SecurityModel_Enum_v2c corresponds to the value v2c of IETFSnmp_SecurityModel_Enum
	IETFSnmp_SecurityModel_Enum_v2c E_IETFSnmp_SecurityModel_Enum = 3
	// IETFSnmp_SecurityModel_Enum_usm corresponds to the value usm of IETFSnmp_SecurityModel_Enum
	IETFSnmp_SecurityModel_Enum_usm E_IETFSnmp_SecurityModel_Enum = 4
	// IETFSnmp_SecurityModel_Enum_tsm corresponds to the value tsm of IETFSnmp_SecurityModel_Enum
	IETFSnmp_SecurityModel_Enum_tsm E_IETFSnmp_SecurityModel_Enum = 5
)


// E_IETFSnmp_Snmp_Notify_Type is a derived int64 type which is used to represent
// the enumerated node IETFSnmp_Snmp_Notify_Type. An additional value named
// IETFSnmp_Snmp_Notify_Type_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_IETFSnmp_Snmp_Notify_Type int64

// IsYANGGoEnum ensures that IETFSnmp_Snmp_Notify_Type implements the yang.GoEnum
// interface. This ensures that IETFSnmp_Snmp_Notify_Type can be identified as a
// mapped type for a YANG enumeration.
func (E_IETFSnmp_Snmp_Notify_Type) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  IETFSnmp_Snmp_Notify_Type.
func (E_IETFSnmp_Snmp_Notify_Type) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_IETFSnmp_Snmp_Notify_Type.
func (e E_IETFSnmp_Snmp_Notify_Type) String() string {
	return ygot.EnumLogString(e, int64(e), "E_IETFSnmp_Snmp_Notify_Type")
}

const (
	// IETFSnmp_Snmp_Notify_Type_UNSET corresponds to the value UNSET of IETFSnmp_Snmp_Notify_Type
	IETFSnmp_Snmp_Notify_Type_UNSET E_IETFSnmp_Snmp_Notify_Type = 0
	// IETFSnmp_Snmp_Notify_Type_trap corresponds to the value trap of IETFSnmp_Snmp_Notify_Type
	IETFSnmp_Snmp_Notify_Type_trap E_IETFSnmp_Snmp_Notify_Type = 2
	// IETFSnmp_Snmp_Notify_Type_inform corresponds to the value inform of IETFSnmp_Snmp_Notify_Type
	IETFSnmp_Snmp_Notify_Type_inform E_IETFSnmp_Snmp_Notify_Type = 3
)


// E_IETFSnmp_Snmp_Proxy_Type is a derived int64 type which is used to represent
// the enumerated node IETFSnmp_Snmp_Proxy_Type. An additional value named
// IETFSnmp_Snmp_Proxy_Type_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_IETFSnmp_Snmp_Proxy_Type int64

// IsYANGGoEnum ensures that IETFSnmp_Snmp_Proxy_Type implements the yang.GoEnum
// interface. This ensures that IETFSnmp_Snmp_Proxy_Type can be identified as a
// mapped type for a YANG enumeration.
func (E_IETFSnmp_Snmp_Proxy_Type) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  IETFSnmp_Snmp_Proxy_Type.
func (E_IETFSnmp_Snmp_Proxy_Type) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_IETFSnmp_Snmp_Proxy_Type.
func (e E_IETFSnmp_Snmp_Proxy_Type) String() string {
	return ygot.EnumLogString(e, int64(e), "E_IETFSnmp_Snmp_Proxy_Type")
}

const (
	// IETFSnmp_Snmp_Proxy_Type_UNSET corresponds to the value UNSET of IETFSnmp_Snmp_Proxy_Type
	IETFSnmp_Snmp_Proxy_Type_UNSET E_IETFSnmp_Snmp_Proxy_Type = 0
	// IETFSnmp_Snmp_Proxy_Type_read corresponds to the value read of IETFSnmp_Snmp_Proxy_Type
	IETFSnmp_Snmp_Proxy_Type_read E_IETFSnmp_Snmp_Proxy_Type = 2
	// IETFSnmp_Snmp_Proxy_Type_write corresponds to the value write of IETFSnmp_Snmp_Proxy_Type
	IETFSnmp_Snmp_Proxy_Type_write E_IETFSnmp_Snmp_Proxy_Type = 3
	// IETFSnmp_Snmp_Proxy_Type_trap corresponds to the value trap of IETFSnmp_Snmp_Proxy_Type
	IETFSnmp_Snmp_Proxy_Type_trap E_IETFSnmp_Snmp_Proxy_Type = 4
	// IETFSnmp_Snmp_Proxy_Type_inform corresponds to the value inform of IETFSnmp_Snmp_Proxy_Type
	IETFSnmp_Snmp_Proxy_Type_inform E_IETFSnmp_Snmp_Proxy_Type = 5
)


// E_IETFSnmp_Snmp_Target_Mms_Enum is a derived int64 type which is used to represent
// the enumerated node IETFSnmp_Snmp_Target_Mms_Enum. An additional value named
// IETFSnmp_Snmp_Target_Mms_Enum_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_IETFSnmp_Snmp_Target_Mms_Enum int64

// IsYANGGoEnum ensures that IETFSnmp_Snmp_Target_Mms_Enum implements the yang.GoEnum
// interface. This ensures that IETFSnmp_Snmp_Target_Mms_Enum can be identified as a
// mapped type for a YANG enumeration.
func (E_IETFSnmp_Snmp_Target_Mms_Enum) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  IETFSnmp_Snmp_Target_Mms_Enum.
func (E_IETFSnmp_Snmp_Target_Mms_Enum) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_IETFSnmp_Snmp_Target_Mms_Enum.
func (e E_IETFSnmp_Snmp_Target_Mms_Enum) String() string {
	return ygot.EnumLogString(e, int64(e), "E_IETFSnmp_Snmp_Target_Mms_Enum")
}

const (
	// IETFSnmp_Snmp_Target_Mms_Enum_UNSET corresponds to the value UNSET of IETFSnmp_Snmp_Target_Mms_Enum
	IETFSnmp_Snmp_Target_Mms_Enum_UNSET E_IETFSnmp_Snmp_Target_Mms_Enum = 0
	// IETFSnmp_Snmp_Target_Mms_Enum_unknown corresponds to the value unknown of IETFSnmp_Snmp_Target_Mms_Enum
	IETFSnmp_Snmp_Target_Mms_Enum_unknown E_IETFSnmp_Snmp_Target_Mms_Enum = 1
)


// E_IETFSnmp_Snmp_Vacm_Group_Access_ContextMatch is a derived int64 type which is used to represent
// the enumerated node IETFSnmp_Snmp_Vacm_Group_Access_ContextMatch. An additional value named
// IETFSnmp_Snmp_Vacm_Group_Access_ContextMatch_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_IETFSnmp_Snmp_Vacm_Group_Access_ContextMatch int64

// IsYANGGoEnum ensures that IETFSnmp_Snmp_Vacm_Group_Access_ContextMatch implements the yang.GoEnum
// interface. This ensures that IETFSnmp_Snmp_Vacm_Group_Access_ContextMatch can be identified as a
// mapped type for a YANG enumeration.
func (E_IETFSnmp_Snmp_Vacm_Group_Access_ContextMatch) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  IETFSnmp_Snmp_Vacm_Group_Access_ContextMatch.
func (E_IETFSnmp_Snmp_Vacm_Group_Access_ContextMatch) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_IETFSnmp_Snmp_Vacm_Group_Access_ContextMatch.
func (e E_IETFSnmp_Snmp_Vacm_Group_Access_ContextMatch) String() string {
	return ygot.EnumLogString(e, int64(e), "E_IETFSnmp_Snmp_Vacm_Group_Access_ContextMatch")
}

const (
	// IETFSnmp_Snmp_Vacm_Group_Access_ContextMatch_UNSET corresponds to the value UNSET of IETFSnmp_Snmp_Vacm_Group_Access_ContextMatch
	IETFSnmp_Snmp_Vacm_Group_Access_ContextMatch_UNSET E_IETFSnmp_Snmp_Vacm_Group_Access_ContextMatch = 0
	// IETFSnmp_Snmp_Vacm_Group_Access_ContextMatch_exact corresponds to the value exact of IETFSnmp_Snmp_Vacm_Group_Access_ContextMatch
	IETFSnmp_Snmp_Vacm_Group_Access_ContextMatch_exact E_IETFSnmp_Snmp_Vacm_Group_Access_ContextMatch = 2
	// IETFSnmp_Snmp_Vacm_Group_Access_ContextMatch_prefix corresponds to the value prefix of IETFSnmp_Snmp_Vacm_Group_Access_ContextMatch
	IETFSnmp_Snmp_Vacm_Group_Access_ContextMatch_prefix E_IETFSnmp_Snmp_Vacm_Group_Access_ContextMatch = 3
)


// E_IETFSystem_AuthenticationMethod is a derived int64 type which is used to represent
// the enumerated node IETFSystem_AuthenticationMethod. An additional value named
// IETFSystem_AuthenticationMethod_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_IETFSystem_AuthenticationMethod int64

// IsYANGGoEnum ensures that IETFSystem_AuthenticationMethod implements the yang.GoEnum
// interface. This ensures that IETFSystem_AuthenticationMethod can be identified as a
// mapped type for a YANG enumeration.
func (E_IETFSystem_AuthenticationMethod) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  IETFSystem_AuthenticationMethod.
func (E_IETFSystem_AuthenticationMethod) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_IETFSystem_AuthenticationMethod.
func (e E_IETFSystem_AuthenticationMethod) String() string {
	return ygot.EnumLogString(e, int64(e), "E_IETFSystem_AuthenticationMethod")
}

const (
	// IETFSystem_AuthenticationMethod_UNSET corresponds to the value UNSET of IETFSystem_AuthenticationMethod
	IETFSystem_AuthenticationMethod_UNSET E_IETFSystem_AuthenticationMethod = 0
	// IETFSystem_AuthenticationMethod_local_users corresponds to the value local_users of IETFSystem_AuthenticationMethod
	IETFSystem_AuthenticationMethod_local_users E_IETFSystem_AuthenticationMethod = 1
	// IETFSystem_AuthenticationMethod_radius corresponds to the value radius of IETFSystem_AuthenticationMethod
	IETFSystem_AuthenticationMethod_radius E_IETFSystem_AuthenticationMethod = 2
)


// E_IETFSystem_RadiusAuthenticationType is a derived int64 type which is used to represent
// the enumerated node IETFSystem_RadiusAuthenticationType. An additional value named
// IETFSystem_RadiusAuthenticationType_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_IETFSystem_RadiusAuthenticationType int64

// IsYANGGoEnum ensures that IETFSystem_RadiusAuthenticationType implements the yang.GoEnum
// interface. This ensures that IETFSystem_RadiusAuthenticationType can be identified as a
// mapped type for a YANG enumeration.
func (E_IETFSystem_RadiusAuthenticationType) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  IETFSystem_RadiusAuthenticationType.
func (E_IETFSystem_RadiusAuthenticationType) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_IETFSystem_RadiusAuthenticationType.
func (e E_IETFSystem_RadiusAuthenticationType) String() string {
	return ygot.EnumLogString(e, int64(e), "E_IETFSystem_RadiusAuthenticationType")
}

const (
	// IETFSystem_RadiusAuthenticationType_UNSET corresponds to the value UNSET of IETFSystem_RadiusAuthenticationType
	IETFSystem_RadiusAuthenticationType_UNSET E_IETFSystem_RadiusAuthenticationType = 0
	// IETFSystem_RadiusAuthenticationType_radius_chap corresponds to the value radius_chap of IETFSystem_RadiusAuthenticationType
	IETFSystem_RadiusAuthenticationType_radius_chap E_IETFSystem_RadiusAuthenticationType = 1
	// IETFSystem_RadiusAuthenticationType_radius_pap corresponds to the value radius_pap of IETFSystem_RadiusAuthenticationType
	IETFSystem_RadiusAuthenticationType_radius_pap E_IETFSystem_RadiusAuthenticationType = 2
)


// E_IETFSystem_System_Ntp_Server_AssociationType is a derived int64 type which is used to represent
// the enumerated node IETFSystem_System_Ntp_Server_AssociationType. An additional value named
// IETFSystem_System_Ntp_Server_AssociationType_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_IETFSystem_System_Ntp_Server_AssociationType int64

// IsYANGGoEnum ensures that IETFSystem_System_Ntp_Server_AssociationType implements the yang.GoEnum
// interface. This ensures that IETFSystem_System_Ntp_Server_AssociationType can be identified as a
// mapped type for a YANG enumeration.
func (E_IETFSystem_System_Ntp_Server_AssociationType) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  IETFSystem_System_Ntp_Server_AssociationType.
func (E_IETFSystem_System_Ntp_Server_AssociationType) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_IETFSystem_System_Ntp_Server_AssociationType.
func (e E_IETFSystem_System_Ntp_Server_AssociationType) String() string {
	return ygot.EnumLogString(e, int64(e), "E_IETFSystem_System_Ntp_Server_AssociationType")
}

const (
	// IETFSystem_System_Ntp_Server_AssociationType_UNSET corresponds to the value UNSET of IETFSystem_System_Ntp_Server_AssociationType
	IETFSystem_System_Ntp_Server_AssociationType_UNSET E_IETFSystem_System_Ntp_Server_AssociationType = 0
	// IETFSystem_System_Ntp_Server_AssociationType_server corresponds to the value server of IETFSystem_System_Ntp_Server_AssociationType
	IETFSystem_System_Ntp_Server_AssociationType_server E_IETFSystem_System_Ntp_Server_AssociationType = 1
	// IETFSystem_System_Ntp_Server_AssociationType_peer corresponds to the value peer of IETFSystem_System_Ntp_Server_AssociationType
	IETFSystem_System_Ntp_Server_AssociationType_peer E_IETFSystem_System_Ntp_Server_AssociationType = 2
	// IETFSystem_System_Ntp_Server_AssociationType_pool corresponds to the value pool of IETFSystem_System_Ntp_Server_AssociationType
	IETFSystem_System_Ntp_Server_AssociationType_pool E_IETFSystem_System_Ntp_Server_AssociationType = 3
)


// E_IETFX509CertToName_CertToName is a derived int64 type which is used to represent
// the enumerated node IETFX509CertToName_CertToName. An additional value named
// IETFX509CertToName_CertToName_UNSET is added to the enumeration which is used as
// the nil value, indicating that the enumeration was not explicitly set by
// the program importing the generated structures.
type E_IETFX509CertToName_CertToName int64

// IsYANGGoEnum ensures that IETFX509CertToName_CertToName implements the yang.GoEnum
// interface. This ensures that IETFX509CertToName_CertToName can be identified as a
// mapped type for a YANG enumeration.
func (E_IETFX509CertToName_CertToName) IsYANGGoEnum() {}

// ΛMap returns the value lookup map associated with  IETFX509CertToName_CertToName.
func (E_IETFX509CertToName_CertToName) ΛMap() map[string]map[int64]ygot.EnumDefinition { return ΛEnum; }

// String returns a logging-friendly string for E_IETFX509CertToName_CertToName.
func (e E_IETFX509CertToName_CertToName) String() string {
	return ygot.EnumLogString(e, int64(e), "E_IETFX509CertToName_CertToName")
}

const (
	// IETFX509CertToName_CertToName_UNSET corresponds to the value UNSET of IETFX509CertToName_CertToName
	IETFX509CertToName_CertToName_UNSET E_IETFX509CertToName_CertToName = 0
	// IETFX509CertToName_CertToName_common_name corresponds to the value common_name of IETFX509CertToName_CertToName
	IETFX509CertToName_CertToName_common_name E_IETFX509CertToName_CertToName = 1
	// IETFX509CertToName_CertToName_san_any corresponds to the value san_any of IETFX509CertToName_CertToName
	IETFX509CertToName_CertToName_san_any E_IETFX509CertToName_CertToName = 2
	// IETFX509CertToName_CertToName_san_dns_name corresponds to the value san_dns_name of IETFX509CertToName_CertToName
	IETFX509CertToName_CertToName_san_dns_name E_IETFX509CertToName_CertToName = 3
	// IETFX509CertToName_CertToName_san_ip_address corresponds to the value san_ip_address of IETFX509CertToName_CertToName
	IETFX509CertToName_CertToName_san_ip_address E_IETFX509CertToName_CertToName = 4
	// IETFX509CertToName_CertToName_san_rfc822_name corresponds to the value san_rfc822_name of IETFX509CertToName_CertToName
	IETFX509CertToName_CertToName_san_rfc822_name E_IETFX509CertToName_CertToName = 5
	// IETFX509CertToName_CertToName_specified corresponds to the value specified of IETFX509CertToName_CertToName
	IETFX509CertToName_CertToName_specified E_IETFX509CertToName_CertToName = 6
)


// ΛEnum is a map, keyed by the name of the type defined for each enum in the
// generated Go code, which provides a mapping between the constant int64 value
// of each value of the enumeration, and the string that is used to represent it
// in the YANG schema. The map is named ΛEnum in order to avoid clash with any
// valid YANG identifier.
var ΛEnum = map[string]map[int64]ygot.EnumDefinition{
	"E_IETFNetconfAcm_ActionType": {
		1: {Name: "permit"},
		2: {Name: "deny"},
	},
	"E_IETFSnmp_SecurityLevel": {
		2: {Name: "no-auth-no-priv"},
		3: {Name: "auth-no-priv"},
		4: {Name: "auth-priv"},
	},
	"E_IETFSnmp_SecurityModelOrAny_Enum": {
		1: {Name: "any"},
	},
	"E_IETFSnmp_SecurityModel_Enum": {
		2: {Name: "v1"},
		3: {Name: "v2c"},
		4: {Name: "usm"},
		5: {Name: "tsm"},
	},
	"E_IETFSnmp_Snmp_Notify_Type": {
		2: {Name: "trap"},
		3: {Name: "inform"},
	},
	"E_IETFSnmp_Snmp_Proxy_Type": {
		2: {Name: "read"},
		3: {Name: "write"},
		4: {Name: "trap"},
		5: {Name: "inform"},
	},
	"E_IETFSnmp_Snmp_Target_Mms_Enum": {
		1: {Name: "unknown"},
	},
	"E_IETFSnmp_Snmp_Vacm_Group_Access_ContextMatch": {
		2: {Name: "exact"},
		3: {Name: "prefix"},
	},
	"E_IETFSystem_AuthenticationMethod": {
		1: {Name: "local-users", DefiningModule: "ietf-system"},
		2: {Name: "radius", DefiningModule: "ietf-system"},
	},
	"E_IETFSystem_RadiusAuthenticationType": {
		1: {Name: "radius-chap", DefiningModule: "ietf-system"},
		2: {Name: "radius-pap", DefiningModule: "ietf-system"},
	},
	"E_IETFSystem_System_Ntp_Server_AssociationType": {
		1: {Name: "server"},
		2: {Name: "peer"},
		3: {Name: "pool"},
	},
	"E_IETFX509CertToName_CertToName": {
		1: {Name: "common-name", DefiningModule: "ietf-x509-cert-to-name"},
		2: {Name: "san-any", DefiningModule: "ietf-x509-cert-to-name"},
		3: {Name: "san-dns-name", DefiningModule: "ietf-x509-cert-to-name"},
		4: {Name: "san-ip-address", DefiningModule: "ietf-x509-cert-to-name"},
		5: {Name: "san-rfc822-name", DefiningModule: "ietf-x509-cert-to-name"},
		6: {Name: "specified", DefiningModule: "ietf-x509-cert-to-name"},
	},
}


var (
	// ySchema is a byte slice contain a gzip compressed representation of the
	// YANG schema from which the Go code was generated. When uncompressed the
	// contents of the byte slice is a JSON document containing an object, keyed
	// on the name of the generated struct, and containing the JSON marshalled
	// contents of a goyang yang.Entry struct, which defines the schema for the
	// fields within the struct.
	ySchema = []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0xbd, 0x7b, 0x73, 0xda, 0x48,
		0xba, 0x07, 0xfc, 0xbf, 0x3f, 0x45, 0xbf, 0xaa, 0xdd, 0x1a, 0x93, 0xb1, 0xcc, 0xc5, 0xe0, 0xd8,
		0x54, 0x9d, 0xca, 0x21, 0xb6, 0xb3, 0xe3, 0x77, 0x63, 0xc7, 0x15, 0xc8, 0xcc, 0xd9, 0x0d, 0x9c,
		0x94, 0x8c, 0x1a, 0xa3, 0x1d, 0xd1, 0xe2, 0x95, 0x1a, 0xc7, 0x9e, 0xc4, 0xe7, 0xb3, 0xbf, 0x25,
		0x09, 0x04, 0x98, 0x8b, 0xfa, 0x2a, 0x04, 0x3c, 0xfb, 0x47, 0x86, 0xc5, 0x52, 0x23, 0x3d, 0xfd,
		0x5c, 0x7e, 0xcf, 0xb5, 0x7f, 0x1c, 0x20, 0x84, 0x90, 0x71, 0x6b, 0x0d, 0xb0, 0x51, 0x47, 0x86,
		0x8d, 0x1f, 0x9d, 0x2e, 0x36, 0x8e, 0xe2, 0x6f, 0xff, 0xe9, 0x10, 0xdb, 0xa8, 0xa3, 0xf2, 0xf8,
		0xff, 0x5e, 0x78, 0xa4, 0xe7, 0x3c, 0x18, 0x75, 0x54, 0x1a, 0x7f, 0x71, 0xe9, 0xf8, 0x46, 0x1d,
		0xc5, 0x4b, 0x44, 0x5f, 0x10, 0xab, 0x3b, 0x98, 0xfb, 0x66, 0x6e, 0xf1, 0xe8, 0xaf, 0x47, 0xf3,
		0x7f, 0x9b, 0xff, 0x89, 0xe4, 0xeb, 0xd7, 0x3f, 0x95, 0xfc, 0xe1, 0xce, 0xc7, 0x3d, 0xe7, 0x69,
		0xe1, 0x37, 0xd2, 0x7e, 0x27, 0xfa, 0x7b, 0xd3, 0x1b, 0xf9, 0x5d, 0xbc, 0xf4, 0xde, 0xf8, 0x59,
		0xf0, 0xf3, 0x77, 0xcf, 0x0f, 0x1f, 0xc7, 0x18, 0xc6, 0x3f, 0x73, 0xb4, 0xfc, 0xc2, 0xdf, 0xac,
		0xa0, 0xe1, 0x3f, 0x8c, 0x06, 0x98, 0x50, 0xa3, 0x8e, 0xa8, 0x3f, 0xc2, 0x2b, 0x2e, 0x9c, 0xb9,
		0x2a, 0x7e, 0xaa, 0x85, 0xcb, 0x5e, 0xe6, 0xbe, 0x79, 0x79, 0xf5, 0xb6, 0xaf, 0x09, 0x9c, 0xfc,
		0xc1, 0xc6, 0xc4, 0xc1, 0xb6, 0x69, 0x5b, 0xd4, 0x32, 0xbf, 0xfb, 0x0e, 0xc5, 0xc1, 0xea, 0xd7,
		0x9a, 0xee, 0xed, 0xc2, 0x3d, 0x2b, 0x1e, 0x7b, 0xbc, 0x29, 0xa5, 0x15, 0x7f, 0x4e, 0x36, 0xa7,
		0xb2, 0xe2, 0x82, 0x35, 0x9b, 0xc4, 0xba, 0x59, 0xac, 0x9b, 0xc6, 0xbd, 0x79, 0xdc, 0x9b, 0xc8,
		0xb1, 0x99, 0xcb, 0x37, 0x75, 0xc5, 0xe6, 0x26, 0xeb, 0xde, 0x58, 0xc4, 0xb6, 0xa8, 0xe7, 0x3f,
		0x2f, 0xca, 0x41, 0x72, 0x4d, 0xeb, 0x79, 0x88, 0xd9, 0xe8, 0xf9, 0x17, 0xf6, 0x3d, 0xf3, 0xde,
		0x0a, 0xb0, 0x6d, 0x76, 0xbd, 0x11, 0xa1, 0xd8, 0x3f, 0xa9, 0xac, 0xa3, 0xef, 0x78, 0xaf, 0xdf,
		0xae, 0xb9, 0xe4, 0x12, 0xf7, 0xac, 0x91, 0x1b, 0xbd, 0x77, 0x69, 0xdd, 0x52, 0xbf, 0x59, 0xc1,
		0xf4, 0xd2, 0xf5, 0x04, 0x35, 0x3e, 0x5b, 0xe4, 0x21, 0x7c, 0xde, 0xaf, 0x6b, 0x69, 0xbe, 0x7e,
		0xcf, 0x63, 0xea, 0x39, 0x24, 0x95, 0x39, 0x92, 0x8b, 0x7f, 0xb7, 0xdc, 0x11, 0x5e, 0xcd, 0xd9,
		0x0b, 0xd7, 0x7f, 0xf0, 0xad, 0x2e, 0x75, 0x3c, 0x72, 0xe9, 0x3c, 0x38, 0x34, 0xe0, 0xb8, 0xf1,
		0x16, 0x3f, 0x58, 0xd4, 0x79, 0x0c, 0x7f, 0xab, 0x67, 0xb9, 0x01, 0x4e, 0xbd, 0xeb, 0xe5, 0x88,
		0xe1, 0x55, 0xad, 0x27, 0xfe, 0x57, 0xad, 0x56, 0xce, 0xab, 0xe7, 0xa7, 0x6f, 0x2b, 0xe7, 0xb5,
		0xfc, 0xbd, 0xf3, 0x81, 0xd8, 0x5f, 0x3b, 0x07, 0x6c, 0xd7, 0x2f, 0xa1, 0xe9, 0x44, 0x09, 0x12,
		0x8f, 0x3a, 0x3d, 0xa7, 0x6b, 0x85, 0x2f, 0xca, 0xae, 0x3a, 0xe7, 0xef, 0x02, 0xe5, 0x09, 0xca,
		0x13, 0x94, 0x27, 0x28, 0xcf, 0xbd, 0x53, 0x9e, 0xde, 0x10, 0xfb, 0x9c, 0x9a, 0x73, 0xe6, 0x16,
		0x50, 0x9b, 0xa0, 0x36, 0x41, 0x6d, 0x82, 0xda, 0xdc, 0x1f, 0xb5, 0x89, 0x89, 0x75, 0xef, 0x62,
		0x13, 0x3f, 0x51, 0xec, 0x13, 0xcb, 0x35, 0x1f, 0x7c, 0x6f, 0x34, 0x64, 0xd0, 0x9d, 0x2b, 0xee,
		0x5b, 0x21, 0xae, 0x53, 0x31, 0x58, 0xcd, 0xdf, 0x46, 0x28, 0x21, 0xcb, 0x75, 0x48, 0x47, 0x52,
		0x2f, 0x97, 0x40, 0x2f, 0x2b, 0xd0, 0xcb, 0xec, 0x3a, 0xf7, 0xde, 0xf3, 0x5c, 0x6c, 0x11, 0x06,
		0x35, 0x5b, 0x2e, 0xcb, 0xf3, 0xee, 0xd2, 0xc0, 0xde, 0x2a, 0x86, 0x5d, 0xb3, 0x8d, 0xc0, 0xa5,
		0xc0, 0xa5, 0x3a, 0xb8, 0xf4, 0x09, 0x77, 0x4d, 0x3b, 0x61, 0xad, 0x34, 0x36, 0x9d, 0xbd, 0x5a,
		0x86, 0x4f, 0x87, 0xd8, 0x1f, 0x38, 0x14, 0x38, 0x75, 0x17, 0x38, 0x35, 0x06, 0x20, 0x26, 0x0d,
		0x6f, 0x60, 0xe0, 0xd6, 0xea, 0x9a, 0x6b, 0xae, 0xc8, 0x68, 0x90, 0x4e, 0xd4, 0x96, 0xd7, 0xa4,
		0xbe, 0x43, 0x1e, 0x98, 0xe0, 0x95, 0x51, 0x8a, 0x88, 0x1f, 0xf3, 0x1b, 0x03, 0x6c, 0x2b, 0x8f,
		0x7d, 0xaf, 0x67, 0xe3, 0x40, 0x02, 0x01, 0x1a, 0x2d, 0xef, 0x9a, 0x50, 0xb6, 0x07, 0x8c, 0x7e,
		0x6c, 0xa5, 0x33, 0xb1, 0x4c, 0x6c, 0xea, 0xa8, 0x24, 0x08, 0xc6, 0x5e, 0x24, 0x54, 0x05, 0x2b,
		0xf8, 0x5a, 0x0f, 0xb6, 0x96, 0xa7, 0xad, 0x40, 0x8a, 0xf5, 0x48, 0xf1, 0xaa, 0x34, 0xd8, 0xfc,
		0xa6, 0xa6, 0x53, 0x60, 0x6e, 0x6f, 0xd3, 0xde, 0x7e, 0xfd, 0x16, 0x33, 0x6f, 0x35, 0xcf, 0x96,
		0xf3, 0x6e, 0x3d, 0x2f, 0x0b, 0x08, 0xb3, 0x82, 0x30, 0x4b, 0x08, 0xb0, 0x06, 0xa3, 0xa7, 0x96,
		0x42, 0xed, 0x34, 0x96, 0x49, 0x2e, 0x24, 0x31, 0xa9, 0x19, 0x09, 0x37, 0xdd, 0x98, 0x01, 0x66,
		0xa5, 0xd9, 0x7a, 0x8b, 0x2f, 0xcc, 0x50, 0x22, 0x8c, 0x25, 0xca, 0x60, 0xa2, 0x8c, 0x26, 0xcd,
		0x70, 0xd2, 0x8c, 0x27, 0xc1, 0x80, 0x6c, 0x8c, 0xc8, 0x11, 0x4c, 0x61, 0x43, 0x24, 0xeb, 0xb5,
		0x96, 0x19, 0x72, 0x5e, 0x1a, 0x4a, 0x59, 0xa9, 0xcb, 0xce, 0x38, 0xee, 0xf9, 0x88, 0xc9, 0x03,
		0xed, 0xa7, 0x86, 0xcb, 0xf8, 0xc3, 0x67, 0x52, 0xe1, 0xb4, 0x95, 0x31, 0xa7, 0xf2, 0x91, 0xd8,
		0xfd, 0xa2, 0xa1, 0x27, 0xf9, 0x50, 0x94, 0x20, 0x07, 0x09, 0x87, 0xe7, 0x56, 0x93, 0xee, 0xac,
		0x5a, 0x3d, 0x7d, 0x5b, 0xad, 0x96, 0xde, 0x9e, 0xbc, 0x2d, 0x9d, 0xd7, 0x6a, 0xe5, 0xd3, 0x72,
		0x6d, 0xfb, 0xa9, 0x79, 0xa0, 0xe7, 0xea, 0x0e, 0x87, 0x08, 0xdd, 0x59, 0x94, 0x62, 0x9f, 0x70,
		0xcb, 0x90, 0xf1, 0xf5, 0x7f, 0xdb, 0xed, 0x37, 0x9d, 0xe3, 0x37, 0xec, 0x4a, 0xaa, 0x73, 0xa0,
		0xe6, 0x35, 0x59, 0x62, 0xc2, 0xa3, 0x00, 0xfb, 0xa6, 0x98, 0xdd, 0x9c, 0xde, 0x0a, 0xc6, 0x13,
		0x8c, 0x67, 0x86, 0xc6, 0x33, 0x61, 0x3c, 0xb0, 0x9d, 0x60, 0x3b, 0xc1, 0x76, 0x6e, 0xc8, 0x76,
		0x2a, 0x55, 0x06, 0x1f, 0x9d, 0x80, 0x36, 0x28, 0xf5, 0xf9, 0x14, 0xc2, 0x8d, 0x43, 0xae, 0x5c,
		0x1c, 0x2a, 0x33, 0x4e, 0x12, 0x87, 0xfc, 0x32, 0x73, 0xa7, 0xdc, 0xc6, 0x1b, 0x9f, 0x7c, 0x1b,
		0xfb, 0xd8, 0x7e, 0xff, 0x6c, 0xd4, 0x11, 0x19, 0xb9, 0xae, 0xc8, 0xad, 0x5f, 0x02, 0xec, 0x73,
		0xed, 0xf1, 0x8b, 0x66, 0xa7, 0xfb, 0x9f, 0xf8, 0x99, 0xd1, 0x39, 0xe6, 0xdb, 0x3c, 0xfe, 0x4d,
		0x53, 0xb2, 0x59, 0x02, 0x9b, 0x24, 0xb0, 0x39, 0x69, 0x44, 0x6d, 0x10, 0xe2, 0xd1, 0xa8, 0x76,
		0x86, 0x8d, 0x56, 0x41, 0xb7, 0x8f, 0x07, 0xd6, 0xd0, 0x8a, 0xec, 0x8f, 0x51, 0x74, 0x30, 0xed,
		0x99, 0x04, 0xd3, 0xae, 0x47, 0x7a, 0xa6, 0xd5, 0x1d, 0x14, 0x43, 0xfb, 0x5d, 0x8c, 0xa3, 0x9b,
		0x45, 0x96, 0x40, 0x58, 0xbc, 0x28, 0xf5, 0x47, 0x5d, 0x3a, 0xc6, 0x7c, 0xc6, 0xf5, 0x55, 0xeb,
		0xc3, 0x6d, 0xbc, 0x64, 0xa3, 0x3b, 0xf8, 0x76, 0x6b, 0x75, 0x07, 0xdf, 0xfe, 0x11, 0xad, 0x18,
		0xff, 0xc7, 0x50, 0x1b, 0xd7, 0x5d, 0x55, 0x5c, 0xcf, 0x46, 0x18, 0x1e, 0x82, 0xac, 0x0b, 0xb3,
		0xb2, 0x92, 0xc0, 0x90, 0x08, 0x4e, 0xfb, 0xd8, 0xb2, 0xd9, 0xf3, 0x58, 0x73, 0x57, 0x43, 0x1e,
		0x0b, 0xf2, 0x58, 0x90, 0xc7, 0x5a, 0xf9, 0x8c, 0x3b, 0x97, 0xc7, 0xf2, 0x47, 0x2e, 0x36, 0x5d,
		0x27, 0x60, 0xd1, 0x13, 0xc9, 0xa5, 0x90, 0xcd, 0xda, 0xf3, 0x6c, 0x56, 0x09, 0xb2, 0x59, 0x0a,
		0xe2, 0x22, 0x99, 0x67, 0xb3, 0x98, 0xe3, 0x1e, 0xd3, 0x78, 0x07, 0x09, 0x71, 0x11, 0x03, 0xb1,
		0x27, 0xb2, 0x7f, 0xce, 0x70, 0xed, 0xf8, 0x31, 0xd8, 0x82, 0x1a, 0x02, 0x41, 0x9a, 0x81, 0x45,
		0xbb, 0x7d, 0xcb, 0x75, 0xcd, 0x20, 0xb2, 0x28, 0x99, 0x84, 0x6a, 0x84, 0x63, 0xb4, 0xed, 0xb6,
		0xfa, 0xf0, 0xec, 0x91, 0x2e, 0xca, 0x42, 0xee, 0x08, 0xe2, 0x5f, 0x10, 0xff, 0xda, 0x78, 0xfc,
		0x6b, 0xb7, 0x73, 0x47, 0x1d, 0x29, 0x1b, 0x07, 0x11, 0x21, 0x06, 0x87, 0x61, 0x0d, 0x70, 0x66,
		0x4a, 0xc8, 0xf1, 0x14, 0xb0, 0x00, 0x66, 0xdc, 0x33, 0xcc, 0x18, 0xa3, 0x2e, 0x1e, 0xd0, 0xc8,
		0x80, 0x09, 0x78, 0xb1, 0x00, 0x5f, 0x28, 0x9f, 0x3f, 0x99, 0x2a, 0x68, 0xf3, 0xa5, 0xad, 0x93,
		0xb8, 0x55, 0x7a, 0xe1, 0xcb, 0x51, 0x48, 0x90, 0x44, 0xda, 0x96, 0x6f, 0x92, 0x4a, 0xd9, 0x18,
		0x31, 0x21, 0xd5, 0xec, 0x8f, 0x5c, 0x0e, 0xd5, 0x1c, 0x5d, 0x0d, 0xc5, 0xa9, 0x50, 0x9c, 0x8a,
		0x0c, 0xab, 0xdb, 0xc5, 0x41, 0xc0, 0xd2, 0x70, 0xbd, 0x26, 0x1e, 0xfc, 0x7a, 0x09, 0x46, 0xa2,
		0xb0, 0x64, 0x0e, 0x16, 0x6e, 0x62, 0x44, 0x9d, 0x1d, 0xa8, 0xfe, 0x61, 0xf7, 0xbf, 0xa1, 0xfa,
		0x87, 0x17, 0xd1, 0x08, 0x47, 0xc3, 0x44, 0xa2, 0x62, 0x62, 0xd1, 0x31, 0x89, 0x90, 0x87, 0xa2,
		0x68, 0x99, 0x4c, 0x80, 0x47, 0xda, 0x4b, 0x15, 0x8b, 0xa2, 0xf1, 0x39, 0xac, 0x82, 0xb1, 0x11,
		0x89, 0x1d, 0x59, 0xd0, 0xb5, 0xd2, 0x7b, 0x22, 0x10, 0x02, 0x31, 0xde, 0x3b, 0x54, 0x3c, 0xae,
		0xc3, 0x95, 0xcd, 0x5b, 0xb9, 0x4a, 0x94, 0xe5, 0xeb, 0xfa, 0xd8, 0xa2, 0x22, 0x6f, 0x9f, 0x2c,
		0x53, 0x9e, 0x64, 0xb9, 0x65, 0x16, 0xa9, 0x44, 0x0a, 0x60, 0x68, 0x4b, 0x3e, 0xcb, 0x49, 0x9c,
		0x89, 0x74, 0xb1, 0xdc, 0x32, 0xd5, 0x49, 0x03, 0xaa, 0x21, 0xb4, 0xc6, 0xcb, 0x91, 0xe8, 0xb6,
		0xb2, 0x26, 0x40, 0x57, 0x2e, 0x31, 0xde, 0x4e, 0xe1, 0xb0, 0x1c, 0x8a, 0xb3, 0xab, 0x11, 0x01,
		0xeb, 0xe8, 0x44, 0x62, 0x91, 0x88, 0x7c, 0x75, 0x54, 0x95, 0x58, 0x22, 0x62, 0x2a, 0xe1, 0xc0,
		0x6f, 0xb4, 0xc4, 0x98, 0xa5, 0xea, 0xa8, 0x22, 0xb6, 0x93, 0xdb, 0x56, 0x95, 0xa7, 0xa4, 0x74,
		0x3c, 0xf6, 0x0e, 0x45, 0x50, 0x2c, 0x65, 0xb7, 0xe0, 0x00, 0x1b, 0x01, 0x36, 0xce, 0xc5, 0x44,
		0x52, 0x67, 0x1d, 0x29, 0x84, 0x9a, 0x6c, 0xf5, 0x37, 0x2b, 0x0d, 0x3e, 0x87, 0x52, 0x63, 0xab,
		0xcf, 0x51, 0x6b, 0xe1, 0x39, 0xeb, 0x77, 0x96, 0x5b, 0xf4, 0xf4, 0x7a, 0x1e, 0x49, 0xb3, 0x27,
		0x61, 0xee, 0x38, 0xea, 0x7f, 0x16, 0x6e, 0x65, 0xac, 0x07, 0x12, 0xd7, 0xd4, 0x2f, 0x19, 0x6a,
		0xea, 0xae, 0x37, 0x18, 0x0b, 0x2f, 0xa7, 0xaa, 0x9e, 0xdc, 0x08, 0xba, 0x1a, 0x74, 0x75, 0x86,
		0x2e, 0x3e, 0x73, 0xf2, 0x62, 0xd1, 0xef, 0xcd, 0x50, 0xaa, 0x06, 0x9e, 0x3d, 0x8a, 0x26, 0x24,
		0x89, 0x34, 0xcf, 0xcd, 0xde, 0x0c, 0x41, 0x3c, 0x90, 0x70, 0x08, 0xe2, 0x41, 0x10, 0x0f, 0x82,
		0x78, 0xaa, 0x77, 0x84, 0xdb, 0x90, 0x08, 0x1a, 0x94, 0x7c, 0x3b, 0xea, 0x30, 0x16, 0x05, 0xcc,
		0xc2, 0xce, 0x03, 0x3f, 0xa8, 0x68, 0x7d, 0x7d, 0x3f, 0x54, 0xb4, 0x42, 0x45, 0x6b, 0x5e, 0x4d,
		0x52, 0xd4, 0xc6, 0x44, 0x79, 0xf4, 0xc4, 0x7c, 0x07, 0x14, 0x07, 0xb4, 0x9a, 0xa8, 0x88, 0x1a,
		0x18, 0x27, 0x30, 0x4e, 0xec, 0xf5, 0x3a, 0xd3, 0x20, 0xa2, 0x45, 0x2d, 0x93, 0x78, 0xb6, 0x00,
		0xd5, 0x93, 0x83, 0x13, 0x92, 0x25, 0x38, 0x89, 0x36, 0x66, 0x5d, 0xce, 0xec, 0x18, 0x37, 0x0b,
		0xcb, 0xb0, 0xb2, 0x2c, 0x4b, 0xcb, 0xb2, 0xb6, 0x32, 0x16, 0x57, 0xc6, 0xea, 0x0a, 0x58, 0x5e,
		0x50, 0xd5, 0x73, 0xee, 0x36, 0xaf, 0x28, 0x24, 0x37, 0x8e, 0xfb, 0xef, 0x05, 0x37, 0x6a, 0xc2,
		0x28, 0xd1, 0x2a, 0x82, 0xa4, 0xe5, 0x73, 0x38, 0x94, 0x09, 0x88, 0x0a, 0x41, 0x51, 0x25, 0x30,
		0xaa, 0x04, 0x47, 0xb9, 0x00, 0x29, 0x17, 0x24, 0x85, 0x02, 0x25, 0x26, 0x58, 0x12, 0x38, 0x16,
		0x09, 0x66, 0x2d, 0xe5, 0x9d, 0xaa, 0xd5, 0xfc, 0xe6, 0xd9, 0xd8, 0x74, 0x48, 0x40, 0x2d, 0xd2,
		0xc5, 0xa6, 0x63, 0x63, 0x42, 0x9d, 0x9e, 0x83, 0x7d, 0x19, 0x1e, 0x14, 0x0b, 0x97, 0x88, 0xef,
		0x86, 0x5e, 0xc5, 0xc8, 0x39, 0xa6, 0x65, 0xe1, 0x7e, 0xa6, 0x29, 0x25, 0x49, 0x27, 0x7f, 0xf4,
		0xa9, 0x98, 0xc0, 0xda, 0xe2, 0x14, 0x2d, 0xe8, 0x4a, 0x3d, 0x72, 0x00, 0xce, 0xd9, 0x63, 0xf2,
		0xc4, 0x01, 0xd0, 0xdc, 0x2a, 0x80, 0x81, 0x00, 0x03, 0x6d, 0x3f, 0x06, 0x9a, 0x65, 0x69, 0xbe,
		0x1c, 0x20, 0x93, 0x94, 0xf0, 0x64, 0x06, 0x01, 0x1d, 0x01, 0x3a, 0xda, 0x62, 0x74, 0xa4, 0x0e,
		0xd9, 0xf0, 0x66, 0x15, 0x57, 0xc2, 0x98, 0x73, 0x89, 0x35, 0x84, 0xb2, 0x8e, 0xaf, 0xff, 0x27,
		0xc7, 0xac, 0x48, 0x43, 0x56, 0x72, 0x35, 0xe4, 0x53, 0xb0, 0x96, 0x6c, 0xd6, 0x72, 0x61, 0x41,
		0xa1, 0x2c, 0xa6, 0x58, 0x40, 0x54, 0xb1, 0x38, 0x68, 0xe0, 0x00, 0xe1, 0x2c, 0xa8, 0x62, 0x98,
		0x2f, 0xa7, 0x5e, 0xc4, 0x77, 0x04, 0xdc, 0x8b, 0x59, 0xf7, 0x62, 0x0e, 0x8b, 0xe7, 0xc0, 0xc3,
		0x18, 0xfa, 0x1e, 0xf5, 0xba, 0x9e, 0x3b, 0x6d, 0xb5, 0x11, 0xf7, 0x33, 0x96, 0xac, 0x05, 0xde,
		0x06, 0x78, 0x1b, 0xdb, 0xef, 0x6d, 0xf8, 0xc3, 0xae, 0x22, 0x27, 0x23, 0x59, 0x09, 0x7c, 0x0b,
		0xf0, 0x2d, 0xc0, 0xb7, 0x00, 0xdf, 0x02, 0x7c, 0x0b, 0xf0, 0x2d, 0xc0, 0xb7, 0x00, 0xdf, 0x42,
		0x85, 0x6f, 0xb1, 0x04, 0x7f, 0x6f, 0xb6, 0x7d, 0x8a, 0x75, 0x68, 0x8c, 0x18, 0xd5, 0xe4, 0xa8,
		0x65, 0xc0, 0x39, 0x0f, 0xaf, 0xee, 0x50, 0x3d, 0xd5, 0x4f, 0xe0, 0x40, 0x2b, 0xd6, 0xa2, 0x32,
		0x01, 0xe8, 0x37, 0x0b, 0xf3, 0xbc, 0xf8, 0x29, 0xcd, 0xfb, 0x67, 0x9e, 0xea, 0x2f, 0x19, 0x58,
		0x37, 0x07, 0xe1, 0xa2, 0x37, 0xcd, 0xb0, 0xdc, 0xef, 0xf5, 0xdc, 0xc4, 0xf0, 0xd1, 0xa5, 0xb8,
		0x16, 0x3f, 0x51, 0xdf, 0x32, 0x47, 0x24, 0xa0, 0xd6, 0xbd, 0xcb, 0x38, 0x1a, 0x6f, 0x86, 0xe6,
		0x1a, 0xe7, 0x1e, 0x73, 0x30, 0x11, 0x52, 0x54, 0xd1, 0x27, 0xc4, 0x4c, 0x48, 0x79, 0x55, 0x1f,
		0x3b, 0x53, 0xa1, 0xec, 0x66, 0xbc, 0x6d, 0xe2, 0x40, 0x96, 0x79, 0x85, 0xaf, 0xe6, 0x48, 0x96,
		0xcf, 0x23, 0x17, 0x87, 0xfa, 0x37, 0xfa, 0x90, 0xcd, 0x99, 0x2c, 0xe9, 0x96, 0x81, 0xcd, 0x22,
		0xb0, 0x5b, 0x02, 0x29, 0x0b, 0xc0, 0xa1, 0xf9, 0x79, 0x84, 0x95, 0x47, 0x40, 0x85, 0x85, 0x52,
		0x48, 0x10, 0x39, 0x85, 0x4f, 0x6c, 0xdc, 0x21, 0xb3, 0xe6, 0x5e, 0xc5, 0x45, 0x1c, 0x9a, 0x9a,
		0x47, 0x43, 0xf3, 0x8c, 0xcf, 0x67, 0xd3, 0xc8, 0x32, 0xb3, 0x0d, 0xb9, 0x35, 0xb0, 0x9a, 0xf9,
		0x86, 0x6c, 0x1a, 0xf7, 0x45, 0x90, 0x2d, 0x3a, 0x9b, 0x3b, 0xc1, 0x29, 0xed, 0x94, 0x13, 0x4e,
		0xa5, 0x29, 0x73, 0x8c, 0xd3, 0x77, 0xdf, 0xa1, 0x98, 0xfd, 0x1c, 0xa7, 0xf9, 0xcb, 0x65, 0x0e,
		0x72, 0x5a, 0x3d, 0x59, 0x03, 0x8e, 0x71, 0x82, 0x63, 0x9c, 0xd6, 0x87, 0x09, 0xe1, 0x18, 0x27,
		0xed, 0xc7, 0x38, 0x1d, 0xac, 0x79, 0x59, 0xe3, 0xea, 0x29, 0x02, 0x30, 0x8b, 0xd2, 0xfd, 0xe3,
		0x20, 0x4d, 0x0a, 0x42, 0x16, 0xad, 0x8f, 0xf5, 0x87, 0x19, 0xbe, 0xb9, 0x69, 0xb9, 0xee, 0x2a,
		0x45, 0x32, 0x2f, 0x0c, 0x51, 0x3b, 0xd9, 0x2a, 0xf5, 0x3c, 0x23, 0x05, 0x46, 0xca, 0xdb, 0xbc,
		0xd2, 0x2f, 0x69, 0xaa, 0x9d, 0x49, 0xa5, 0x2f, 0x79, 0x83, 0x74, 0x05, 0x3e, 0xff, 0xa0, 0xd3,
		0x87, 0x9c, 0x21, 0xb7, 0x11, 0x90, 0xc1, 0xe2, 0xf9, 0x4a, 0xd3, 0xf0, 0x64, 0xf8, 0xd7, 0x57,
		0xaf, 0xb3, 0x7c, 0xde, 0xf2, 0x4a, 0xf5, 0xb8, 0x4e, 0x2d, 0xae, 0xfb, 0x1d, 0x16, 0x35, 0xc8,
		0xac, 0xfe, 0x98, 0xd5, 0xde, 0xdc, 0x46, 0x47, 0x4f, 0xc5, 0xc9, 0xba, 0xab, 0x52, 0x94, 0xd1,
		0x2c, 0xa0, 0x11, 0x71, 0xe8, 0x73, 0xba, 0x11, 0x9c, 0x5e, 0x9a, 0x83, 0x43, 0xca, 0x56, 0x6c,
		0x4d, 0xce, 0x2d, 0xd5, 0xf2, 0xad, 0x13, 0xb3, 0x54, 0xa9, 0x87, 0x94, 0x75, 0x3d, 0x42, 0xf1,
		0x13, 0x65, 0xf7, 0x9b, 0x26, 0x37, 0xa4, 0xcd, 0xc6, 0xe6, 0x98, 0x58, 0x63, 0xac, 0x37, 0x27,
		0x9d, 0x2d, 0x38, 0xdf, 0x22, 0x85, 0xd3, 0x54, 0x38, 0x1a, 0x1b, 0x18, 0xa2, 0xbe, 0x9e, 0x13,
		0xd5, 0x04, 0xa1, 0xf9, 0xcf, 0xb7, 0x18, 0x73, 0x20, 0x6b, 0x29, 0xc3, 0x2e, 0x9c, 0x72, 0x51,
		0x82, 0x53, 0x2e, 0x5e, 0x93, 0xe4, 0xa4, 0x02, 0x67, 0x5a, 0x68, 0x8f, 0x9b, 0xfb, 0xb8, 0x87,
		0x7d, 0x4c, 0xba, 0x5a, 0x8f, 0x0b, 0xfc, 0xfc, 0xe1, 0x02, 0x9d, 0xd4, 0xce, 0xaa, 0x75, 0x74,
		0xe1, 0xe1, 0x27, 0x27, 0xa0, 0xe1, 0x0f, 0xa2, 0x7b, 0x4c, 0xbf, 0x63, 0x4c, 0xd0, 0xef, 0xd8,
		0x0f, 0x1c, 0x8f, 0xa0, 0xf2, 0x51, 0xf2, 0xb1, 0x72, 0xd4, 0x26, 0x08, 0x59, 0xc4, 0x4e, 0xbe,
		0x39, 0x41, 0x5e, 0x0f, 0xd1, 0x3e, 0x46, 0xd7, 0x84, 0x62, 0x9f, 0x60, 0x6a, 0x06, 0xd4, 0x22,
		0xb6, 0xe5, 0xdb, 0xe1, 0x95, 0xb7, 0x98, 0x7e, 0xf7, 0xfc, 0x3f, 0xd1, 0x8d, 0x45, 0xac, 0x87,
		0x28, 0xc4, 0x88, 0x3e, 0xf8, 0xd6, 0x00, 0x87, 0x5f, 0x1e, 0x87, 0x17, 0x34, 0x6f, 0x6f, 0xee,
		0xcc, 0x8b, 0x4f, 0x37, 0x37, 0x5f, 0x6e, 0xaf, 0x5b, 0xff, 0x32, 0x6f, 0xae, 0xdf, 0x1f, 0x87,
		0xaa, 0xef, 0x62, 0x82, 0x65, 0x2e, 0x62, 0x8d, 0x73, 0xcb, 0x57, 0x3b, 0xa5, 0x22, 0xbe, 0x3f,
		0xdd, 0x80, 0x4d, 0x86, 0xf7, 0xb7, 0x6b, 0x87, 0x76, 0xe2, 0xac, 0x19, 0x4c, 0x1e, 0x1c, 0x82,
		0x4d, 0xc7, 0x66, 0x47, 0x66, 0xd3, 0x5b, 0x00, 0x30, 0x01, 0x60, 0x12, 0x60, 0x0c, 0x6e, 0xb4,
		0xc4, 0x5b, 0x5f, 0x65, 0x1c, 0x7e, 0x2d, 0x99, 0xe7, 0x96, 0xd9, 0x6b, 0x98, 0x1f, 0x3a, 0x3f,
		0x2a, 0x2f, 0x87, 0xf5, 0xf9, 0xff, 0x5f, 0x78, 0x53, 0x78, 0xc7, 0xba, 0x5f, 0xb3, 0x4b, 0x15,
		0xa2, 0xb5, 0x5e, 0x7f, 0x53, 0xf8, 0x51, 0x3d, 0x3a, 0x29, 0xbf, 0x18, 0x39, 0xb4, 0xab, 0x4e,
		0xcf, 0xec, 0x61, 0x8b, 0x8e, 0x7c, 0xad, 0x86, 0x35, 0xe4, 0xc6, 0xfa, 0xd0, 0xf7, 0x9e, 0x9e,
		0x33, 0xb6, 0x5a, 0x33, 0xaf, 0xb7, 0x49, 0xb3, 0x35, 0xf3, 0xfe, 0xd9, 0xdb, 0x84, 0x23, 0x40,
		0x57, 0x7c, 0xb6, 0xfb, 0x2a, 0xd2, 0x52, 0xd7, 0x97, 0x80, 0xb0, 0xb6, 0x62, 0x97, 0x76, 0x02,
		0x65, 0x39, 0xc4, 0xc6, 0x4f, 0xec, 0x08, 0x2b, 0xbe, 0x1c, 0xd0, 0x15, 0xa0, 0xab, 0x59, 0xa6,
		0xe0, 0x99, 0xa2, 0x02, 0x47, 0xae, 0x42, 0x30, 0x0a, 0x82, 0x51, 0x10, 0x8c, 0x92, 0x30, 0xc4,
		0xd7, 0x0c, 0x46, 0x08, 0x40, 0xd2, 0x26, 0xf7, 0x66, 0x27, 0xa0, 0x91, 0xb6, 0x73, 0xe8, 0x6b,
		0x00, 0x8c, 0xb6, 0x11, 0x18, 0x31, 0x1f, 0x76, 0x7c, 0xef, 0x10, 0xcb, 0x7f, 0x16, 0x3c, 0x1b,
		0x65, 0xf6, 0x66, 0xbe, 0x19, 0xbf, 0xd5, 0x3c, 0xce, 0xf8, 0x65, 0x64, 0x37, 0x95, 0xaa, 0x3a,
		0x07, 0x33, 0x7e, 0xd9, 0xd8, 0x91, 0x53, 0x09, 0xea, 0x9a, 0xf1, 0x2b, 0xc2, 0xae, 0x0a, 0xd8,
		0x96, 0xd3, 0x5d, 0x94, 0x66, 0x63, 0x19, 0x76, 0x96, 0x65, 0x6b, 0x59, 0xf6, 0x56, 0xc6, 0xe6,
		0xca, 0xd8, 0x5d, 0x01, 0xdb, 0xf3, 0xb1, 0xbf, 0x80, 0x47, 0x83, 0xa4, 0x9a, 0xe0, 0x5f, 0xb1,
		0xb6, 0xc4, 0x39, 0x2a, 0xe7, 0x7b, 0xd7, 0x06, 0x1a, 0x32, 0x42, 0x31, 0xfa, 0x27, 0xa9, 0x86,
		0x2b, 0x86, 0xaa, 0xa1, 0x38, 0xab, 0x26, 0x32, 0x6c, 0xc1, 0x9b, 0x56, 0xcb, 0x70, 0xdb, 0x63,
		0x9e, 0x42, 0x1b, 0xb0, 0xc6, 0x60, 0x8d, 0x65, 0xad, 0x31, 0x3f, 0xab, 0x4a, 0xb3, 0x2c, 0x58,
		0x62, 0xb0, 0xc4, 0x5b, 0x61, 0x89, 0xf3, 0x7b, 0xa2, 0xd9, 0x16, 0x9a, 0xe2, 0xa9, 0x96, 0xc8,
		0xc5, 0x28, 0x86, 0x95, 0x5d, 0x23, 0x62, 0x21, 0x4d, 0xd1, 0xae, 0x92, 0x14, 0xf1, 0x5c, 0xd3,
		0x65, 0xb2, 0x56, 0x1e, 0x65, 0x63, 0x13, 0x1d, 0x88, 0x26, 0xeb, 0x8a, 0x58, 0x42, 0x4d, 0x63,
		0xbe, 0xb7, 0x66, 0x0f, 0x87, 0x2a, 0xac, 0xd2, 0xd9, 0x3a, 0x7a, 0xdc, 0x03, 0xdc, 0x1d, 0xf9,
		0x0e, 0x65, 0x8c, 0xff, 0x4c, 0x4d, 0xf1, 0xdc, 0x6d, 0x50, 0x10, 0xb0, 0xc3, 0x71, 0x6f, 0x8e,
		0x03, 0x5c, 0x04, 0x8a, 0x07, 0x78, 0x18, 0x09, 0x41, 0xfd, 0x00, 0xd4, 0x0f, 0x6c, 0x9e, 0x26,
		0xb9, 0xb0, 0x33, 0x80, 0x97, 0x01, 0x2f, 0x6f, 0x04, 0x94, 0x35, 0xc7, 0x0a, 0x1b, 0x70, 0xf3,
		0x76, 0x6c, 0xd1, 0x4e, 0xd4, 0x62, 0x50, 0xcb, 0x7f, 0xc0, 0xd4, 0xa4, 0xd6, 0x03, 0x3b, 0x44,
		0x9d, 0xb9, 0x07, 0xf0, 0x29, 0x14, 0xac, 0xce, 0x71, 0xc6, 0x83, 0xf9, 0x18, 0x01, 0x0f, 0x68,
		0x9e, 0xde, 0x53, 0xbc, 0x59, 0xa9, 0xd5, 0x00, 0x70, 0x72, 0x89, 0x19, 0x40, 0x26, 0x61, 0x7b,
		0xdc, 0xf2, 0x2d, 0x12, 0x0c, 0x3d, 0x9f, 0xb6, 0xac, 0x07, 0x80, 0x4c, 0xf9, 0xdf, 0xa2, 0xed,
		0x81, 0x4c, 0x22, 0x33, 0x4d, 0xd7, 0xf5, 0xf0, 0xe4, 0x77, 0xa8, 0x29, 0x19, 0xb9, 0x2e, 0xc7,
		0xa8, 0xce, 0xd5, 0x1a, 0x56, 0xc5, 0xac, 0x4e, 0x76, 0xbd, 0xc6, 0x81, 0x4a, 0xb6, 0x40, 0x48,
		0x22, 0xca, 0xe8, 0x05, 0xa9, 0xbc, 0x0a, 0x4b, 0x0d, 0x4e, 0xdd, 0x16, 0xda, 0xef, 0xc0, 0xbc,
		0xd3, 0x25, 0xc9, 0x0d, 0xbe, 0x41, 0xa7, 0x4d, 0x32, 0x18, 0x7e, 0x8b, 0xfe, 0x49, 0x88, 0x23,
		0x33, 0xe3, 0x34, 0x9e, 0x0d, 0x90, 0x3e, 0xd7, 0x6d, 0x7c, 0x1d, 0x0c, 0x75, 0xdb, 0x86, 0xa1,
		0x6e, 0x98, 0x84, 0xe2, 0x62, 0x5a, 0x23, 0xda, 0xc7, 0xc4, 0xa4, 0xbe, 0x35, 0x0c, 0x78, 0xc6,
		0x88, 0x2c, 0xde, 0x0c, 0x11, 0x04, 0x88, 0x20, 0xcc, 0xd6, 0x04, 0x7b, 0x9e, 0x8b, 0x2d, 0xc2,
		0x13, 0x3f, 0x28, 0xef, 0xb0, 0xf7, 0x55, 0x2d, 0x9f, 0xd5, 0x67, 0x4d, 0xdb, 0x35, 0xe9, 0x79,
		0xfe, 0x20, 0x32, 0x10, 0xe8, 0xbd, 0x15, 0x60, 0x74, 0x78, 0x73, 0xfd, 0xbe, 0x80, 0x7a, 0x9e,
		0x1f, 0x5a, 0xc8, 0xc8, 0xdc, 0x39, 0x83, 0xa1, 0x8b, 0x97, 0x99, 0xc5, 0xbb, 0xf1, 0x31, 0x3a,
		0xe8, 0x30, 0x34, 0x89, 0x85, 0x89, 0x6d, 0x7c, 0xac, 0x24, 0x36, 0xf1, 0x2a, 0x92, 0xcf, 0x46,
		0x24, 0x9e, 0x2d, 0x06, 0xe9, 0xdc, 0x61, 0x9f, 0x6a, 0xd3, 0x84, 0xdf, 0x91, 0x49, 0x53, 0xe1,
		0x6b, 0xd9, 0xbc, 0x06, 0xc2, 0x56, 0x3a, 0x01, 0x34, 0x72, 0x58, 0x60, 0x0c, 0x28, 0x18, 0xa1,
		0x4d, 0x1a, 0x21, 0x18, 0xd4, 0x06, 0x2c, 0xbd, 0x51, 0x96, 0x86, 0x41, 0x6d, 0xfb, 0x1b, 0xc2,
		0xaf, 0x96, 0xcb, 0x75, 0xd4, 0x20, 0xa8, 0xe1, 0x77, 0xfb, 0x0e, 0xc5, 0x5d, 0x3a, 0xf2, 0x71,
		0x84, 0x5c, 0x2e, 0x71, 0xd0, 0xf5, 0x9d, 0x7b, 0x87, 0x3c, 0xbc, 0x42, 0x2f, 0x21, 0x44, 0x59,
		0x0d, 0x60, 0x66, 0xfe, 0x14, 0x5e, 0x98, 0x84, 0x5b, 0x82, 0x69, 0xbc, 0xe5, 0xc3, 0xe7, 0xc6,
		0xcd, 0xd5, 0x1f, 0x9f, 0x3e, 0xff, 0x73, 0x06, 0xe2, 0xec, 0xfb, 0x0c, 0xae, 0x7c, 0x6d, 0xc3,
		0x4e, 0x00, 0x4c, 0x37, 0x0a, 0x28, 0xb2, 0x9b, 0xc7, 0xf1, 0xf5, 0x6c, 0xb6, 0xb1, 0x0c, 0xb6,
		0x71, 0x1b, 0x6d, 0x23, 0xf3, 0x34, 0x09, 0xb1, 0xb6, 0x55, 0x81, 0x8e, 0xd5, 0x12, 0x74, 0xac,
		0x42, 0xc7, 0xaa, 0x40, 0x9b, 0x9e, 0xd8, 0x1c, 0x38, 0x11, 0x14, 0x37, 0xcd, 0x52, 0xf2, 0xd5,
		0xd9, 0xf0, 0x23, 0x93, 0xe4, 0x97, 0x44, 0xea, 0x6e, 0x92, 0x9b, 0x05, 0xeb, 0xbd, 0x93, 0xfb,
		0x65, 0x4b, 0x4e, 0xa6, 0x3b, 0x24, 0x5a, 0x7a, 0xc2, 0xc9, 0x3c, 0xf3, 0xa4, 0xb3, 0x9e, 0xe4,
		0x49, 0xc7, 0x5b, 0x17, 0x9e, 0x47, 0xda, 0x69, 0xea, 0x39, 0xed, 0x64, 0x39, 0x40, 0x61, 0x52,
		0x1e, 0x21, 0x30, 0x40, 0x21, 0xb9, 0x95, 0xcf, 0x1c, 0xd5, 0xc0, 0x1c, 0x81, 0x39, 0xe2, 0xea,
		0x3e, 0xe2, 0xc6, 0x56, 0xc9, 0x0d, 0x36, 0x75, 0x03, 0xf1, 0x79, 0x0b, 0xd1, 0xdd, 0x62, 0xa3,
		0x16, 0xaa, 0x30, 0x6a, 0x41, 0xbf, 0x30, 0x28, 0x13, 0x0a, 0x05, 0xc2, 0x21, 0x68, 0x14, 0x38,
		0x77, 0x9b, 0x57, 0x00, 0xe4, 0x04, 0x41, 0x85, 0x40, 0x70, 0x7a, 0xb5, 0xca, 0x05, 0x44, 0x85,
		0xa0, 0xa8, 0x12, 0x18, 0x55, 0x82, 0xa3, 0x5c, 0x80, 0x94, 0x0b, 0x92, 0x42, 0x81, 0x12, 0x13,
		0x2c, 0x09, 0x7c, 0x2b, 0x25, 0x68, 0xc9, 0x02, 0xce, 0x50, 0x7e, 0x7b, 0x13, 0xff, 0x6b, 0x28,
		0xbb, 0xaf, 0x62, 0x03, 0x80, 0x94, 0x0b, 0xa1, 0x4a, 0x61, 0x54, 0x2d, 0x94, 0xaa, 0x85, 0x53,
		0x9b, 0x90, 0x6a, 0x13, 0x56, 0x0d, 0x42, 0x2b, 0x27, 0xbc, 0x92, 0x42, 0x2c, 0x03, 0x35, 0xd5,
		0x45, 0x51, 0x18, 0xa4, 0xdb, 0xb4, 0x6c, 0xdb, 0xc7, 0x41, 0xa0, 0x82, 0x7b, 0x27, 0x66, 0xf6,
		0x5c, 0xc1, 0x5a, 0xe3, 0x77, 0xfd, 0xaa, 0x84, 0xab, 0xd4, 0x48, 0xd3, 0x2b, 0xca, 0x3d, 0x56,
		0x15, 0xd2, 0x4e, 0x26, 0x72, 0x95, 0xae, 0xf1, 0x38, 0xf3, 0x94, 0xcc, 0x0b, 0x1f, 0x46, 0x39,
		0xc7, 0xce, 0xcf, 0xaf, 0x65, 0xf3, 0xbc, 0x13, 0x7f, 0x2c, 0x47, 0xff, 0x89, 0x3f, 0x57, 0xbe,
		0x96, 0xcc, 0xea, 0xe4, 0x73, 0xed, 0x6b, 0xc9, 0xac, 0x75, 0x0a, 0xed, 0xf6, 0x71, 0xe1, 0xc7,
		0xc9, 0x0b, 0xff, 0x8d, 0x87, 0x7f, 0x3f, 0xfe, 0xb5, 0xf0, 0xce, 0x50, 0xf6, 0x02, 0x1d, 0x25,
		0x2b, 0xbd, 0x1c, 0xe5, 0x98, 0x41, 0x4f, 0x81, 0x41, 0x0f, 0xeb, 0x3f, 0x67, 0x73, 0xec, 0xa5,
		0xa3, 0xea, 0x4b, 0xa1, 0x5e, 0x38, 0x7c, 0xfd, 0x5d, 0xbd, 0xf0, 0xa3, 0x74, 0x54, 0x7b, 0x39,
		0x3c, 0x5c, 0xf2, 0x97, 0x77, 0xcb, 0xd6, 0x28, 0xfc, 0x3c, 0x3c, 0x3c, 0x1c, 0xb3, 0xe6, 0x1c,
		0xbb, 0x7e, 0x2d, 0x95, 0x3b, 0xef, 0xa2, 0x8f, 0xf1, 0xbf, 0x09, 0xc3, 0x33, 0x5d, 0x5c, 0x28,
		0x1c, 0xfe, 0xfd, 0x6b, 0xc3, 0xfc, 0xb7, 0x65, 0xfe, 0x15, 0x49, 0x43, 0xf2, 0xb1, 0xdd, 0x36,
		0xdb, 0xed, 0xe3, 0x6f, 0xff, 0x57, 0xec, 0xb0, 0xd7, 0x08, 0xf0, 0x88, 0xf1, 0xff, 0xd6, 0x3b,
		0xbf, 0xd6, 0x0b, 0x3f, 0x4e, 0x5f, 0x26, 0x9f, 0xa3, 0x7f, 0x0b, 0x3f, 0x0f, 0x8f, 0xdf, 0xb4,
		0xdb, 0xc7, 0xc7, 0x6f, 0x0a, 0xf1, 0x1b, 0x8f, 0xaf, 0x7b, 0x13, 0xff, 0xf5, 0x5d, 0xbd, 0xbe,
		0xf0, 0x55, 0x5e, 0xe5, 0xf4, 0x60, 0xb3, 0xcf, 0x21, 0xfe, 0xfb, 0x12, 0x1a, 0xc6, 0xe0, 0x0a,
		0xae, 0xa6, 0x6a, 0x14, 0x8e, 0x78, 0x2b, 0x38, 0x03, 0xe0, 0x0c, 0x80, 0x33, 0x90, 0x01, 0x80,
		0x0f, 0x65, 0xd2, 0x24, 0xa3, 0xc1, 0x3d, 0x57, 0x7e, 0x34, 0x4d, 0x3c, 0x4f, 0x15, 0x2c, 0xf5,
		0xd9, 0x22, 0x0f, 0xb9, 0x44, 0xf0, 0x32, 0xd9, 0xd7, 0x95, 0x8b, 0x0a, 0x4e, 0x45, 0x48, 0x5d,
		0x57, 0x55, 0xc6, 0x71, 0x35, 0x23, 0xc9, 0x66, 0x22, 0x35, 0x23, 0x63, 0x24, 0x9b, 0xf5, 0x4d,
		0xdd, 0xb2, 0xd3, 0x5a, 0xed, 0xa4, 0x06, 0xdb, 0xa6, 0x0c, 0x28, 0x6d, 0x39, 0xdc, 0xca, 0x34,
		0xd4, 0x2b, 0x38, 0x94, 0x79, 0x61, 0x9d, 0xf5, 0x3d, 0xb1, 0x71, 0x01, 0x74, 0x31, 0xae, 0x00,
		0x2c, 0x26, 0xb9, 0xf3, 0xa2, 0x4d, 0xdd, 0xa0, 0x28, 0x91, 0x57, 0x41, 0x69, 0xbd, 0xb4, 0x71,
		0xc5, 0xe5, 0xb7, 0x8f, 0xd1, 0x0f, 0x7f, 0xbb, 0x0c, 0x7f, 0xe9, 0x20, 0x9b, 0x4d, 0xd1, 0x9b,
		0x0a, 0x13, 0xa8, 0x79, 0x5e, 0x58, 0x43, 0xe0, 0xb0, 0x6a, 0x75, 0x46, 0x71, 0x5a, 0x48, 0xe1,
		0x06, 0x74, 0x90, 0xb3, 0x74, 0x92, 0xf0, 0x39, 0xd7, 0xda, 0x81, 0xe9, 0x1c, 0x20, 0x8d, 0x49,
		0x97, 0xb5, 0xa2, 0x39, 0xd0, 0xab, 0x48, 0x79, 0x25, 0x41, 0x52, 0x81, 0x49, 0x28, 0x2e, 0x43,
		0xd7, 0xd4, 0x7d, 0x8e, 0x4a, 0x9c, 0x20, 0xe8, 0x8b, 0x57, 0x78, 0x84, 0x37, 0x43, 0x81, 0x87,
		0x2e, 0xc5, 0x02, 0x05, 0x1e, 0xd9, 0x15, 0x78, 0x88, 0x88, 0x81, 0x02, 0x71, 0x78, 0x2d, 0x16,
		0x50, 0xde, 0x01, 0xe5, 0x1d, 0x5b, 0x80, 0xf9, 0xa1, 0xbc, 0x43, 0x87, 0x10, 0xaa, 0x14, 0x46,
		0xd5, 0x42, 0xa9, 0x5a, 0x38, 0xb5, 0x09, 0xa9, 0x36, 0x61, 0xd5, 0x20, 0xb4, 0x6a, 0x42, 0x0d,
		0x50, 0xde, 0xc1, 0x6f, 0x66, 0xa1, 0xbc, 0x43, 0x9e, 0x86, 0x50, 0xde, 0x01, 0xe5, 0x1d, 0xb2,
		0x0c, 0x0a, 0xe5, 0x1d, 0x50, 0xde, 0xc1, 0x28, 0xc6, 0x50, 0xde, 0xa1, 0xf7, 0x39, 0xa0, 0xbc,
		0x03, 0x9c, 0x01, 0x70, 0x06, 0xf6, 0xdd, 0x19, 0x80, 0xf2, 0x8e, 0x1c, 0x00, 0x24, 0x28, 0xef,
		0x98, 0x63, 0x24, 0x28, 0xef, 0x80, 0xf2, 0x0e, 0xa5, 0x40, 0x09, 0x41, 0x79, 0x07, 0xbb, 0x81,
		0xdb, 0x68, 0x79, 0x47, 0x10, 0xf4, 0x8b, 0xe2, 0x59, 0x15, 0xc4, 0x57, 0xdc, 0xd1, 0x0c, 0xfa,
		0x50, 0xdb, 0x31, 0x59, 0x23, 0x1f, 0xb5, 0x1d, 0x41, 0xd0, 0x87, 0xda, 0x0e, 0x41, 0x34, 0x1a,
		0x91, 0x0e, 0x6a, 0x3b, 0x36, 0x50, 0xdb, 0x11, 0xf0, 0x2a, 0x12, 0x3d, 0xa5, 0x1d, 0x52, 0xc3,
		0x3b, 0x60, 0x76, 0x87, 0x4e, 0xbd, 0x02, 0xa5, 0x1d, 0xd9, 0x95, 0x76, 0x28, 0x19, 0xdd, 0x01,
		0x93, 0x3b, 0xa0, 0xb4, 0x63, 0x43, 0x81, 0x21, 0x28, 0xed, 0x90, 0x0f, 0x17, 0x41, 0x34, 0x37,
		0x3b, 0xe1, 0xd4, 0x26, 0xa4, 0xda, 0x84, 0x55, 0x83, 0xd0, 0xaa, 0x09, 0x33, 0x40, 0x69, 0x07,
		0xbf, 0x99, 0x85, 0xd2, 0x0e, 0x79, 0x1a, 0x42, 0x69, 0x07, 0x94, 0x76, 0xc8, 0x32, 0x28, 0x94,
		0x76, 0x40, 0x69, 0x07, 0xa3, 0x18, 0x43, 0x69, 0x87, 0xde, 0xe7, 0x80, 0xd2, 0x0e, 0x70, 0x06,
		0xc0, 0x19, 0xd8, 0x77, 0x67, 0x00, 0x4a, 0x3b, 0x72, 0x00, 0x90, 0xa0, 0xb4, 0x63, 0x8e, 0x91,
		0xa0, 0xb4, 0x03, 0x4a, 0x3b, 0x94, 0x02, 0x25, 0x04, 0xa5, 0x1d, 0xec, 0x06, 0x6e, 0xa3, 0xa5,
		0x1d, 0xd4, 0x0d, 0x8a, 0x99, 0xcd, 0xed, 0x68, 0xc1, 0xd8, 0x8e, 0xe9, 0x1a, 0x30, 0xb6, 0x63,
		0x15, 0x32, 0x85, 0xb1, 0x1d, 0x2a, 0xef, 0xda, 0xc5, 0xd2, 0x8e, 0x9c, 0x4c, 0xed, 0x18, 0xd9,
		0x43, 0xf1, 0xd2, 0x8e, 0xf0, 0x66, 0x28, 0xed, 0xd0, 0xa5, 0x57, 0xa0, 0xb4, 0x23, 0xbb, 0xd2,
		0x0e, 0x11, 0x31, 0x50, 0x20, 0x0e, 0xaf, 0xc5, 0x02, 0x4a, 0x3b, 0xa0, 0xb4, 0x63, 0x0b, 0xf0,
		0x3e, 0x94, 0x76, 0xe8, 0x10, 0x42, 0x95, 0xc2, 0xa8, 0x5a, 0x28, 0x55, 0x0b, 0xa7, 0x36, 0x21,
		0xd5, 0x26, 0xac, 0x1a, 0x84, 0x56, 0x4d, 0x98, 0x01, 0x4a, 0x3b, 0xf8, 0xcd, 0x2c, 0x94, 0x76,
		0xc8, 0xd3, 0x10, 0x4a, 0x3b, 0xa0, 0xb4, 0x43, 0x96, 0x41, 0xa1, 0xb4, 0x03, 0x4a, 0x3b, 0x18,
		0xc5, 0x18, 0x4a, 0x3b, 0xf4, 0x3e, 0x07, 0x94, 0x76, 0x80, 0x33, 0x00, 0xce, 0xc0, 0xbe, 0x3b,
		0x03, 0x50, 0xda, 0x91, 0x03, 0x80, 0x04, 0xa5, 0x1d, 0x73, 0x8c, 0x04, 0xa5, 0x1d, 0x50, 0xda,
		0xa1, 0x14, 0x28, 0x21, 0x28, 0xed, 0x60, 0x37, 0x70, 0x1b, 0x2d, 0xed, 0x18, 0xd9, 0xc3, 0xa2,
		0x78, 0x56, 0x05, 0xf1, 0x95, 0x76, 0x7c, 0xb1, 0x87, 0xbb, 0x51, 0xda, 0xb1, 0x99, 0x84, 0xf6,
		0x88, 0x97, 0x7c, 0x1c, 0x09, 0xed, 0x03, 0x85, 0x64, 0x32, 0x1a, 0xa3, 0x87, 0x10, 0xb2, 0x61,
		0x9b, 0xcb, 0xf6, 0x0b, 0xa6, 0xc8, 0x23, 0x9a, 0xd5, 0x13, 0xea, 0xd5, 0xc7, 0xd4, 0x8b, 0x3e,
		0x8f, 0x49, 0x18, 0x7d, 0x4e, 0xe8, 0x28, 0x98, 0x50, 0x2f, 0x43, 0x42, 0x3d, 0x3b, 0xff, 0x02,
		0x12, 0xea, 0xa9, 0x37, 0xda, 0x4a, 0x86, 0x25, 0xd8, 0xf2, 0xd3, 0x12, 0xaa, 0x90, 0x52, 0x87,
		0x94, 0x7a, 0x86, 0x38, 0xeb, 0x20, 0x03, 0x64, 0x96, 0x97, 0x49, 0x24, 0x20, 0x5b, 0x20, 0x5b,
		0xf9, 0x96, 0x2d, 0x28, 0xa1, 0x66, 0x55, 0x05, 0x50, 0x42, 0x2d, 0x26, 0x08, 0xbb, 0x59, 0x42,
		0xad, 0xa3, 0xd6, 0x18, 0x3c, 0x28, 0xf0, 0xa0, 0xc0, 0x83, 0x62, 0x8f, 0xc2, 0xe4, 0xe3, 0x20,
		0x41, 0xc0, 0x78, 0x80, 0xf1, 0x00, 0xe3, 0xc1, 0x04, 0x64, 0x98, 0x80, 0xbc, 0xbf, 0x18, 0x8f,
		0xe9, 0xca, 0x0e, 0x6b, 0xf8, 0x5d, 0x2c, 0x3b, 0x21, 0x96, 0x95, 0x60, 0xdb, 0xb4, 0xf4, 0x17,
		0x5c, 0x7f, 0x45, 0x8a, 0x52, 0x09, 0x39, 0x3e, 0x7c, 0xe6, 0x28, 0x09, 0x95, 0x72, 0xe9, 0x47,
		0x27, 0xa0, 0x0d, 0x4a, 0xd9, 0x30, 0x83, 0x71, 0xe3, 0x90, 0x2b, 0x17, 0x87, 0x6c, 0xca, 0x98,
		0xc2, 0x35, 0x6e, 0xac, 0xa7, 0x99, 0x3b, 0xca, 0x67, 0xd5, 0xea, 0xe9, 0xdb, 0x6a, 0xb5, 0xf4,
		0xf6, 0xe4, 0x6d, 0xe9, 0xbc, 0x56, 0x2b, 0x9f, 0x96, 0x19, 0x12, 0xcd, 0xc6, 0x27, 0xdf, 0xc6,
		0x3e, 0xb6, 0xdf, 0x87, 0x6f, 0x45, 0x46, 0xae, 0xcb, 0x73, 0xcb, 0x97, 0x00, 0xfb, 0x4c, 0x39,
		0xe1, 0x34, 0xa2, 0x72, 0xf2, 0x11, 0x0f, 0xff, 0x30, 0x28, 0x23, 0xf6, 0xbc, 0xe2, 0x7a, 0x16,
		0x5c, 0xcd, 0x58, 0x6b, 0xde, 0xdf, 0x78, 0xc4, 0x7e, 0xc0, 0xf2, 0xe2, 0x89, 0xf2, 0x9f, 0xdc,
		0x90, 0xc6, 0xa8, 0x4c, 0xae, 0x10, 0x33, 0xb6, 0xe3, 0xc1, 0x70, 0xbc, 0x58, 0x8d, 0xd7, 0x1c,
		0x09, 0x63, 0x2f, 0x61, 0xd3, 0x22, 0x80, 0xa5, 0xe4, 0xd4, 0x0c, 0xab, 0xab, 0x61, 0x3c, 0x96,
		0xd9, 0xc9, 0x96, 0x70, 0x50, 0x99, 0x95, 0x5e, 0x7c, 0x15, 0x94, 0xdc, 0x8e, 0x82, 0x88, 0x63,
		0x20, 0xea, 0x08, 0x88, 0x62, 0x1e, 0x69, 0xa0, 0x2f, 0x8d, 0x67, 0x24, 0x80, 0xbc, 0xda, 0x6c,
		0x3b, 0x77, 0x45, 0x61, 0xb2, 0x57, 0x78, 0x30, 0xa4, 0xcf, 0x3c, 0x9b, 0x35, 0xd1, 0x5e, 0x27,
		0xaa, 0x8c, 0x3e, 0x83, 0x16, 0x7a, 0xac, 0x74, 0x05, 0x64, 0xa9, 0xd2, 0x05, 0x61, 0x02, 0x61,
		0x02, 0x61, 0x7a, 0x2d, 0x4c, 0x27, 0x02, 0xb2, 0x74, 0x02, 0xa2, 0x04, 0xa2, 0xb4, 0x5f, 0xa2,
		0x94, 0x3f, 0xbf, 0x89, 0xcd, 0xbf, 0x60, 0x75, 0x9c, 0x7e, 0x1f, 0xaf, 0x26, 0xea, 0x39, 0x1d,
		0x70, 0xd0, 0x85, 0x95, 0x1e, 0x4c, 0x74, 0x58, 0xf3, 0xfe, 0x0c, 0xef, 0xbd, 0xfc, 0x7d, 0x17,
		0xdf, 0x66, 0xc9, 0x9b, 0x18, 0xc4, 0xa3, 0x4e, 0xef, 0x79, 0xe5, 0x1b, 0x24, 0xcc, 0x3b, 0xbe,
		0x6e, 0x05, 0x2d, 0xd6, 0xfb, 0x7f, 0xa9, 0x2a, 0x91, 0x45, 0x05, 0xb2, 0xaa, 0x3c, 0x56, 0x15,
		0xc7, 0xad, 0xd2, 0xb8, 0x55, 0x18, 0x87, 0xca, 0xe2, 0xe3, 0xbc, 0x34, 0x7f, 0xcd, 0x18, 0x33,
		0x0b, 0xa3, 0x8f, 0xcf, 0x12, 0x5e, 0x62, 0xb3, 0x81, 0xe0, 0xe0, 0xe7, 0xd3, 0xc1, 0x67, 0xb6,
		0x59, 0xd3, 0x1e, 0x6b, 0x1b, 0x13, 0xea, 0xf4, 0x1c, 0xa6, 0xe6, 0x2b, 0x9e, 0xce, 0x69, 0xe3,
		0x23, 0x26, 0x0f, 0x91, 0x2a, 0x64, 0x4b, 0x68, 0x70, 0xd8, 0x59, 0x91, 0xf6, 0xa7, 0xa4, 0x57,
		0x86, 0x37, 0x8b, 0x2f, 0xdb, 0x07, 0x23, 0xde, 0xe7, 0xc2, 0x33, 0xa5, 0x4d, 0xa4, 0xbd, 0x28,
		0x21, 0xc9, 0x49, 0x65, 0x7b, 0x68, 0xa2, 0x08, 0x21, 0x75, 0xa4, 0xc4, 0x4c, 0x20, 0xe7, 0x67,
		0xf8, 0xb8, 0x87, 0x7d, 0x4c, 0xba, 0x58, 0x87, 0x44, 0x4c, 0xa4, 0xf9, 0xf3, 0x87, 0x0b, 0x74,
		0x52, 0x2d, 0x9f, 0xd4, 0x51, 0xd3, 0x19, 0x0c, 0x5d, 0x8c, 0x6e, 0x31, 0xfd, 0xee, 0xf9, 0x7f,
		0xa2, 0x1b, 0x8b, 0x58, 0x0f, 0x51, 0x54, 0x1f, 0xdd, 0xf9, 0x1e, 0xf5, 0xba, 0x9e, 0x8b, 0x0e,
		0x9b, 0xb7, 0x37, 0x77, 0x85, 0xe3, 0x36, 0x41, 0xa8, 0x31, 0x1c, 0xba, 0x4e, 0x37, 0xc2, 0x38,
		0x41, 0xf4, 0x45, 0xf8, 0x27, 0xf3, 0xf6, 0x53, 0xeb, 0xfa, 0xc3, 0xf5, 0x45, 0xa3, 0x75, 0xfd,
		0xe9, 0xd6, 0xbc, 0xb9, 0x7e, 0x7f, 0x1c, 0xaa, 0xb0, 0xdb, 0x08, 0x1f, 0xdc, 0xa6, 0x9b, 0x12,
		0xd5, 0xee, 0xc8, 0x94, 0x80, 0x9b, 0xf4, 0x48, 0xb2, 0xa5, 0x70, 0xde, 0xe4, 0x42, 0x28, 0x17,
		0x41, 0xad, 0x07, 0x76, 0x8c, 0x12, 0x5e, 0x0c, 0x10, 0x65, 0x87, 0x21, 0x0a, 0xc7, 0x34, 0x29,
		0x01, 0x38, 0x43, 0xad, 0x07, 0xf3, 0x31, 0x32, 0x6b, 0xfb, 0x81, 0x66, 0x4a, 0x80, 0x66, 0x5e,
		0x93, 0xa4, 0x52, 0xab, 0x01, 0x9c, 0x01, 0x38, 0xc3, 0x65, 0x6c, 0x5b, 0xa9, 0x56, 0x07, 0xd0,
		0x8c, 0x34, 0x81, 0x77, 0x03, 0xcc, 0xb0, 0x98, 0xa4, 0xa9, 0x39, 0x0a, 0xaf, 0x4e, 0x4b, 0xca,
		0xe3, 0x9e, 0x35, 0x72, 0x29, 0x93, 0x1c, 0x19, 0xd4, 0xb7, 0x52, 0x2c, 0x74, 0x07, 0xd0, 0x13,
		0x04, 0x78, 0x66, 0x93, 0x11, 0x64, 0x34, 0xc0, 0x7e, 0x1c, 0xbe, 0xe6, 0xc0, 0x44, 0x0c, 0x55,
		0xdd, 0xc6, 0x15, 0x19, 0x0d, 0xd8, 0x37, 0xa7, 0xe5, 0x35, 0xa9, 0xef, 0x90, 0x07, 0xbe, 0x9c,
		0x4a, 0x39, 0x12, 0xa3, 0x90, 0xeb, 0x39, 0xf4, 0x73, 0x25, 0x8a, 0x6c, 0x91, 0x9e, 0xe7, 0x33,
		0x16, 0x65, 0x32, 0xe7, 0x84, 0xbc, 0x6b, 0xc2, 0x37, 0x8e, 0x6c, 0xf2, 0x18, 0x75, 0xc4, 0x11,
		0x64, 0x89, 0x5f, 0xb8, 0x8e, 0xca, 0xb9, 0xc8, 0x07, 0x01, 0x3c, 0x68, 0xa5, 0xab, 0x71, 0xc0,
		0x07, 0xf2, 0x14, 0xde, 0x1e, 0x80, 0xc0, 0x95, 0xc5, 0x49, 0x2f, 0xee, 0x65, 0x2b, 0xea, 0x65,
		0x2f, 0xe6, 0x95, 0x2a, 0xe2, 0xe5, 0x28, 0xde, 0xe5, 0x28, 0xda, 0x5d, 0x45, 0x1c, 0x0e, 0xe5,
		0xc2, 0xa1, 0x54, 0x38, 0xec, 0x63, 0x86, 0x10, 0x38, 0x7c, 0x41, 0xbd, 0xa8, 0x87, 0x57, 0x6b,
		0xa8, 0x01, 0x3e, 0x19, 0x93, 0x50, 0xd6, 0xdc, 0x1d, 0xf0, 0xa9, 0x03, 0xbd, 0x65, 0x01, 0x6b,
		0xd3, 0xed, 0x28, 0xad, 0x2c, 0x20, 0x26, 0x8b, 0x7c, 0x59, 0x80, 0xd9, 0x73, 0x5c, 0x8a, 0x7d,
		0x73, 0xe8, 0x7b, 0x3d, 0x67, 0x8d, 0x18, 0xbe, 0xaa, 0x12, 0x78, 0x7d, 0x1b, 0x14, 0x0d, 0x6c,
		0x43, 0xd1, 0x00, 0x7e, 0xea, 0xba, 0x23, 0x9b, 0xc3, 0x8b, 0x9d, 0xdc, 0x00, 0x9e, 0x25, 0x78,
		0x96, 0x33, 0xb4, 0xfe, 0xee, 0xb8, 0x76, 0xd7, 0xf2, 0x6d, 0xd3, 0xbb, 0xff, 0x0f, 0xee, 0x52,
		0x53, 0xb0, 0x94, 0x40, 0xea, 0xa9, 0xa1, 0x1b, 0x0a, 0xbc, 0x38, 0x56, 0xf4, 0xf0, 0x21, 0x32,
		0x56, 0xcd, 0xd1, 0x3d, 0xf5, 0x31, 0x66, 0xbf, 0xe1, 0xc6, 0x0a, 0xfe, 0x64, 0xbf, 0x1a, 0x5c,
		0xc5, 0xdd, 0xd9, 0xc6, 0x9d, 0x08, 0x58, 0x3b, 0x84, 0xd3, 0xda, 0x4f, 0x6e, 0x00, 0x6b, 0x0f,
		0xd6, 0x1e, 0xac, 0x3d, 0x58, 0x7b, 0xb0, 0xf6, 0x60, 0xed, 0xc1, 0xda, 0x6f, 0x89, 0xb5, 0x87,
		0x86, 0x00, 0xb0, 0xf3, 0x72, 0x76, 0x1e, 0x1a, 0x02, 0x52, 0xee, 0x83, 0x86, 0x80, 0x5c, 0xd1,
		0x04, 0x2a, 0xe8, 0x72, 0x04, 0xb7, 0xee, 0xe2, 0x44, 0x00, 0x74, 0x07, 0x64, 0x4f, 0x6e, 0x48,
		0x9e, 0x43, 0xf2, 0x7c, 0xdd, 0xfb, 0x73, 0xcc, 0x18, 0xe4, 0x44, 0x66, 0xf5, 0x28, 0x19, 0x38,
		0x66, 0xdf, 0x71, 0x4a, 0x50, 0x33, 0x5a, 0xe3, 0x1e, 0x0b, 0xa8, 0x0e, 0xb1, 0x2d, 0x7d, 0x5b,
		0x7d, 0x29, 0xe9, 0xa3, 0x5d, 0x2d, 0x87, 0x98, 0xd3, 0x60, 0x51, 0x62, 0x9f, 0xc3, 0x5f, 0x83,
		0x52, 0x8a, 0xcd, 0x93, 0x7f, 0x07, 0xcb, 0x30, 0xd8, 0xea, 0x19, 0x10, 0x5b, 0x55, 0xc6, 0x1c,
		0x85, 0x65, 0x4a, 0x34, 0x86, 0xbe, 0xf7, 0xc4, 0x30, 0xb8, 0x21, 0xbe, 0x0c, 0x4a, 0x30, 0xb6,
		0xa1, 0x04, 0xa3, 0xeb, 0x11, 0x8a, 0x9f, 0xa8, 0x19, 0x0f, 0x05, 0x31, 0x1d, 0x9b, 0x3d, 0x66,
		0xb3, 0x78, 0x2b, 0x04, 0x70, 0xa0, 0x5d, 0x12, 0x89, 0x36, 0x07, 0xb0, 0x31, 0x11, 0x77, 0xac,
		0x87, 0xf7, 0x38, 0x7c, 0x63, 0xee, 0xd4, 0xfa, 0xca, 0xcb, 0x61, 0x7d, 0xfe, 0xff, 0x17, 0xd8,
		0xcf, 0x8c, 0x9f, 0x5b, 0xaa, 0x10, 0xad, 0xf5, 0xfa, 0x9b, 0xc2, 0x8f, 0xea, 0xd1, 0x49, 0xf9,
		0xc5, 0x80, 0xa8, 0x80, 0x0a, 0x94, 0x71, 0xf7, 0xf9, 0xd3, 0xff, 0xfc, 0x2b, 0x01, 0x0a, 0x77,
		0xa1, 0x19, 0xba, 0x88, 0x95, 0x54, 0x3c, 0xb5, 0xe8, 0xfa, 0x12, 0x62, 0x01, 0x59, 0x10, 0x79,
		0x27, 0x12, 0x18, 0x13, 0xf3, 0xc6, 0x97, 0xc8, 0x98, 0xbb, 0x0b, 0xec, 0x21, 0x24, 0x34, 0xc4,
		0x78, 0x03, 0xc1, 0x54, 0x00, 0x48, 0x69, 0x40, 0x4a, 0x03, 0xc0, 0x4b, 0xa8, 0x30, 0x20, 0x89,
		0x91, 0x05, 0x81, 0x77, 0x02, 0xb4, 0x0c, 0x46, 0x2e, 0x75, 0x86, 0x2e, 0x36, 0xa9, 0xe5, 0x3f,
		0x60, 0x6a, 0x7a, 0x23, 0xca, 0x8e, 0x5d, 0x96, 0xdd, 0x0c, 0x10, 0x06, 0x20, 0x0c, 0x4c, 0x35,
		0x02, 0xfc, 0x02, 0x53, 0x8d, 0x00, 0xc0, 0xf0, 0xdb, 0xd7, 0x9b, 0xb1, 0x45, 0x69, 0x45, 0x06,
		0xe5, 0xd3, 0x88, 0x02, 0x8c, 0xc9, 0x86, 0xcc, 0xd9, 0x4b, 0x08, 0x83, 0x8e, 0xff, 0xde, 0xc7,
		0x44, 0x27, 0x3b, 0x1f, 0x1f, 0x17, 0xe9, 0xf3, 0x10, 0xa3, 0xff, 0x42, 0xbf, 0x50, 0xdf, 0x1a,
		0xfe, 0x82, 0x3c, 0x1f, 0xcd, 0x7c, 0x17, 0xcf, 0x3f, 0xf9, 0x25, 0x63, 0x16, 0x8c, 0x5e, 0x7a,
		0x93, 0xdc, 0xc7, 0x48, 0x15, 0x28, 0x3a, 0x06, 0x80, 0x0b, 0x00, 0x17, 0x8a, 0x8e, 0x01, 0xe1,
		0x42, 0x84, 0x0e, 0x00, 0x2e, 0x2b, 0xf2, 0x82, 0xd0, 0x9c, 0x56, 0xca, 0xee, 0x04, 0x28, 0x09,
		0x1c, 0xf2, 0x20, 0x18, 0x91, 0x5b, 0xbc, 0x15, 0xe0, 0x0a, 0xc0, 0x15, 0x80, 0x2b, 0x00, 0x57,
		0x00, 0xae, 0x00, 0x5c, 0xe1, 0x37, 0xaa, 0xcd, 0xc8, 0x9e, 0x40, 0x34, 0x2e, 0x53, 0x22, 0xef,
		0x7b, 0x2c, 0xce, 0xc7, 0x96, 0xfd, 0x3a, 0xea, 0xf4, 0xdd, 0x77, 0x28, 0xde, 0xe7, 0x50, 0xdc,
		0x1a, 0xa2, 0xec, 0xc8, 0x51, 0x3b, 0x11, 0x64, 0x1d, 0x5a, 0xbe, 0x35, 0x08, 0x4c, 0x87, 0xf0,
		0x9c, 0xbb, 0xf3, 0xea, 0x4e, 0x80, 0xbc, 0x00, 0x79, 0x01, 0xf2, 0x02, 0xe4, 0x05, 0xc8, 0x0b,
		0x90, 0x97, 0x1f, 0x8d, 0xc5, 0x38, 0xec, 0x2e, 0xb2, 0x26, 0xd7, 0x04, 0x10, 0x6f, 0x06, 0x34,
		0x86, 0xe3, 0x75, 0x00, 0xa8, 0x40, 0xfb, 0xdb, 0xde, 0x9d, 0x8d, 0x13, 0xba, 0x34, 0xdc, 0x67,
		0xe3, 0x44, 0x3e, 0x0f, 0xcf, 0x5d, 0x27, 0x22, 0xc7, 0xf0, 0x54, 0xf3, 0x78, 0x0c, 0x4f, 0x95,
		0xe3, 0x05, 0x22, 0xda, 0x72, 0x41, 0xc1, 0xc9, 0xc9, 0x3d, 0x27, 0x1c, 0xb7, 0xc4, 0x9b, 0x51,
		0x47, 0x15, 0x38, 0xed, 0x67, 0xb3, 0x98, 0x05, 0x86, 0x39, 0xea, 0xa4, 0x2c, 0x0c, 0x28, 0x82,
		0x01, 0x45, 0x1b, 0x1a, 0x50, 0xb4, 0x6e, 0x34, 0x86, 0x2a, 0x00, 0xb6, 0xc9, 0x91, 0x44, 0xf1,
		0xfb, 0xc1, 0x10, 0x22, 0x0e, 0xd7, 0x09, 0x06, 0x08, 0x49, 0x91, 0x6e, 0xa7, 0x86, 0xff, 0xa4,
		0xa9, 0x87, 0xb5, 0xc3, 0x7e, 0xee, 0x56, 0xcb, 0x1e, 0xdb, 0x78, 0x9f, 0x38, 0xf2, 0x9e, 0x3e,
		0xdf, 0x67, 0x7c, 0x1d, 0x0c, 0xf8, 0xd9, 0x86, 0x01, 0x3f, 0x83, 0x41, 0xc0, 0xd1, 0x01, 0x38,
		0x08, 0x94, 0x1e, 0x12, 0x5c, 0x3d, 0xab, 0xc2, 0x19, 0xc1, 0x90, 0xdc, 0x61, 0xa7, 0xf5, 0x88,
		0x70, 0x46, 0x40, 0xce, 0x19, 0xae, 0x1d, 0x3f, 0x86, 0x36, 0x7f, 0x90, 0x2f, 0x78, 0x23, 0x12,
		0xc4, 0x11, 0x0b, 0xe6, 0xc8, 0x05, 0x75, 0x92, 0xbb, 0x4b, 0xf1, 0xc6, 0xfc, 0x49, 0xbc, 0xef,
		0x1c, 0xb1, 0x5d, 0xce, 0x7c, 0x90, 0x60, 0x34, 0x25, 0xb9, 0x75, 0xf2, 0x7c, 0x75, 0x54, 0xe2,
		0x7b, 0x44, 0xd5, 0xce, 0xe0, 0x91, 0x2e, 0x2e, 0x73, 0x08, 0x3d, 0xa9, 0x08, 0xf0, 0x17, 0x4f,
		0x00, 0xe8, 0xb3, 0x45, 0x1e, 0xd8, 0x45, 0x85, 0xff, 0x65, 0x66, 0x5d, 0x4c, 0xa1, 0x7d, 0x46,
		0xb3, 0x59, 0xc0, 0xea, 0x59, 0xf5, 0x48, 0x6c, 0x05, 0xd9, 0x74, 0xe0, 0x74, 0x73, 0x44, 0xd3,
		0x82, 0x82, 0x22, 0x82, 0x44, 0x53, 0xa7, 0x0b, 0xc4, 0xab, 0x94, 0xab, 0x6f, 0xab, 0x67, 0x27,
		0xa7, 0xd5, 0xb7, 0xdb, 0x4f, 0x43, 0x4d, 0x12, 0xdf, 0x81, 0xd4, 0x6d, 0xaa, 0x6f, 0x5c, 0x3b,
		0xab, 0xd6, 0xd1, 0x85, 0x87, 0x9f, 0x9c, 0x80, 0x86, 0x3f, 0x88, 0xee, 0x31, 0xfd, 0x8e, 0x31,
		0x41, 0xbf, 0x63, 0x3f, 0x70, 0x3c, 0x82, 0xca, 0x47, 0xc9, 0xc7, 0xca, 0x51, 0xe8, 0xce, 0x59,
		0xc4, 0x4e, 0xbe, 0x39, 0x41, 0x5e, 0x0f, 0xd1, 0x3e, 0x46, 0xd7, 0x84, 0x62, 0x9f, 0x60, 0x6a,
		0x06, 0xd4, 0x22, 0xb6, 0xe5, 0xdb, 0xe1, 0x95, 0x4b, 0x1c, 0xc6, 0x0f, 0xbe, 0x35, 0xc0, 0xe1,
		0x97, 0x53, 0xcf, 0xf0, 0xe2, 0xd3, 0xcd, 0xcd, 0x97, 0xdb, 0xeb, 0xd6, 0xd4, 0x3b, 0x8c, 0xd3,
		0x91, 0x0d, 0xdb, 0xf6, 0x6f, 0x6e, 0x9a, 0xfb, 0x1b, 0x47, 0xcd, 0xff, 0xd6, 0xec, 0x65, 0x65,
		0x64, 0x14, 0x27, 0x7b, 0x2c, 0x23, 0xcf, 0x47, 0xf1, 0xc7, 0x4a, 0x77, 0xdf, 0xea, 0x20, 0x97,
		0x91, 0x00, 0xfa, 0x8f, 0xc1, 0x01, 0x06, 0x07, 0x18, 0xaa, 0x1b, 0x75, 0xc3, 0x4e, 0xa8, 0x6e,
		0x54, 0x4a, 0x13, 0x80, 0xc8, 0xa9, 0x10, 0x99, 0x2f, 0x07, 0xb2, 0x3a, 0x05, 0xd2, 0x6a, 0x7c,
		0xfe, 0xc7, 0x55, 0x6b, 0x09, 0x94, 0x82, 0x26, 0x64, 0xfd, 0xe4, 0xdd, 0x09, 0x78, 0xe2, 0x63,
		0xea, 0x3b, 0x98, 0x23, 0x1f, 0x30, 0xb9, 0x41, 0x65, 0x4e, 0xe0, 0x04, 0x32, 0x02, 0x00, 0x88,
		0x38, 0x32, 0x02, 0x0e, 0xa1, 0x67, 0x1c, 0x58, 0x88, 0xe5, 0x60, 0x64, 0xbe, 0x30, 0x27, 0xcc,
		0x1a, 0xdc, 0x18, 0x12, 0x82, 0x59, 0x83, 0xfb, 0x0c, 0x85, 0x8e, 0x05, 0x8c, 0xf5, 0x67, 0x4c,
		0xfd, 0xe7, 0x0b, 0x6f, 0x44, 0xa0, 0xb9, 0x39, 0x1b, 0x2a, 0xef, 0x48, 0xb7, 0xea, 0x03, 0x4f,
		0x83, 0xea, 0x03, 0x44, 0x6d, 0x00, 0xa4, 0xc0, 0x58, 0x64, 0x80, 0x2a, 0x00, 0x55, 0x24, 0xc4,
		0x8c, 0xa9, 0x18, 0x7d, 0x96, 0x5f, 0xd9, 0x8a, 0xd2, 0x67, 0xb7, 0x53, 0xb8, 0x38, 0x3d, 0x59,
		0x84, 0xbd, 0x48, 0x7d, 0xf1, 0x96, 0xd4, 0x62, 0x75, 0x00, 0x75, 0x6c, 0x70, 0xa3, 0x65, 0x3d,
		0x84, 0xcc, 0x02, 0x88, 0x4e, 0x3f, 0x89, 0x77, 0x6f, 0xf8, 0x88, 0xe0, 0xe4, 0x11, 0x80, 0x78,
		0xd0, 0xcd, 0x2b, 0x0a, 0x07, 0x21, 0x89, 0x07, 0x78, 0x10, 0x92, 0x78, 0x00, 0x72, 0xb8, 0x2c,
		0xf0, 0x1d, 0x8b, 0xd9, 0x01, 0x8c, 0x23, 0x4f, 0xe1, 0xdd, 0x80, 0x38, 0xce, 0x00, 0x73, 0x8d,
		0x12, 0x9e, 0xdc, 0xa0, 0x32, 0x95, 0x57, 0xae, 0x95, 0x4a, 0x90, 0xcd, 0x83, 0x40, 0x19, 0x5f,
		0x36, 0x8f, 0xa9, 0x8b, 0x61, 0xc2, 0x19, 0x6f, 0x21, 0x9d, 0xb7, 0x3b, 0x98, 0xa8, 0x5a, 0x39,
		0xaf, 0x9e, 0x9f, 0xbe, 0xad, 0x9c, 0x43, 0xa8, 0x0c, 0xb0, 0x11, 0x57, 0x74, 0x82, 0xc9, 0x78,
		0x01, 0x38, 0x52, 0x40, 0xe2, 0xdd, 0x40, 0x47, 0xbe, 0x45, 0x82, 0xa1, 0xe7, 0xf3, 0xe0, 0xa3,
		0xe4, 0x16, 0x36, 0xc8, 0x52, 0x03, 0xc8, 0xb2, 0xeb, 0x81, 0x9f, 0xb4, 0xde, 0xfa, 0xe4, 0x42,
		0x9b, 0xba, 0x01, 0x3b, 0x91, 0x27, 0x9b, 0x18, 0xdd, 0xc5, 0x48, 0xa6, 0x31, 0xd3, 0x31, 0xf6,
		0x3b, 0x32, 0x33, 0x9f, 0x08, 0x13, 0x8a, 0x32, 0xa3, 0x4a, 0xcd, 0xcc, 0xc5, 0x9c, 0x7a, 0xd4,
		0x32, 0x1b, 0xb3, 0x72, 0x2a, 0x4b, 0xc6, 0xdd, 0x62, 0x65, 0x4c, 0x31, 0x06, 0x95, 0x61, 0xd4,
		0x85, 0xa0, 0x26, 0xe7, 0x6d, 0xbc, 0x8c, 0x2b, 0xc3, 0xc0, 0xb2, 0x8c, 0x2c, 0xcb, 0xd0, 0xca,
		0x18, 0x5b, 0x19, 0x83, 0x2b, 0x60, 0x74, 0x3e, 0x86, 0x17, 0xf0, 0x40, 0x84, 0x04, 0x20, 0xb9,
		0xb1, 0xeb, 0x3a, 0x98, 0x50, 0xb3, 0xe7, 0x90, 0x07, 0xec, 0x0f, 0x7d, 0x47, 0x70, 0xdc, 0xc0,
		0x1c, 0xdb, 0x2c, 0x59, 0x53, 0x90, 0xec, 0x6c, 0xd1, 0x10, 0xe5, 0xc2, 0xa3, 0x42, 0x88, 0x54,
		0x09, 0x93, 0x2a, 0xa1, 0x52, 0x2e, 0x5c, 0xca, 0x85, 0x4c, 0xa1, 0xb0, 0x89, 0x09, 0x9d, 0xa0,
		0xf0, 0xf1, 0x47, 0x7f, 0xd2, 0xb1, 0xb7, 0x1b, 0x28, 0x10, 0x1f, 0xc4, 0x99, 0x4c, 0x5b, 0x2d,
		0x06, 0x16, 0xa5, 0xd8, 0x27, 0xdc, 0x73, 0x30, 0x16, 0x16, 0x3a, 0xfc, 0x5a, 0x32, 0xcf, 0x2d,
		0xb3, 0xd7, 0x30, 0x3f, 0x74, 0x7e, 0x54, 0x5e, 0x0e, 0xeb, 0xf3, 0xff, 0xbf, 0xf0, 0xa6, 0xf0,
		0x4e, 0x96, 0x1b, 0x67, 0x7f, 0xa2, 0x10, 0xfd, 0xc6, 0xeb, 0x6f, 0x0a, 0x3f, 0x4a, 0x47, 0x95,
		0x5a, 0xf5, 0x45, 0x9c, 0xad, 0x3a, 0x99, 0xb2, 0x95, 0x40, 0xac, 0x43, 0x61, 0x0c, 0x44, 0x3e,
		0x36, 0xc2, 0x14, 0x33, 0x39, 0x3d, 0xa9, 0x9d, 0xd4, 0x51, 0x6b, 0xe2, 0x73, 0xa2, 0x8f, 0xd6,
		0x33, 0xf6, 0x51, 0x13, 0x77, 0x47, 0xbe, 0x43, 0x9f, 0xd1, 0x61, 0xeb, 0x63, 0xb3, 0x30, 0xf3,
		0xe7, 0x1b, 0xcf, 0xc6, 0x6e, 0xe8, 0xc3, 0xf7, 0x3c, 0x3f, 0x6a, 0xca, 0xe7, 0x0b, 0x05, 0xc4,
		0x9e, 0xff, 0xc7, 0xa6, 0xd9, 0xba, 0x99, 0x7a, 0xfe, 0x6e, 0x40, 0x07, 0x71, 0x46, 0xe4, 0x22,
		0x32, 0x60, 0x1f, 0x94, 0x08, 0xa0, 0x6a, 0xfd, 0xad, 0x32, 0x2e, 0x93, 0x99, 0x4a, 0x5f, 0x19,
		0xc7, 0xc9, 0xf9, 0xb6, 0x4b, 0xbf, 0xf4, 0xcb, 0xc1, 0x66, 0xee, 0x16, 0xd4, 0x50, 0x99, 0x4c,
		0xeb, 0x71, 0x86, 0xf2, 0x10, 0xd3, 0x19, 0x02, 0xa4, 0x04, 0x48, 0xb9, 0xfb, 0x90, 0x92, 0x23,
		0x3a, 0x97, 0x01, 0x2c, 0xed, 0x7b, 0x81, 0x12, 0x2c, 0x7a, 0x2e, 0xb1, 0x06, 0xd7, 0xec, 0xc2,
		0x0c, 0xc0, 0x8b, 0x33, 0x34, 0x2d, 0xdb, 0xf6, 0x71, 0x10, 0xa8, 0x00, 0x09, 0x0a, 0x28, 0xa4,
		0x96, 0x52, 0xea, 0x28, 0xb6, 0x84, 0x72, 0x8f, 0x55, 0x85, 0xb4, 0x53, 0xe9, 0xf1, 0x68, 0xf3,
		0x80, 0x16, 0xdd, 0x95, 0xc8, 0x3b, 0xe9, 0xfc, 0xfc, 0x5a, 0x36, 0xcf, 0x3b, 0xf1, 0xc7, 0x72,
		0xf4, 0x9f, 0xf8, 0x73, 0xe5, 0x6b, 0xc9, 0xac, 0x4e, 0x3e, 0xd7, 0xbe, 0x96, 0xcc, 0x5a, 0xa7,
		0xd0, 0x6e, 0x1f, 0x17, 0x7e, 0x9c, 0xbc, 0xf0, 0xdf, 0x78, 0xf8, 0xf7, 0xe3, 0x5f, 0x0b, 0xef,
		0x0c, 0x65, 0x2f, 0xd0, 0x51, 0xb2, 0xd2, 0xcb, 0x51, 0x8e, 0x19, 0xf4, 0x14, 0x18, 0xf4, 0xb0,
		0xfe, 0x73, 0xd6, 0x4b, 0x2f, 0x1d, 0x55, 0x5f, 0x0a, 0xf5, 0xc2, 0xe1, 0xeb, 0xef, 0xea, 0xa1,
		0x5b, 0x5d, 0x7b, 0x39, 0x3c, 0x5c, 0xf2, 0x97, 0x77, 0xcb, 0xd6, 0x28, 0xfc, 0x3c, 0x3c, 0x3c,
		0x1c, 0xb3, 0xe6, 0x1c, 0xbb, 0x7e, 0x2d, 0x95, 0x3b, 0xef, 0xa2, 0x8f, 0xf1, 0xbf, 0x09, 0xc3,
		0x33, 0x5d, 0x5c, 0x28, 0x1c, 0xfe, 0xfd, 0x6b, 0xc3, 0xfc, 0xb7, 0x65, 0xfe, 0x15, 0x49, 0x43,
		0xf2, 0xb1, 0xdd, 0x36, 0xdb, 0xed, 0xe3, 0x6f, 0xff, 0x57, 0xec, 0xc8, 0x47, 0x19, 0x96, 0x89,
		0xf1, 0xff, 0xd6, 0x3b, 0xbf, 0xd6, 0x0b, 0x3f, 0x4e, 0x5f, 0x26, 0x9f, 0xa3, 0x7f, 0x0b, 0x3f,
		0x0f, 0x8f, 0xdf, 0xb4, 0xdb, 0xc7, 0xc7, 0x6f, 0x0a, 0xf1, 0x1b, 0x8f, 0xaf, 0x7b, 0x13, 0xff,
		0xf5, 0x5d, 0xbd, 0xbe, 0xf0, 0x55, 0x5e, 0xe5, 0xf4, 0x60, 0xb3, 0xcf, 0x21, 0xa9, 0x27, 0x14,
		0x9a, 0xfc, 0x10, 0x06, 0x99, 0x84, 0x6f, 0xc6, 0x4c, 0x16, 0xca, 0x80, 0xb7, 0x18, 0x3e, 0x43,
		0x95, 0x2a, 0x33, 0xde, 0x76, 0xe5, 0xa2, 0x49, 0xa7, 0xa1, 0x62, 0x61, 0x56, 0x35, 0xc8, 0x75,
		0x35, 0x23, 0xc9, 0x0e, 0x78, 0xd5, 0x6c, 0x4b, 0x91, 0xec, 0x50, 0xdd, 0xf4, 0x2d, 0xab, 0x9d,
		0xc0, 0xa6, 0x29, 0x53, 0xac, 0x8a, 0xd4, 0xb3, 0x02, 0x0d, 0xa4, 0x1a, 0x86, 0x18, 0xa1, 0xc5,
		0xb4, 0xcc, 0xbf, 0x1a, 0xe6, 0xbf, 0x4b, 0xe6, 0xf9, 0xb7, 0xce, 0xcc, 0xff, 0x69, 0xb7, 0xcd,
		0x6f, 0x9d, 0x10, 0x74, 0x9c, 0x96, 0x5f, 0x0a, 0xef, 0xa6, 0xdf, 0x77, 0x42, 0xb8, 0xf0, 0x46,
		0xe4, 0xae, 0x77, 0x85, 0x9f, 0xed, 0xf6, 0xb1, 0xaa, 0x18, 0xea, 0xdc, 0x6f, 0xb6, 0xdb, 0xc7,
		0x9d, 0x5f, 0x8d, 0x4d, 0x5b, 0x50, 0x48, 0x78, 0xe4, 0x03, 0x40, 0x64, 0x55, 0xc1, 0xd8, 0x88,
		0x7d, 0x97, 0x36, 0xd9, 0x7c, 0xa8, 0xbd, 0x19, 0x3e, 0xd9, 0xc7, 0x66, 0x43, 0x5d, 0xa8, 0x04,
		0xf2, 0x29, 0x1b, 0xaa, 0x8b, 0xcd, 0x2f, 0x57, 0x41, 0xba, 0x46, 0xbd, 0x46, 0x36, 0x98, 0xaa,
		0x86, 0x53, 0x55, 0x1e, 0x43, 0x21, 0xf1, 0xca, 0x35, 0x78, 0x5a, 0xb0, 0x56, 0x2e, 0x52, 0x2e,
		0x95, 0x4f, 0xcb, 0x62, 0x1c, 0xd2, 0x81, 0x54, 0x13, 0xa4, 0x9a, 0x84, 0x54, 0xf2, 0x7e, 0x56,
		0x2f, 0x85, 0xb2, 0x6e, 0x92, 0xd1, 0xe0, 0x9e, 0xa9, 0xdd, 0x3f, 0x4d, 0x7c, 0x4e, 0x25, 0x96,
		0x10, 0x3b, 0xbe, 0x47, 0x03, 0xf2, 0x53, 0x19, 0xff, 0x10, 0x6d, 0xa8, 0xcb, 0xdc, 0x75, 0x56,
		0xef, 0x32, 0x2b, 0x88, 0x6f, 0x28, 0x8d, 0x6b, 0x24, 0x5b, 0x71, 0x5a, 0xab, 0x9d, 0xd4, 0xf6,
		0x6f, 0x3b, 0xc0, 0x1d, 0x05, 0x77, 0x14, 0xdc, 0x51, 0x70, 0x47, 0xc1, 0x1d, 0x05, 0x77, 0x34,
		0x23, 0x77, 0x34, 0xc0, 0xfe, 0x23, 0xf6, 0xd5, 0x36, 0xac, 0x2c, 0x59, 0x13, 0x5c, 0x3e, 0x70,
		0xf9, 0xc0, 0xe5, 0x63, 0xe6, 0x15, 0x68, 0x58, 0x51, 0xf2, 0x13, 0xd0, 0xb0, 0xb2, 0x35, 0x80,
		0x39, 0x27, 0x9d, 0x0b, 0x21, 0xd6, 0x68, 0x46, 0xe6, 0x0b, 0xda, 0x55, 0xf6, 0xa6, 0x5d, 0x65,
		0xf9, 0xa6, 0x03, 0xdc, 0xd4, 0x07, 0x37, 0xe3, 0x01, 0xa6, 0xf4, 0x59, 0x19, 0xd6, 0x4c, 0x16,
		0x04, 0xa0, 0x09, 0x40, 0x13, 0x80, 0x26, 0x33, 0xaf, 0x58, 0xf6, 0xc0, 0x21, 0x66, 0x40, 0x7d,
		0x87, 0x3c, 0x6c, 0x1a, 0x65, 0x2a, 0x2a, 0xb7, 0x84, 0xf4, 0x42, 0x6e, 0xe2, 0xd9, 0x79, 0x4d,
		0x2f, 0x70, 0x9f, 0xa5, 0xb1, 0x0b, 0x9b, 0x01, 0xc9, 0x05, 0xf0, 0x95, 0x34, 0xc1, 0xe6, 0x6b,
		0x39, 0xf4, 0x05, 0x8e, 0xd2, 0xd6, 0x39, 0x4a, 0xc9, 0x8e, 0x83, 0x97, 0xa4, 0xf4, 0x0e, 0xde,
		0x41, 0x55, 0x0d, 0x42, 0x3c, 0x1a, 0x25, 0x77, 0xc4, 0xe6, 0x55, 0x05, 0xdd, 0x3e, 0x1e, 0x58,
		0x43, 0x2b, 0xc2, 0x5d, 0x46, 0xd1, 0xc1, 0xb4, 0x67, 0x86, 0xdb, 0x5d, 0x8c, 0xfe, 0x89, 0x0f,
		0x2c, 0x29, 0x26, 0xa3, 0x2b, 0x8b, 0x36, 0x75, 0x83, 0xa2, 0xc0, 0xb8, 0xb6, 0xf8, 0xb7, 0xa8,
		0x3f, 0xea, 0x52, 0x32, 0x56, 0x64, 0xd7, 0x57, 0xad, 0x0f, 0x4d, 0x32, 0x18, 0x7e, 0x8b, 0xfe,
		0x89, 0x13, 0x50, 0xdf, 0x2e, 0xc3, 0xa5, 0x0f, 0xf4, 0x90, 0x57, 0xed, 0x88, 0x3c, 0x09, 0x43,
		0x63, 0x38, 0x3d, 0xb3, 0x87, 0x2d, 0x3a, 0xf2, 0xf9, 0x2d, 0x8b, 0xc4, 0xf4, 0x39, 0x1a, 0x4a,
		0xf0, 0x86, 0xc7, 0xcf, 0xcd, 0xbc, 0x79, 0x9e, 0x46, 0xd0, 0xc5, 0xa4, 0xd1, 0x2d, 0xda, 0xcc,
		0x57, 0x73, 0x14, 0x48, 0x4a, 0x80, 0x14, 0x09, 0x56, 0xca, 0x87, 0x49, 0xba, 0x6c, 0x7d, 0x6c,
		0x7e, 0xb9, 0xbc, 0xbb, 0xf4, 0x06, 0x96, 0x43, 0x36, 0xcc, 0xd8, 0xb2, 0xd0, 0x42, 0x0f, 0x5f,
		0xe7, 0x71, 0x9f, 0xf2, 0x23, 0x65, 0x4a, 0xed, 0x81, 0xa0, 0x21, 0x16, 0x31, 0xc0, 0x86, 0xa2,
		0xc1, 0xd8, 0x0c, 0xaf, 0x66, 0x04, 0x41, 0x9f, 0x7f, 0xf0, 0x70, 0x78, 0x13, 0xcc, 0x1d, 0xce,
		0x2c, 0x4e, 0xba, 0xc7, 0x73, 0x87, 0x79, 0xd8, 0x53, 0x82, 0x4d, 0x17, 0xc2, 0x9c, 0x30, 0x75,
		0x58, 0x3f, 0x5b, 0xeb, 0x35, 0x8d, 0x3b, 0x35, 0x75, 0x18, 0x46, 0xc0, 0x41, 0xee, 0x2c, 0xe3,
		0x50, 0x15, 0x8c, 0x80, 0x83, 0x11, 0x70, 0x9a, 0x42, 0xdc, 0x30, 0x02, 0x4e, 0x9c, 0x72, 0x30,
		0x02, 0x0e, 0x46, 0xc0, 0xc1, 0x08, 0xb8, 0xbc, 0x33, 0x28, 0x8c, 0x80, 0x63, 0x12, 0x63, 0x18,
		0x01, 0xa7, 0xf7, 0x39, 0x60, 0x04, 0x5c, 0xea, 0x5a, 0x30, 0x02, 0x4e, 0xc9, 0xba, 0x30, 0x02,
		0x0e, 0x46, 0xc0, 0x65, 0xb9, 0x69, 0x30, 0x02, 0x6e, 0x9d, 0x61, 0x85, 0x11, 0x70, 0xca, 0x2c,
		0x28, 0x94, 0xc5, 0xe5, 0x03, 0x40, 0x6c, 0xa4, 0x3b, 0xba, 0x56, 0x3b, 0xaf, 0xd4, 0xe3, 0x54,
		0x2a, 0x46, 0xcd, 0x3e, 0x76, 0xdd, 0xd7, 0x89, 0xd4, 0x49, 0x16, 0x35, 0x5a, 0x99, 0x3f, 0x91,
		0xda, 0x6c, 0xfe, 0x36, 0xdb, 0x0b, 0xdd, 0x6c, 0xfe, 0x06, 0x1d, 0xf6, 0x3b, 0xd6, 0x61, 0xbf,
		0x41, 0x1e, 0x82, 0xd2, 0x3d, 0xf5, 0xda, 0x76, 0x57, 0xc6, 0xbb, 0xd5, 0x60, 0xba, 0x9b, 0xc4,
		0xf6, 0x41, 0x16, 0x49, 0x44, 0xff, 0xc2, 0x74, 0x37, 0x98, 0xee, 0x86, 0xa0, 0xfd, 0x0a, 0xa6,
		0xbb, 0xed, 0xe8, 0x76, 0x80, 0xa7, 0x09, 0x9e, 0x26, 0x78, 0x9a, 0xe0, 0x69, 0x82, 0xa7, 0x09,
		0x9e, 0xa6, 0x02, 0x4f, 0x73, 0x14, 0x60, 0x7f, 0xdc, 0x4c, 0x25, 0xe9, 0x6d, 0x26, 0x2b, 0x81,
		0xeb, 0x06, 0xae, 0x1b, 0xb8, 0x6e, 0xec, 0xbc, 0xa2, 0x6e, 0x6c, 0x06, 0x60, 0x34, 0xc0, 0x68,
		0x80, 0xd1, 0x00, 0xa3, 0x01, 0x46, 0xcb, 0x2f, 0x46, 0xdb, 0xa5, 0x46, 0xfe, 0x20, 0xe8, 0x17,
		0xf9, 0xfb, 0x9f, 0x10, 0x63, 0x1b, 0x7f, 0x33, 0xe8, 0x43, 0x17, 0xbf, 0x52, 0x53, 0x37, 0xdb,
		0xb4, 0x06, 0x5d, 0xfc, 0x2b, 0x40, 0x68, 0x44, 0x1a, 0xe8, 0xe2, 0xe7, 0x41, 0x49, 0x59, 0x1a,
		0x9c, 0x20, 0x36, 0x38, 0xd0, 0xaf, 0xbf, 0x16, 0x73, 0x6c, 0x6e, 0x47, 0xa0, 0x33, 0x5f, 0xd2,
		0xa2, 0x66, 0xd9, 0x98, 0x4f, 0xdd, 0x80, 0xbf, 0x31, 0x9f, 0x7d, 0x70, 0x0f, 0x34, 0xe6, 0x43,
		0x63, 0xfe, 0xcc, 0x73, 0x70, 0x37, 0xe6, 0xf3, 0xb0, 0xa7, 0x04, 0x9b, 0x2e, 0x04, 0x52, 0xa0,
		0x31, 0x3f, 0xbb, 0xd0, 0x22, 0x34, 0xe6, 0xa7, 0xde, 0xd8, 0x75, 0x1d, 0x4c, 0xa8, 0xda, 0xd3,
		0x55, 0x96, 0xac, 0x09, 0x71, 0x7b, 0x88, 0xdb, 0x43, 0xdc, 0x9e, 0xc7, 0xbe, 0xc0, 0xe9, 0x2a,
		0xf2, 0x3f, 0x01, 0xa7, 0xab, 0xa8, 0x73, 0xe3, 0xe5, 0xdd, 0xfa, 0xb5, 0x6e, 0x7e, 0x4e, 0xe6,
		0xc7, 0xde, 0x59, 0xbe, 0x35, 0x08, 0x2e, 0x22, 0x03, 0x06, 0xe7, 0xab, 0xec, 0xcd, 0xd8, 0xe0,
		0x55, 0xdb, 0x0e, 0x29, 0x07, 0xf5, 0x3a, 0x0d, 0x66, 0x41, 0x01, 0xa4, 0x04, 0x48, 0xc9, 0xf8,
		0xdc, 0x30, 0x0b, 0x6a, 0xc5, 0xdb, 0xc0, 0x2c, 0xa8, 0x6c, 0x28, 0xa5, 0x8e, 0x62, 0x4b, 0x28,
		0x07, 0xb3, 0xa0, 0x60, 0x16, 0x14, 0xcc, 0x82, 0xca, 0x3b, 0x83, 0xc2, 0x2c, 0x28, 0x26, 0x31,
		0x86, 0x59, 0x50, 0x7a, 0x9f, 0x03, 0x66, 0x41, 0xa5, 0xae, 0x05, 0xb3, 0xa0, 0x94, 0xac, 0x0b,
		0xb3, 0xa0, 0x60, 0x16, 0x54, 0x96, 0x9b, 0x06, 0xb3, 0xa0, 0xd6, 0x19, 0x56, 0x98, 0x05, 0xa5,
		0xcc, 0x82, 0x42, 0xc2, 0x23, 0x1f, 0x00, 0x62, 0x23, 0x95, 0xfb, 0x9b, 0x0d, 0xb5, 0x37, 0xc3,
		0x27, 0xfb, 0xd8, 0x84, 0x7e, 0x90, 0x1d, 0xeb, 0x07, 0xc9, 0x15, 0x57, 0x41, 0xba, 0x46, 0xbd,
		0x46, 0xde, 0x95, 0x79, 0x51, 0xe5, 0x12, 0x0c, 0x8c, 0x92, 0xd8, 0x3f, 0x48, 0x35, 0x89, 0xa8,
		0x64, 0x18, 0x18, 0x05, 0x03, 0xa3, 0x10, 0x0c, 0x8c, 0x82, 0x81, 0x51, 0x3b, 0xba, 0x1d, 0xe0,
		0x8e, 0x82, 0x3b, 0x0a, 0xee, 0x28, 0xb8, 0xa3, 0xe0, 0x8e, 0x82, 0x3b, 0x9a, 0x91, 0x3b, 0x1a,
		0x60, 0xff, 0x11, 0xfb, 0x6a, 0x1b, 0x56, 0x96, 0xac, 0x09, 0x2e, 0x1f, 0xb8, 0x7c, 0xe0, 0xf2,
		0x31, 0xf3, 0x0a, 0x34, 0xac, 0x28, 0xf9, 0x09, 0x68, 0x58, 0xd9, 0x1a, 0xc0, 0x9c, 0x93, 0xce,
		0x85, 0x10, 0x6b, 0x34, 0x23, 0xf3, 0x05, 0xed, 0x2a, 0x7b, 0xd3, 0xae, 0xb2, 0x7c, 0xd3, 0x01,
		0x6e, 0xea, 0x83, 0x9b, 0x8e, 0x8d, 0x09, 0x75, 0xe8, 0xb3, 0x32, 0xac, 0x99, 0x2c, 0x08, 0x40,
		0x13, 0x80, 0x26, 0x00, 0x4d, 0x66, 0x5e, 0xb1, 0xec, 0x81, 0x43, 0x4c, 0x85, 0x73, 0x4d, 0x25,
		0xd6, 0x50, 0x54, 0x6e, 0x09, 0xe9, 0x85, 0xdc, 0xc4, 0xb3, 0xf3, 0x9a, 0x5e, 0xa8, 0xd4, 0x20,
		0xb9, 0x90, 0x73, 0x34, 0x02, 0xbe, 0xd2, 0x16, 0xf9, 0x4a, 0xd7, 0x72, 0xe8, 0x0b, 0x1c, 0xa5,
		0xad, 0x73, 0x94, 0x92, 0x1d, 0x07, 0x2f, 0x49, 0xe9, 0x1d, 0x39, 0x9f, 0x22, 0x4c, 0xdd, 0xa0,
		0xc8, 0x3f, 0xac, 0x0d, 0x31, 0x4e, 0x11, 0x6e, 0xb9, 0x01, 0x4c, 0x11, 0x56, 0x6a, 0x46, 0x66,
		0x03, 0xca, 0x30, 0x45, 0x78, 0xb9, 0x7e, 0x8d, 0x49, 0x03, 0x53, 0x84, 0xb7, 0x0c, 0x81, 0x7c,
		0x6c, 0xb6, 0x2e, 0xee, 0x60, 0xb4, 0x70, 0xde, 0x61, 0xc3, 0xec, 0x36, 0xc1, 0xbc, 0x61, 0x49,
		0xdb, 0x9b, 0xe5, 0xbc, 0xe1, 0x91, 0x3d, 0xe4, 0x9f, 0x37, 0x1c, 0xde, 0x04, 0xf3, 0x86, 0x33,
		0x8b, 0x90, 0xee, 0xf1, 0xbc, 0x61, 0x1e, 0xf6, 0x94, 0x60, 0xd3, 0x85, 0x00, 0x27, 0xcc, 0x1b,
		0xd6, 0xcf, 0xd6, 0x7a, 0x0d, 0xe3, 0x4e, 0xcd, 0x1b, 0x86, 0xe1, 0x6f, 0x90, 0x35, 0xcb, 0x38,
		0x48, 0x05, 0xc3, 0xdf, 0x94, 0xf0, 0x9b, 0x92, 0x41, 0x67, 0x3b, 0x3a, 0x02, 0x4e, 0xe9, 0x20,
		0x33, 0xa5, 0x23, 0x61, 0x34, 0x0c, 0x64, 0xd8, 0xbe, 0x81, 0x65, 0xbb, 0x32, 0x78, 0x48, 0xf1,
		0x40, 0xb2, 0xbc, 0x33, 0x1a, 0x0c, 0x1e, 0x5b, 0x2b, 0x86, 0xf9, 0x1b, 0x38, 0x06, 0xe3, 0x49,
		0x78, 0xd7, 0xda, 0xa9, 0x7e, 0x30, 0xb6, 0x46, 0x1d, 0xc8, 0xb9, 0xe6, 0xa8, 0xd9, 0x8a, 0x71,
		0xcb, 0x20, 0x69, 0xaa, 0x5e, 0x97, 0xec, 0xcc, 0x60, 0x8d, 0xd3, 0x0a, 0x8c, 0xd5, 0x00, 0x27,
		0x1e, 0x9c, 0x78, 0xdd, 0x0e, 0x38, 0x8c, 0xd5, 0x58, 0x8c, 0x90, 0x40, 0xdd, 0x2b, 0x8c, 0xd5,
		0xd8, 0xbd, 0xed, 0x00, 0x37, 0x0a, 0xdc, 0x28, 0x70, 0xa3, 0xc0, 0x8d, 0x02, 0x37, 0x8a, 0xc5,
		0x8d, 0x8a, 0xf0, 0xaa, 0xe9, 0x4e, 0x9a, 0x71, 0x64, 0xfd, 0xa9, 0xb9, 0xe5, 0xc0, 0x45, 0x01,
		0x17, 0x05, 0x5c, 0x14, 0x66, 0x5e, 0x19, 0x39, 0x84, 0x9e, 0x29, 0x70, 0x4e, 0x6a, 0xe0, 0x9c,
		0x80, 0x73, 0x92, 0x77, 0xe7, 0x04, 0x9a, 0xf2, 0xc0, 0x35, 0xd9, 0x66, 0xd7, 0xa4, 0x76, 0x56,
		0xad, 0xa3, 0x0b, 0x0f, 0x3f, 0x39, 0x01, 0x0d, 0x1f, 0x10, 0xdd, 0x63, 0xfa, 0x1d, 0x63, 0x82,
		0x7e, 0xc7, 0x7e, 0xe0, 0x78, 0x04, 0x95, 0x8f, 0x92, 0x8f, 0x95, 0xa3, 0x10, 0xe6, 0x5a, 0xc4,
		0x4e, 0xbe, 0x39, 0x41, 0x5e, 0x2f, 0xaa, 0xb9, 0xbe, 0x26, 0x14, 0xfb, 0x04, 0x53, 0x33, 0xa0,
		0x16, 0xb1, 0x2d, 0xdf, 0x0e, 0xaf, 0x5c, 0x82, 0x9b, 0x3f, 0xf8, 0xd6, 0x00, 0x87, 0x5f, 0x4e,
		0x11, 0xf3, 0xc5, 0xa7, 0x9b, 0x9b, 0x2f, 0xb7, 0xd7, 0xad, 0x7f, 0x2d, 0x03, 0xcd, 0x37, 0x56,
		0xf0, 0x27, 0x38, 0x39, 0xba, 0x9c, 0x9c, 0x6d, 0xd8, 0x7c, 0x70, 0x97, 0x94, 0xde, 0x91, 0xf3,
		0x56, 0xbd, 0x91, 0x3d, 0x2c, 0xf2, 0xd7, 0x39, 0x23, 0xc6, 0x56, 0xbd, 0x2f, 0xf6, 0x70, 0xf7,
		0x5b, 0xf5, 0x36, 0xd6, 0x5e, 0x75, 0x52, 0x2d, 0xbf, 0x9d, 0xed, 0xdb, 0xb9, 0xb1, 0x86, 0x43,
		0x87, 0x3c, 0x04, 0x2b, 0x1a, 0x73, 0x42, 0x1d, 0xc0, 0x10, 0x51, 0x79, 0xac, 0x98, 0xad, 0x9b,
		0x48, 0x33, 0x7c, 0xb9, 0x1c, 0xb7, 0xe4, 0xc4, 0x53, 0x3e, 0x4f, 0xaa, 0xe5, 0xf3, 0x3a, 0x6a,
		0xe1, 0x27, 0x3a, 0xb2, 0x5c, 0x74, 0xe1, 0x91, 0x47, 0x4c, 0xa2, 0x79, 0xa1, 0xd1, 0xef, 0x4d,
		0x1f, 0x63, 0x1c, 0x77, 0xc1, 0xf1, 0x1c, 0xd1, 0xd6, 0xe7, 0xc6, 0x6d, 0xf3, 0xee, 0xd3, 0xe7,
		0x96, 0xd9, 0xb8, 0xbc, 0xfc, 0x7c, 0xd5, 0x6c, 0x46, 0x8a, 0x27, 0x61, 0xc0, 0xf8, 0x07, 0xbe,
		0xd8, 0xc3, 0xeb, 0xe1, 0x63, 0x95, 0xf7, 0xfa, 0xbf, 0x38, 0x6f, 0x38, 0xe5, 0xbd, 0xfe, 0x2f,
		0xe8, 0x19, 0x5b, 0x1d, 0xaf, 0x03, 0xde, 0xd3, 0xcc, 0x7b, 0xd0, 0x08, 0x27, 0x69, 0xd9, 0x94,
		0x35, 0xc2, 0x1d, 0x48, 0xbc, 0xb7, 0xd1, 0x18, 0x3d, 0x84, 0x4c, 0x8f, 0x6d, 0x26, 0xfb, 0xc0,
		0xd9, 0x4a, 0x17, 0xbd, 0x7c, 0x3d, 0x21, 0x43, 0x7d, 0x4c, 0x86, 0xf8, 0xf3, 0x84, 0x16, 0x9c,
		0xcd, 0x76, 0x65, 0x68, 0xb6, 0x83, 0x66, 0x3b, 0x81, 0x66, 0xbb, 0x20, 0xe8, 0x8b, 0x37, 0xdb,
		0x85, 0x37, 0x8b, 0x35, 0xdb, 0x55, 0xa1, 0xd9, 0x2e, 0xbb, 0x38, 0xfe, 0xfe, 0x34, 0xdb, 0x29,
		0x08, 0x47, 0x29, 0x08, 0x43, 0x29, 0x48, 0x0f, 0x84, 0xf8, 0xa9, 0x56, 0x3b, 0xaf, 0xd4, 0xe3,
		0x96, 0x7e, 0x8c, 0x9a, 0x7d, 0xec, 0xba, 0xaf, 0x1b, 0xfa, 0x27, 0xc0, 0x2d, 0x82, 0x62, 0xfc,
		0x69, 0xd8, 0x66, 0xf3, 0xb7, 0xd9, 0x86, 0xfe, 0x66, 0xf3, 0x37, 0xe1, 0xa1, 0x0b, 0xaa, 0x63,
		0x48, 0x3a, 0x62, 0x47, 0x7a, 0xd3, 0x58, 0x9b, 0xdd, 0xb1, 0xac, 0xf3, 0x67, 0x07, 0x7a, 0x03,
		0x3d, 0x30, 0xfd, 0x87, 0xc3, 0x04, 0xc3, 0xf4, 0x9f, 0x15, 0x06, 0x2a, 0x22, 0xcd, 0xb6, 0x39,
		0x64, 0x2a, 0x26, 0x7c, 0x80, 0x3f, 0x02, 0xfe, 0xc8, 0x96, 0xfa, 0x23, 0xd4, 0x0d, 0xc4, 0xfd,
		0x11, 0xfe, 0xf9, 0x75, 0xe0, 0x8f, 0x80, 0x3f, 0x02, 0xfe, 0x08, 0x9b, 0x3f, 0xb2, 0xf5, 0x93,
		0xe1, 0xc0, 0x49, 0xd9, 0x85, 0xc9, 0x71, 0xe0, 0xb9, 0xec, 0x86, 0xe7, 0x02, 0x73, 0x4b, 0x57,
		0x8a, 0x69, 0xde, 0xe6, 0x96, 0x82, 0xe7, 0x02, 0x9e, 0x0b, 0x78, 0x2e, 0x29, 0x37, 0xd8, 0x52,
		0xae, 0x8b, 0x0d, 0xbe, 0x0b, 0xf8, 0x2e, 0xe0, 0xbb, 0xec, 0xae, 0xef, 0x72, 0xd9, 0xfa, 0xd8,
		0x4c, 0x0a, 0x64, 0xc0, 0x79, 0xd9, 0x5a, 0xe7, 0x65, 0x7e, 0x1f, 0xc1, 0x7b, 0x01, 0xef, 0x05,
		0xbc, 0x97, 0xfd, 0xf0, 0x5e, 0xd6, 0x5e, 0x91, 0x32, 0xa2, 0x47, 0x84, 0xc3, 0x05, 0xac, 0xa7,
		0x80, 0x67, 0x21, 0xd0, 0xc8, 0x1d, 0xaa, 0xc6, 0xc6, 0x70, 0xe8, 0x3a, 0xdd, 0xa8, 0x22, 0x30,
		0x60, 0x69, 0xec, 0x9e, 0x14, 0x86, 0x6a, 0x68, 0xda, 0x57, 0xe1, 0xec, 0x88, 0x5a, 0x40, 0xb5,
		0xfe, 0x4e, 0x5e, 0xf7, 0x42, 0xb5, 0x55, 0x38, 0x90, 0x93, 0xd9, 0xd4, 0xe2, 0x4d, 0xbe, 0x62,
		0x55, 0xce, 0x22, 0xd5, 0xf5, 0xd4, 0x58, 0xfd, 0x6e, 0xcb, 0xff, 0xb2, 0xe2, 0x5d, 0x42, 0xde,
		0x0c, 0x1f, 0x26, 0xea, 0xd4, 0x58, 0x71, 0xc9, 0x47, 0x27, 0xa0, 0x0d, 0x4a, 0xd7, 0xbb, 0xa9,
		0xc6, 0x8d, 0x43, 0xae, 0xdc, 0x88, 0x75, 0x52, 0xda, 0x25, 0x8d, 0x1b, 0xeb, 0x69, 0xe6, 0xca,
		0xf2, 0x59, 0xb5, 0x7a, 0xfa, 0xb6, 0x5a, 0x2d, 0xbd, 0x3d, 0x79, 0x5b, 0x3a, 0xaf, 0xd5, 0xca,
		0xa7, 0xe5, 0x35, 0x4d, 0x9c, 0xc6, 0x27, 0xdf, 0xc6, 0x3e, 0xb6, 0xdf, 0x87, 0x4f, 0x4d, 0x46,
		0xae, 0xcb, 0x72, 0xe9, 0x97, 0x00, 0xfb, 0x6b, 0xfb, 0x2d, 0x57, 0x11, 0x87, 0xad, 0x3a, 0x77,
		0xfd, 0xce, 0xa7, 0xc4, 0x90, 0x52, 0xf4, 0x00, 0x63, 0xb0, 0x88, 0xd9, 0xd7, 0xe6, 0xf1, 0xad,
		0x79, 0x7d, 0x69, 0x5e, 0xfd, 0x28, 0xec, 0x2b, 0x0b, 0x2b, 0x43, 0x01, 0x5f, 0x58, 0xae, 0xbc,
		0x9b, 0x35, 0xb8, 0x63, 0x0c, 0x06, 0x01, 0xff, 0x51, 0x29, 0xe1, 0x4d, 0xac, 0x51, 0x26, 0x1c,
		0x74, 0x7d, 0x67, 0x38, 0xd6, 0x55, 0x46, 0xab, 0x8f, 0xd1, 0xc0, 0x7a, 0x72, 0x06, 0xa3, 0x01,
		0x1a, 0xe0, 0x20, 0xb0, 0x1e, 0x30, 0x0a, 0x9c, 0xbf, 0xf0, 0x31, 0xfb, 0x7a, 0xfc, 0x73, 0x0a,
		0x8d, 0xea, 0x59, 0x95, 0x4d, 0xc5, 0x77, 0xf8, 0x22, 0xa9, 0x25, 0x88, 0xa4, 0x42, 0x24, 0x55,
		0x60, 0x68, 0xc6, 0x74, 0x48, 0x06, 0x09, 0xe5, 0x82, 0x63, 0xb3, 0x04, 0x66, 0xe6, 0x8b, 0xcd,
		0xc8, 0x97, 0xf0, 0x1c, 0x31, 0x19, 0x0d, 0xb0, 0x1f, 0xc3, 0x13, 0x01, 0xff, 0x71, 0xf2, 0x8a,
		0x55, 0x81, 0x7b, 0xaf, 0xc8, 0x68, 0x20, 0xee, 0x79, 0xb6, 0xbc, 0x66, 0x7c, 0x98, 0xb8, 0x54,
		0x97, 0x7f, 0x29, 0xde, 0xd8, 0x3f, 0x89, 0xf7, 0x5d, 0x30, 0x7c, 0x22, 0x3c, 0xbc, 0xc5, 0xbb,
		0x26, 0x54, 0xee, 0xe1, 0x27, 0xcf, 0x5d, 0x47, 0xa5, 0x5d, 0x68, 0x5c, 0x96, 0xe0, 0x62, 0x87,
		0xd0, 0x93, 0x8a, 0x04, 0xff, 0x9e, 0x08, 0xdc, 0x2a, 0x37, 0xaf, 0x46, 0x62, 0xdb, 0x55, 0xcc,
		0xa7, 0x49, 0x86, 0xa1, 0x54, 0xcf, 0xaa, 0x92, 0x41, 0x51, 0xd5, 0x43, 0x50, 0xd4, 0x0d, 0x3f,
		0x91, 0x98, 0x40, 0xa3, 0x64, 0xf2, 0xcc, 0x74, 0xe2, 0x4c, 0xb9, 0xfa, 0xb6, 0x7a, 0x76, 0x72,
		0x5a, 0x7d, 0xbb, 0xbb, 0xb4, 0xde, 0xf2, 0x08, 0x72, 0x07, 0x86, 0x01, 0xe4, 0x7c, 0xb6, 0xc8,
		0xcd, 0x4d, 0x13, 0x7a, 0xe9, 0x57, 0x85, 0xe9, 0xf2, 0xbf, 0x75, 0x7b, 0x16, 0x81, 0x7f, 0xd1,
		0x10, 0x81, 0xff, 0xde, 0xc7, 0x44, 0x67, 0xf0, 0x3d, 0x0a, 0x38, 0x3d, 0x96, 0x91, 0xe7, 0xa3,
		0xf8, 0x63, 0xa5, 0x9b, 0xb1, 0x6f, 0x1a, 0xbd, 0xe1, 0xa6, 0x3d, 0xd3, 0xd7, 0x24, 0xc8, 0x5b,
		0xbc, 0x99, 0x33, 0xa6, 0xbb, 0x22, 0x4c, 0xc2, 0xc3, 0x81, 0x1c, 0x36, 0x89, 0x23, 0x60, 0x98,
		0x51, 0x7e, 0x21, 0x7a, 0x3b, 0xbd, 0x71, 0x49, 0x5e, 0xc3, 0xa0, 0x26, 0x34, 0x99, 0x25, 0xfd,
		0x64, 0xb5, 0xe1, 0x01, 0x1f, 0xaf, 0xaf, 0x0c, 0xb5, 0xb3, 0xe5, 0x52, 0x98, 0x72, 0x28, 0x6b,
		0xf6, 0x8a, 0x61, 0x30, 0xd5, 0x72, 0x8a, 0x2c, 0xbe, 0xe7, 0x92, 0x37, 0x31, 0xe2, 0xdf, 0x37,
		0x87, 0x96, 0x6f, 0xad, 0x09, 0xe8, 0x4e, 0x93, 0xfb, 0x73, 0x97, 0xaf, 0xca, 0xd0, 0xac, 0xcd,
		0x00, 0xa4, 0x06, 0x35, 0x59, 0x82, 0x98, 0xac, 0x41, 0x4b, 0x56, 0x49, 0xe2, 0x0e, 0x4a, 0x72,
		0x8b, 0x0d, 0x47, 0xd0, 0x91, 0x2f, 0x1f, 0x96, 0x16, 0xb1, 0x37, 0xc6, 0xac, 0xc3, 0x98, 0xf4,
		0x59, 0x93, 0x57, 0xe3, 0x8c, 0x62, 0x43, 0x8a, 0x27, 0x9f, 0x29, 0x1e, 0xe6, 0xa8, 0xf3, 0x34,
		0xa4, 0x65, 0x63, 0x42, 0x9d, 0x9e, 0xc3, 0x74, 0x68, 0x0c, 0xcf, 0x89, 0x90, 0xc6, 0xc7, 0xc9,
		0xc4, 0x75, 0xe5, 0x40, 0x52, 0x24, 0x32, 0x95, 0x04, 0x49, 0x78, 0x4f, 0x3c, 0x97, 0x8d, 0x85,
		0x88, 0xc7, 0x3e, 0x38, 0xe2, 0x4a, 0x42, 0x71, 0xa4, 0x84, 0x24, 0x27, 0x95, 0xed, 0xa1, 0xc9,
		0xa6, 0xb1, 0xef, 0x1a, 0x7b, 0x44, 0x3c, 0xea, 0xf4, 0x9e, 0xcd, 0x9e, 0xe3, 0x52, 0xec, 0x9b,
		0x43, 0xdf, 0xeb, 0x39, 0x2e, 0x8f, 0x76, 0x5e, 0x7a, 0x3b, 0xa8, 0x6b, 0x50, 0xd7, 0x33, 0xb4,
		0x76, 0xb1, 0xd5, 0xf3, 0x71, 0x8f, 0x47, 0x57, 0x33, 0x04, 0x83, 0x8d, 0xbb, 0x09, 0x84, 0x8d,
		0x80, 0xeb, 0x52, 0x4e, 0x2c, 0x46, 0xe8, 0x21, 0xf3, 0x60, 0x84, 0x40, 0xa1, 0xab, 0x68, 0x48,
		0x22, 0x7a, 0xed, 0xb1, 0xcb, 0x32, 0x7e, 0xf9, 0x8c, 0xe3, 0x12, 0xc2, 0xb5, 0xad, 0x1a, 0xa2,
		0x13, 0xcb, 0xa8, 0x91, 0xbd, 0x9a, 0x3e, 0xda, 0xde, 0x82, 0xd1, 0xe3, 0xd5, 0x5e, 0xf0, 0xed,
		0xa7, 0xd6, 0xf5, 0x87, 0xeb, 0x8b, 0x46, 0xeb, 0xfa, 0xd3, 0x6d, 0xe2, 0x0b, 0xdf, 0x46, 0x52,
		0xf7, 0x21, 0xa2, 0xf4, 0x5d, 0x2c, 0x73, 0xb7, 0xe9, 0x80, 0x5d, 0x35, 0x0b, 0x6e, 0x6d, 0x4d,
		0xa8, 0x2a, 0x72, 0x6f, 0xa6, 0x5e, 0x64, 0x6b, 0x58, 0x92, 0x35, 0xce, 0x05, 0x3c, 0xa9, 0x92,
		0xde, 0x3b, 0x81, 0x8f, 0x53, 0x02, 0x51, 0x0b, 0x0c, 0xbe, 0x36, 0x12, 0xf5, 0x1a, 0xe6, 0xd4,
		0x00, 0x01, 0x6f, 0x23, 0x02, 0x66, 0xae, 0x49, 0xa5, 0xc1, 0x80, 0xbf, 0x26, 0x35, 0xbc, 0x89,
		0xaf, 0x7a, 0xb3, 0x0a, 0xd5, 0x9b, 0x50, 0xbd, 0x29, 0x32, 0xc1, 0x2b, 0x18, 0x48, 0x4c, 0xf0,
		0x0a, 0x06, 0x82, 0x5d, 0xf0, 0x65, 0xe8, 0x82, 0xd7, 0xcf, 0xd6, 0xca, 0xd8, 0x5b, 0x01, 0x9b,
		0xf3, 0xb1, 0xbb, 0x40, 0x24, 0x51, 0x88, 0xfd, 0x93, 0x1b, 0x83, 0x71, 0x4f, 0xb2, 0xe9, 0xe2,
		0x47, 0xec, 0xca, 0x9f, 0xb6, 0xf9, 0x6a, 0x3d, 0x38, 0x6e, 0x13, 0x8e, 0xdb, 0xcc, 0x50, 0xc8,
		0xc4, 0x84, 0x4d, 0x50, 0xe8, 0x66, 0x42, 0xf9, 0xc4, 0xb6, 0xa8, 0xe7, 0x3f, 0xf3, 0xeb, 0x77,
		0xfe, 0xc0, 0x62, 0x36, 0x12, 0x88, 0x24, 0x6b, 0xf8, 0x93, 0x35, 0xa4, 0x6a, 0xf9, 0xa7, 0xd4,
		0x51, 0x51, 0xd3, 0x9f, 0xac, 0x56, 0x8e, 0x83, 0xf7, 0xa6, 0x35, 0xa2, 0x7d, 0x93, 0x78, 0xe6,
		0xd0, 0x77, 0x1e, 0x55, 0x1c, 0x4c, 0x57, 0x09, 0xd7, 0x55, 0xbd, 0xe8, 0x49, 0xb2, 0x68, 0xb4,
		0xa2, 0xdc, 0x01, 0x68, 0x47, 0xb2, 0xdb, 0x20, 0xdb, 0x9a, 0x90, 0x2c, 0x35, 0x47, 0xa6, 0x3a,
		0xaa, 0x1c, 0x29, 0x5a, 0x72, 0xbc, 0xde, 0x89, 0x82, 0xf5, 0x5e, 0x73, 0x48, 0x1d, 0x95, 0x37,
		0x74, 0xfc, 0xdc, 0x0b, 0x1c, 0x96, 0x99, 0x87, 0x73, 0xfc, 0x39, 0x0a, 0xa4, 0xee, 0xa2, 0x48,
		0xc8, 0x64, 0xe0, 0xcb, 0x47, 0x49, 0x4d, 0xac, 0x1a, 0x0b, 0xa8, 0x0c, 0xd9, 0x65, 0x06, 0x0f,
		0x32, 0x08, 0xf1, 0x31, 0x6f, 0x25, 0x1c, 0x64, 0xa9, 0x5e, 0xf7, 0x4c, 0x81, 0x0b, 0x53, 0x8d,
		0x14, 0x3b, 0x0e, 0x22, 0x7c, 0x39, 0x19, 0x70, 0x44, 0xc0, 0x11, 0x01, 0x47, 0x44, 0xa5, 0x23,
		0x22, 0x21, 0x80, 0x88, 0xb3, 0x86, 0x6d, 0xe5, 0x1a, 0x9c, 0xb5, 0x6d, 0x1a, 0x51, 0x88, 0x8a,
		0x2e, 0xcd, 0x64, 0x31, 0xc1, 0x1a, 0xb9, 0x95, 0xeb, 0x6d, 0xd1, 0xc1, 0xf5, 0x0a, 0xe0, 0x94,
		0x8a, 0x5e, 0xce, 0x85, 0xad, 0x38, 0xa9, 0xec, 0xdf, 0x5e, 0x6c, 0x17, 0x9a, 0x01, 0xbf, 0x28,
		0x27, 0x7e, 0xd1, 0xad, 0x9c, 0x61, 0x00, 0xb7, 0x28, 0x37, 0x6e, 0x11, 0x5f, 0x21, 0xce, 0xde,
		0x7a, 0x45, 0x5b, 0x7f, 0xbc, 0xff, 0xb8, 0xd9, 0xa8, 0x38, 0xfe, 0x0f, 0x0d, 0x06, 0x45, 0xfe,
		0x5c, 0x28, 0x62, 0xeb, 0xa4, 0x8a, 0x39, 0xec, 0x5b, 0x2b, 0x18, 0x18, 0x30, 0x1d, 0x56, 0xa5,
		0x01, 0x90, 0x48, 0x63, 0xa3, 0x3d, 0x99, 0x0d, 0x1b, 0x0c, 0xe0, 0x88, 0x74, 0x15, 0xda, 0xc1,
		0xc8, 0xee, 0x4c, 0x0e, 0x63, 0x24, 0x52, 0x70, 0x34, 0x82, 0x82, 0xa3, 0x2c, 0x63, 0x37, 0x7b,
		0x5c, 0x70, 0x34, 0x92, 0x29, 0x38, 0x1a, 0x41, 0xc1, 0x51, 0x46, 0x16, 0x09, 0x0a, 0x8e, 0xb4,
		0xb0, 0xff, 0xd4, 0x8e, 0x40, 0xc1, 0x91, 0x5a, 0xe1, 0x51, 0x25, 0x44, 0xaa, 0xbd, 0x69, 0x88,
		0xf3, 0x6b, 0x8b, 0x44, 0x41, 0xc1, 0xd1, 0xea, 0x35, 0xa0, 0xe0, 0x48, 0x72, 0x51, 0x28, 0x38,
		0xe2, 0x5a, 0x12, 0x0a, 0x8e, 0xa4, 0xd5, 0x19, 0x04, 0xd6, 0xa1, 0xe0, 0x48, 0xc1, 0xda, 0x50,
		0x70, 0xa4, 0x45, 0x17, 0xa0, 0x9d, 0x2d, 0x38, 0x1a, 0x05, 0xd8, 0x57, 0x54, 0x6c, 0x34, 0x5d,
		0x0a, 0x1c, 0x10, 0x70, 0x40, 0xc0, 0x01, 0xd9, 0x8c, 0x03, 0x02, 0x85, 0x46, 0x73, 0x9b, 0x04,
		0x85, 0x46, 0x50, 0x68, 0xb4, 0x63, 0x7b, 0x01, 0x85, 0x46, 0xe0, 0x0f, 0x41, 0xa1, 0xd1, 0x1e,
		0xbb, 0x43, 0x50, 0x68, 0xa4, 0xfe, 0x8e, 0x2d, 0x28, 0x34, 0x1a, 0x05, 0x83, 0xe2, 0x48, 0x73,
		0xa1, 0xd1, 0x97, 0x6d, 0x29, 0x34, 0xca, 0xb0, 0x84, 0x63, 0x94, 0x6d, 0x09, 0xc7, 0x63, 0x99,
		0xbf, 0x82, 0xe3, 0xb1, 0x0c, 0x05, 0x1c, 0xd9, 0xf9, 0xc4, 0x7b, 0x5c, 0xc0, 0xc1, 0xc1, 0x9c,
		0xe2, 0x4c, 0xba, 0xe0, 0x8b, 0x42, 0xf9, 0x46, 0x76, 0x81, 0x1e, 0x28, 0xdf, 0x48, 0xb7, 0x21,
		0xd0, 0xa4, 0x09, 0xb1, 0x53, 0x88, 0x9d, 0x42, 0xec, 0x14, 0x62, 0xa7, 0x10, 0x3b, 0x85, 0xd8,
		0x29, 0xc4, 0x4e, 0x21, 0x76, 0x0a, 0xb1, 0x53, 0x88, 0x9d, 0x42, 0xec, 0x14, 0x62, 0xa7, 0x79,
		0x8d, 0x9d, 0x3e, 0x96, 0x8b, 0xdc, 0xe1, 0x07, 0xbe, 0xc8, 0xe9, 0xef, 0x65, 0x08, 0x9c, 0x2e,
		0x10, 0x3d, 0xd3, 0xb8, 0x69, 0xa5, 0x2b, 0x10, 0x38, 0x65, 0x3e, 0xc5, 0x15, 0x22, 0xa7, 0x10,
		0x39, 0x95, 0x8a, 0x9c, 0x72, 0xb0, 0xa7, 0x04, 0x9b, 0x42, 0xec, 0x14, 0x62, 0xa7, 0x10, 0x3b,
		0x85, 0xd8, 0x29, 0xc4, 0x4e, 0x21, 0x76, 0x0a, 0xb1, 0x53, 0x88, 0x9d, 0x42, 0xec, 0x14, 0x62,
		0xa7, 0x10, 0x3b, 0x85, 0xd8, 0x29, 0xc4, 0x4e, 0x21, 0x76, 0x0a, 0xb1, 0x53, 0x88, 0x9d, 0x8a,
		0x84, 0xf1, 0x2a, 0xdd, 0x22, 0x7f, 0x00, 0x82, 0x33, 0x7a, 0x5a, 0xb9, 0x80, 0xf0, 0xe9, 0x22,
		0xdd, 0x95, 0xc5, 0x4f, 0xa5, 0x8e, 0x3b, 0x6c, 0x8c, 0x1e, 0x42, 0x65, 0x82, 0x6d, 0x26, 0x3b,
		0xc6, 0x19, 0x81, 0x8d, 0x08, 0x50, 0x4f, 0x48, 0x51, 0x9f, 0x27, 0x45, 0xf4, 0x15, 0xd3, 0x91,
		0x9a, 0x82, 0x81, 0x2f, 0x88, 0xd3, 0x42, 0x9c, 0x76, 0x3e, 0x4e, 0xbb, 0x89, 0x0a, 0xd7, 0x2a,
		0x44, 0x69, 0x21, 0x4a, 0xab, 0xd4, 0xe8, 0x1d, 0xe5, 0x3e, 0x33, 0x01, 0x3c, 0x0f, 0x3c, 0xbf,
		0x09, 0xa0, 0xa7, 0x22, 0xd9, 0x0c, 0x18, 0x07, 0x30, 0x0e, 0x9c, 0xfb, 0x0c, 0x1a, 0x1f, 0x34,
		0xfe, 0x36, 0x68, 0x7c, 0x98, 0x5d, 0xaf, 0x8d, 0x45, 0x61, 0x76, 0xbd, 0xaa, 0xc0, 0x23, 0xe0,
		0x12, 0xc0, 0x25, 0xfb, 0x8e, 0x4b, 0x36, 0x34, 0x1e, 0x1e, 0x70, 0x09, 0xe0, 0x92, 0x7c, 0x7a,
		0xa2, 0x6b, 0xaf, 0xe8, 0xa4, 0x85, 0xed, 0xf9, 0x52, 0x15, 0x02, 0x29, 0x8a, 0xf5, 0x14, 0x5f,
		0xfd, 0xf4, 0xcb, 0xff, 0xb2, 0x42, 0xad, 0x84, 0x9c, 0x17, 0xcd, 0x8e, 0x5e, 0x9d, 0x47, 0x36,
		0x3e, 0x3a, 0x01, 0x6d, 0x50, 0xba, 0x5e, 0xdd, 0x18, 0x37, 0x0e, 0xb9, 0x72, 0xa3, 0xbc, 0x68,
		0x4a, 0xa1, 0x85, 0x71, 0x63, 0x3d, 0xcd, 0x5c, 0x59, 0x3e, 0xab, 0x56, 0x4f, 0xdf, 0x56, 0xab,
		0xa5, 0xb7, 0x27, 0x6f, 0x4b, 0xe7, 0xb5, 0x5a, 0xf9, 0xb4, 0x5c, 0x5b, 0x73, 0xf3, 0x27, 0xdf,
		0xc6, 0x3e, 0xb6, 0xdf, 0x87, 0x4f, 0x4d, 0x46, 0xae, 0xcb, 0x72, 0xe9, 0x97, 0x00, 0xfb, 0x6b,
		0x2b, 0x35, 0x56, 0x11, 0x87, 0x2d, 0x37, 0xb3, 0x7e, 0xf7, 0xd9, 0xf0, 0x40, 0x8a, 0xbc, 0x33,
		0xda, 0x7e, 0x66, 0xe5, 0xc9, 0xa3, 0x2c, 0x79, 0x95, 0x23, 0xaf, 0x32, 0x14, 0x56, 0x7e, 0xc2,
		0xca, 0x4e, 0x40, 0xb9, 0xc9, 0xe5, 0xf8, 0x58, 0x6d, 0xb5, 0x41, 0x3c, 0xea, 0xf4, 0x9e, 0xcd,
		0x9e, 0xe3, 0x52, 0xec, 0x9b, 0x43, 0xdf, 0xeb, 0x39, 0x1c, 0xce, 0x52, 0xb2, 0x53, 0xcb, 0x97,
		0x61, 0x05, 0x16, 0x38, 0xe8, 0xfa, 0xce, 0x70, 0xac, 0xda, 0x8c, 0x56, 0xdf, 0x09, 0x90, 0x8b,
		0xad, 0x9e, 0x8f, 0x7b, 0xd1, 0x7f, 0x91, 0x13, 0xa0, 0x51, 0x80, 0x6d, 0x44, 0x3d, 0xe4, 0xe3,
		0xa1, 0x8f, 0x03, 0x4c, 0x28, 0xa2, 0x7d, 0x8c, 0x82, 0xa1, 0xe5, 0x07, 0xb8, 0x4d, 0x7c, 0xec,
		0xc6, 0x05, 0x10, 0x7d, 0x67, 0x88, 0xee, 0x31, 0xfd, 0x8e, 0x31, 0x89, 0x2e, 0x58, 0xa2, 0xec,
		0x90, 0xeb, 0x04, 0x14, 0x59, 0xc4, 0x0e, 0x2f, 0x68, 0x93, 0xf8, 0x8a, 0xa5, 0xcf, 0x1f, 0x5d,
		0x79, 0xcc, 0x09, 0x96, 0x4b, 0x00, 0x96, 0x01, 0x2c, 0x0b, 0x94, 0xe4, 0x26, 0x7b, 0x35, 0xe6,
		0x7c, 0x9e, 0xed, 0x9a, 0xe8, 0xea, 0xb7, 0x1c, 0xf7, 0xdc, 0x4d, 0x80, 0xc1, 0x6a, 0xfe, 0x2f,
		0x12, 0xe6, 0x0a, 0xa1, 0xdd, 0x0d, 0xca, 0x44, 0x96, 0x33, 0x22, 0xcf, 0xb8, 0xc8, 0x6a, 0x4c,
		0x24, 0x88, 0xd4, 0xac, 0x12, 0xb9, 0xa5, 0xd4, 0xca, 0x4f, 0xf8, 0x86, 0x43, 0x46, 0xc4, 0x2b,
		0x3e, 0x25, 0x18, 0x4e, 0x6d, 0x1d, 0xe0, 0xed, 0xa7, 0xd6, 0xf5, 0x87, 0xeb, 0x8b, 0x46, 0xeb,
		0xfa, 0xd3, 0x6d, 0x52, 0x0d, 0x78, 0x1b, 0x49, 0xfb, 0x87, 0x68, 0x67, 0xee, 0x62, 0x59, 0x17,
		0x2c, 0xeb, 0x54, 0xc9, 0xd2, 0xb2, 0x65, 0x9b, 0x7a, 0x38, 0x7a, 0x83, 0xdb, 0xb1, 0x7b, 0x21,
		0x4f, 0x29, 0x4c, 0x2b, 0x60, 0x3b, 0x04, 0x24, 0x58, 0xc0, 0x62, 0x6f, 0x86, 0x45, 0x5a, 0x11,
		0x15, 0xb2, 0x05, 0x75, 0xa2, 0x22, 0xaa, 0x16, 0xd7, 0x6d, 0x92, 0xde, 0x99, 0x07, 0x8d, 0x3a,
		0x4a, 0x83, 0x32, 0x2b, 0xac, 0x1f, 0x8f, 0x6c, 0x71, 0xc8, 0x14, 0x87, 0xab, 0x9f, 0x59, 0xf5,
		0x3b, 0xab, 0xd8, 0xc8, 0x04, 0x15, 0x78, 0xc5, 0x44, 0x4d, 0x5c, 0x21, 0x63, 0x12, 0xca, 0x6a,
		0xfb, 0x03, 0x3e, 0x8e, 0x5f, 0x19, 0x31, 0x63, 0x0b, 0x8b, 0xf2, 0x84, 0x43, 0xd7, 0xec, 0x1a,
		0x73, 0x09, 0xfc, 0x72, 0xf2, 0x2c, 0xbe, 0xf4, 0x92, 0xd7, 0x32, 0xa8, 0x1b, 0xd0, 0xd5, 0x99,
		0x93, 0x69, 0xba, 0x38, 0xba, 0x6c, 0x55, 0x94, 0x75, 0x6d, 0xf8, 0x2e, 0x35, 0xfa, 0xc0, 0x12,
		0x6d, 0x60, 0x8d, 0x2e, 0xb0, 0x4a, 0x12, 0x77, 0xf4, 0x80, 0x5b, 0x6c, 0x38, 0xa2, 0x03, 0x7c,
		0x31, 0xed, 0xb4, 0x70, 0x9b, 0xd1, 0xc5, 0x3e, 0x35, 0xa9, 0xc7, 0xd6, 0x26, 0x9f, 0x10, 0x76,
		0xee, 0xae, 0x2d, 0x88, 0xd7, 0x3e, 0xd5, 0x4a, 0xe7, 0xdd, 0x0a, 0xd9, 0xbd, 0x90, 0xed, 0xe4,
		0xc5, 0xf2, 0x12, 0xb5, 0xed, 0x39, 0xe4, 0x01, 0xfb, 0x43, 0xdf, 0xe1, 0x38, 0x4a, 0x32, 0xd9,
		0xa5, 0xd9, 0x9b, 0x77, 0x20, 0xb6, 0xc9, 0xce, 0x74, 0x3b, 0x16, 0xde, 0x64, 0x66, 0x4a, 0x3d,
		0x11, 0x4e, 0x81, 0xc1, 0x05, 0x12, 0x51, 0x51, 0xea, 0x06, 0x26, 0x3f, 0xe3, 0x22, 0xc1, 0x51,
		0x04, 0xc6, 0x9d, 0x45, 0x29, 0xf6, 0x09, 0x77, 0xdc, 0xc7, 0x38, 0xfc, 0x5a, 0x32, 0xcf, 0x2d,
		0xb3, 0xd7, 0x30, 0x3f, 0x74, 0x7e, 0x54, 0x5e, 0x0e, 0xeb, 0xf3, 0xff, 0xbf, 0xf0, 0xa6, 0xf0,
		0x8e, 0x97, 0x69, 0x66, 0x97, 0x2c, 0x44, 0x6b, 0xbe, 0xfe, 0xa6, 0xf0, 0xa3, 0x74, 0x54, 0xa9,
		0x55, 0x5f, 0x0c, 0xd5, 0x1e, 0x7d, 0x06, 0x51, 0xdd, 0x8d, 0xc4, 0xd8, 0x62, 0x84, 0xfb, 0xb1,
		0x69, 0xb6, 0x6e, 0xa6, 0x08, 0x37, 0x84, 0x53, 0x17, 0xd8, 0xa7, 0x2d, 0xaf, 0xd5, 0xbc, 0xfd,
		0x20, 0xc4, 0x6b, 0xfb, 0x13, 0x16, 0xe3, 0xa3, 0xe0, 0x3e, 0x16, 0xef, 0x19, 0x8e, 0xcd, 0x6f,
		0x9b, 0x1d, 0x1b, 0x4c, 0x32, 0x98, 0x64, 0x51, 0x3d, 0x2c, 0x6e, 0x5e, 0x47, 0x0e, 0xa1, 0x27,
		0x15, 0x01, 0xab, 0xca, 0x93, 0x72, 0xfc, 0x6c, 0x91, 0x87, 0x4c, 0xd4, 0xbc, 0xcc, 0xb8, 0x9e,
		0x64, 0x26, 0x8c, 0xe8, 0xf8, 0x2f, 0x55, 0x23, 0x60, 0xe4, 0x47, 0xbe, 0x88, 0x1c, 0x20, 0x2c,
		0x33, 0x5e, 0x27, 0x21, 0x5d, 0xb5, 0x72, 0x5e, 0x3d, 0x3f, 0x7d, 0x5b, 0x39, 0xaf, 0x6d, 0x3f,
		0x0d, 0x37, 0x6b, 0x88, 0xf6, 0x17, 0x80, 0x5d, 0x5f, 0x02, 0xee, 0x12, 0xc2, 0x5d, 0xd7, 0x97,
		0xfb, 0x09, 0xb7, 0x06, 0xd6, 0xd0, 0xa4, 0x3c, 0x06, 0x30, 0x61, 0xc6, 0xe4, 0x4e, 0x80, 0x5e,
		0x00, 0xbd, 0xb6, 0x22, 0x1a, 0xe2, 0xd8, 0x98, 0x50, 0x87, 0x3e, 0x0b, 0xd6, 0x89, 0x71, 0x98,
		0x65, 0xe3, 0x7a, 0xfc, 0x53, 0xef, 0xad, 0x00, 0x8b, 0x77, 0x73, 0x70, 0x44, 0xb2, 0x97, 0xa3,
		0x8a, 0x40, 0x68, 0xe8, 0x9a, 0xe4, 0x38, 0xda, 0xae, 0x37, 0x18, 0x78, 0xc4, 0x24, 0x62, 0xc5,
		0x18, 0x47, 0x59, 0x3f, 0x6e, 0x60, 0x11, 0xd3, 0x22, 0xcf, 0xdb, 0xf2, 0xa8, 0x36, 0x09, 0xb6,
		0x8a, 0xb4, 0xce, 0xd0, 0xb4, 0x6c, 0xdb, 0xc7, 0x41, 0xb0, 0x2d, 0x4f, 0xec, 0xf7, 0xba, 0x67,
		0x95, 0xca, 0xf6, 0x10, 0x79, 0x88, 0xbb, 0x4e, 0xcf, 0xc1, 0xb6, 0x6e, 0x00, 0xd3, 0xd9, 0xc2,
		0x96, 0xe4, 0x9c, 0xc2, 0xf4, 0x1b, 0x6b, 0xd8, 0x62, 0x87, 0x4e, 0x80, 0xd5, 0x97, 0x53, 0x6f,
		0x2f, 0x01, 0x3b, 0xd7, 0xc8, 0xf8, 0x69, 0xa7, 0x09, 0x3b, 0x82, 0x00, 0xa0, 0x0e, 0x40, 0x7d,
		0xc3, 0x40, 0x3d, 0xa0, 0xbe, 0x43, 0x1e, 0x84, 0xb2, 0x95, 0x60, 0x79, 0xd6, 0xeb, 0xce, 0x4b,
		0x8b, 0x5a, 0x60, 0x76, 0x84, 0xcc, 0x4e, 0x44, 0xba, 0xad, 0xec, 0xc8, 0xf8, 0xde, 0xc7, 0x24,
		0x4b, 0x36, 0x3c, 0x3e, 0x2e, 0x4e, 0xa2, 0x43, 0xe8, 0xbf, 0xd0, 0x2f, 0x63, 0xdd, 0x55, 0x4f,
		0x90, 0xea, 0x2f, 0x1b, 0xe6, 0xc0, 0x88, 0x1e, 0x79, 0x62, 0xbe, 0x74, 0x82, 0x41, 0x57, 0xc3,
		0xeb, 0xcd, 0x64, 0x4a, 0xfc, 0xb2, 0x35, 0xc5, 0x4f, 0xcd, 0x1c, 0x6b, 0x73, 0xfc, 0x8c, 0x61,
		0x14, 0x6f, 0x92, 0x4f, 0x16, 0x61, 0x6f, 0x96, 0x5f, 0xbc, 0x25, 0xb5, 0x69, 0x9e, 0x95, 0xa4,
		0xb9, 0x6d, 0x14, 0x49, 0xd7, 0xcc, 0x57, 0x84, 0xfa, 0xcf, 0x7b, 0xd9, 0xd4, 0xc1, 0x4a, 0x9b,
		0xbc, 0x35, 0x60, 0x64, 0x3b, 0xb5, 0x23, 0x24, 0x48, 0x91, 0x33, 0x98, 0xba, 0xbe, 0x66, 0x3d,
		0x5c, 0xf1, 0x5b, 0x4c, 0xe3, 0xf4, 0xa6, 0x33, 0x55, 0x33, 0x40, 0x78, 0xda, 0x4d, 0x38, 0xda,
		0x7e, 0x39, 0x4a, 0x95, 0xd7, 0x15, 0xcf, 0xcb, 0x08, 0x98, 0x54, 0x8f, 0xae, 0x9a, 0x62, 0xe5,
		0xf8, 0xd5, 0x76, 0xab, 0x3d, 0x23, 0x65, 0xb7, 0xd2, 0x59, 0x5c, 0xaa, 0x1f, 0x23, 0x60, 0xe9,
		0xc6, 0x08, 0xa0, 0x17, 0x63, 0x3b, 0x7a, 0x31, 0x46, 0x01, 0x36, 0x87, 0x6c, 0x91, 0x9b, 0x99,
		0x69, 0x64, 0xc9, 0x3d, 0x69, 0x35, 0xfc, 0xb8, 0x67, 0x8d, 0x5c, 0xca, 0x04, 0x23, 0x8c, 0x08,
		0xeb, 0x18, 0x52, 0x63, 0xa1, 0xd8, 0x62, 0x5c, 0x30, 0xa7, 0x27, 0x9f, 0x73, 0x7a, 0x98, 0x23,
		0x4b, 0x09, 0xad, 0xef, 0x3d, 0xcf, 0xc5, 0x16, 0x53, 0x8f, 0xcd, 0x44, 0xef, 0x94, 0x77, 0xb7,
		0xed, 0xba, 0x56, 0x3b, 0x2f, 0xd7, 0x51, 0xcb, 0xb7, 0x48, 0x30, 0xf4, 0x7c, 0x8a, 0x26, 0x67,
		0x1b, 0xa1, 0x1b, 0xcf, 0xc6, 0x2e, 0xea, 0x79, 0x7e, 0x34, 0x06, 0x28, 0x6e, 0x88, 0x6c, 0x13,
		0xc4, 0xda, 0x13, 0x19, 0xa3, 0xd1, 0xe6, 0x0c, 0x14, 0x0d, 0x06, 0xb1, 0x08, 0x8d, 0xfc, 0xc8,
		0x9a, 0x7d, 0x09, 0xf0, 0x1d, 0x6f, 0x2c, 0x75, 0xb7, 0x3a, 0xb0, 0x73, 0x40, 0xfa, 0x2d, 0x6f,
		0xc6, 0xce, 0x31, 0x3a, 0x0e, 0x76, 0x15, 0x1b, 0x07, 0xbb, 0x86, 0x8c, 0x03, 0x71, 0x5c, 0x1c,
		0x48, 0xa1, 0xe2, 0x11, 0x0b, 0x2a, 0x1e, 0x01, 0x2a, 0xde, 0x12, 0x54, 0xec, 0x7a, 0x5d, 0xcb,
		0x65, 0x07, 0xc4, 0xf1, 0xe5, 0x30, 0x43, 0x12, 0x66, 0x48, 0x46, 0xce, 0x91, 0xcf, 0x9f, 0xc8,
		0x8f, 0xee, 0x82, 0x41, 0xe4, 0x22, 0x20, 0x10, 0x06, 0x91, 0xf3, 0x6d, 0x95, 0x35, 0x8a, 0x8c,
		0xa7, 0x60, 0xed, 0x6a, 0x74, 0xb7, 0xd8, 0x28, 0xf2, 0x32, 0x8c, 0x22, 0xd7, 0xcf, 0xd8, 0xca,
		0x18, 0x5c, 0x01, 0xa3, 0xf3, 0x31, 0x3c, 0x27, 0xe3, 0x0b, 0x0b, 0x40, 0x72, 0xe3, 0x70, 0xec,
		0x6f, 0x89, 0x6f, 0xd6, 0x84, 0x59, 0x92, 0x95, 0x04, 0x49, 0x3c, 0x16, 0x10, 0xd1, 0x06, 0x31,
		0x51, 0x41, 0x51, 0x21, 0x30, 0xaa, 0x04, 0x47, 0x95, 0x00, 0x29, 0x17, 0x24, 0xe5, 0x02, 0xa5,
		0x50, 0xb0, 0xc4, 0x04, 0x4c, 0x50, 0xd0, 0x92, 0xe7, 0x16, 0x28, 0x1a, 0x53, 0x26, 0xb4, 0xc9,
		0x02, 0x03, 0xbb, 0x26, 0xcf, 0x23, 0x49, 0xcf, 0x93, 0x5d, 0x93, 0xe5, 0x0e, 0xb1, 0xe3, 0x36,
		0x94, 0x8b, 0xb2, 0x4a, 0x91, 0x56, 0x2d, 0xda, 0xaa, 0x45, 0x5c, 0x9b, 0xa8, 0x6b, 0x13, 0x79,
		0x0d, 0xa2, 0x2f, 0xa7, 0x02, 0x24, 0x55, 0x81, 0x32, 0x71, 0x56, 0x2a, 0xd6, 0x1a, 0xc4, 0x5b,
		0x12, 0xca, 0x6a, 0x17, 0x77, 0x1d, 0x62, 0xaf, 0x4b, 0xfc, 0x75, 0xa9, 0x01, 0xed, 0xea, 0x40,
		0xbb, 0x5a, 0xd0, 0xa8, 0x1e, 0xd4, 0xa8, 0x09, 0x45, 0xea, 0x42, 0xb9, 0xda, 0x48, 0x16, 0xfc,
		0x33, 0xaa, 0x1f, 0x54, 0xcc, 0x4f, 0x13, 0xfe, 0x0f, 0x17, 0x57, 0xbc, 0xd1, 0x7c, 0x3d, 0x19,
		0x1b, 0x53, 0x2b, 0x3a, 0xd5, 0x8b, 0x6e, 0x35, 0xa3, 0x5b, 0xdd, 0x64, 0xa6, 0x76, 0x32, 0x53,
		0x3f, 0x19, 0xa8, 0x21, 0xb5, 0xea, 0x48, 0xb1, 0x5a, 0x52, 0xe9, 0xe8, 0xac, 0x5c, 0x9b, 0xbb,
		0x8b, 0x86, 0x5b, 0x8e, 0xfa, 0xf8, 0xc9, 0xe4, 0xee, 0xb8, 0xe1, 0x06, 0x42, 0x67, 0x1a, 0xd6,
		0x16, 0x9d, 0x37, 0xc8, 0xfc, 0x03, 0x2c, 0x73, 0x09, 0x95, 0xff, 0x72, 0x27, 0xd7, 0xbc, 0x7e,
		0xf5, 0x44, 0x03, 0x2d, 0x04, 0xd7, 0xaf, 0x6d, 0x89, 0xd5, 0x1d, 0xd4, 0xed, 0xb8, 0xd2, 0xcc,
		0xb4, 0x31, 0x79, 0x36, 0x2d, 0xd7, 0xcd, 0x46, 0xf9, 0x46, 0x25, 0x6b, 0x19, 0x68, 0xdf, 0xbc,
		0x6b, 0xde, 0xce, 0x8e, 0x02, 0x54, 0x89, 0x4e, 0xc1, 0xd4, 0xb5, 0xc5, 0x3b, 0x09, 0xb3, 0x17,
		0xb9, 0xd7, 0x27, 0x13, 0x54, 0xeb, 0xe8, 0x4b, 0x80, 0x7d, 0xf3, 0xde, 0x0a, 0xb0, 0xfd, 0xba,
		0xd8, 0xe9, 0xf0, 0x4b, 0xf3, 0xa6, 0x80, 0x7a, 0x9e, 0xdf, 0x26, 0x08, 0x3d, 0x62, 0x3f, 0x70,
		0x3c, 0x82, 0x4e, 0x90, 0xd7, 0x9b, 0x29, 0x81, 0x5a, 0x57, 0xff, 0x14, 0xde, 0x16, 0x95, 0x40,
		0x3d, 0x9e, 0xcc, 0x14, 0x41, 0x7d, 0x69, 0x5e, 0x7d, 0x36, 0xdf, 0x37, 0x9a, 0x57, 0x97, 0xe6,
		0xb8, 0x1c, 0x6a, 0x14, 0x0c, 0x7e, 0xbb, 0x69, 0x5c, 0xdc, 0x5c, 0xd6, 0x1a, 0x23, 0xda, 0xbf,
		0x93, 0x8b, 0xc1, 0xe7, 0x05, 0x3a, 0xca, 0x76, 0x51, 0xe6, 0x13, 0x3d, 0x6e, 0x01, 0xdb, 0xe4,
		0x1d, 0xdb, 0x1e, 0xe4, 0x4b, 0x57, 0xab, 0xd2, 0xb0, 0x9c, 0x2d, 0x41, 0xcc, 0xeb, 0xae, 0x2f,
		0x14, 0x1b, 0x05, 0x83, 0x62, 0x54, 0xb4, 0x53, 0x1c, 0x05, 0xd8, 0x2f, 0x5a, 0x23, 0xda, 0x2f,
		0x4e, 0x92, 0x78, 0xc5, 0x81, 0x5d, 0x2b, 0xaa, 0x0b, 0x19, 0xa2, 0xb4, 0xca, 0xb3, 0x2f, 0xc1,
		0xe0, 0xdb, 0xc7, 0xf0, 0x59, 0xbe, 0x85, 0xb2, 0xf1, 0x2d, 0x64, 0xca, 0x6f, 0x37, 0x76, 0x4d,
		0x0d, 0x43, 0xbe, 0x6c, 0x79, 0x60, 0x59, 0x31, 0x7b, 0x48, 0xb2, 0x85, 0xdc, 0x9e, 0x88, 0x53,
		0x52, 0x82, 0x8a, 0x46, 0xd0, 0xb7, 0xd4, 0x25, 0xca, 0xc2, 0xc5, 0x20, 0x51, 0x96, 0x55, 0x08,
		0x0b, 0x12, 0x65, 0x90, 0x28, 0xd3, 0x29, 0xd6, 0x1a, 0xc4, 0x7b, 0x21, 0x3e, 0x04, 0x89, 0xb2,
		0xdc, 0xba, 0x1f, 0x90, 0x28, 0xdb, 0x9a, 0x38, 0x04, 0x24, 0xca, 0x20, 0x51, 0xa6, 0x5b, 0xcd,
		0x6c, 0x22, 0xda, 0x01, 0x89, 0xb2, 0xcd, 0x04, 0x13, 0x20, 0x51, 0x06, 0x89, 0x32, 0x96, 0x1f,
		0x80, 0x44, 0xd9, 0x02, 0x49, 0x20, 0x51, 0x26, 0xa2, 0x7c, 0x21, 0x51, 0xa6, 0x9a, 0xb7, 0x21,
		0x51, 0x96, 0x47, 0x91, 0xcb, 0x73, 0xa2, 0xac, 0xf9, 0x5b, 0x03, 0x12, 0x65, 0x39, 0x47, 0x8f,
		0x5b, 0xc0, 0x36, 0x90, 0x28, 0xdb, 0x88, 0x86, 0xcd, 0x61, 0xa2, 0x2c, 0xe8, 0x5b, 0x45, 0x75,
		0x21, 0x43, 0x24, 0x92, 0x28, 0x6b, 0xf6, 0x2d, 0x48, 0x94, 0xe5, 0x2c, 0x51, 0x16, 0xc8, 0xee,
		0xc9, 0xcb, 0x96, 0x34, 0xc2, 0x29, 0x04, 0x3d, 0x0a, 0x41, 0x8e, 0xc2, 0x3c, 0x16, 0x97, 0x35,
		0x9a, 0x9a, 0xa2, 0xd0, 0xa6, 0x30, 0x5b, 0x23, 0x56, 0x53, 0x14, 0x3e, 0x81, 0x62, 0xf8, 0xa2,
		0x33, 0xbf, 0xa6, 0x1a, 0x9e, 0x64, 0x93, 0x62, 0xcb, 0xf5, 0x86, 0x6f, 0x5a, 0x43, 0x1f, 0x64,
		0x0b, 0x24, 0x44, 0xb5, 0x92, 0x22, 0x4b, 0x20, 0x61, 0x01, 0xc4, 0x76, 0xea, 0x25, 0x67, 0x73,
		0x05, 0x14, 0x68, 0x77, 0x63, 0xe8, 0xe3, 0x40, 0x4a, 0xa9, 0x2b, 0x68, 0xc8, 0xc7, 0x24, 0x7c,
		0xfe, 0x00, 0x85, 0x5b, 0x84, 0x09, 0x75, 0xba, 0x31, 0x6f, 0xe4, 0xae, 0x45, 0x3f, 0x50, 0xa0,
		0x2d, 0xf5, 0x36, 0xe9, 0xaf, 0xa0, 0x64, 0xd6, 0x68, 0xe5, 0x40, 0xaf, 0xfe, 0xe1, 0x95, 0x13,
		0x49, 0x7d, 0xc3, 0xaf, 0x67, 0x44, 0xc6, 0xb2, 0x70, 0xfa, 0x15, 0x86, 0xa6, 0x53, 0x16, 0x38,
		0x68, 0xcb, 0x77, 0x22, 0xd4, 0x82, 0xd4, 0x8b, 0x9c, 0x2d, 0x29, 0x96, 0x64, 0x85, 0x39, 0x3d,
		0x30, 0xa7, 0x87, 0xe5, 0xf9, 0x84, 0x13, 0x79, 0xaf, 0x0e, 0x7a, 0xed, 0x39, 0xcc, 0xa3, 0xd2,
		0x96, 0x71, 0xb7, 0x48, 0x22, 0xce, 0xf8, 0x88, 0xc9, 0x43, 0xa4, 0x9f, 0x32, 0xb7, 0xe2, 0x32,
		0xa7, 0xf7, 0x27, 0x8b, 0x4c, 0x8e, 0xa2, 0x97, 0xcc, 0xcd, 0x2a, 0x3b, 0x89, 0x7e, 0xba, 0xb3,
		0xb2, 0x27, 0xd2, 0x2b, 0x08, 0x9f, 0x48, 0x9d, 0xf2, 0xbf, 0x40, 0xe2, 0x93, 0xca, 0xee, 0xd2,
		0x78, 0x27, 0xe0, 0x8a, 0x0a, 0x58, 0x2f, 0x1f, 0xac, 0x51, 0x80, 0xeb, 0xf3, 0xe6, 0xab, 0xdf,
		0xf2, 0x23, 0x0e, 0xdd, 0x5e, 0x85, 0xaa, 0x20, 0x8c, 0x5e, 0xb7, 0x22, 0x97, 0x1b, 0xb9, 0x6b,
		0x5a, 0x42, 0x0b, 0x44, 0x1f, 0xfa, 0xce, 0xa3, 0x38, 0x44, 0x8f, 0xee, 0x86, 0x51, 0x9a, 0x00,
		0xd1, 0x73, 0x03, 0xd1, 0x61, 0x94, 0x26, 0x8c, 0xd2, 0xd4, 0x28, 0x48, 0xd9, 0x98, 0x53, 0x18,
		0xa5, 0xc9, 0xb9, 0x80, 0x85, 0x03, 0x75, 0x1d, 0x82, 0xe1, 0x62, 0xd0, 0x21, 0xa8, 0x5b, 0xb4,
		0x55, 0x8b, 0xb8, 0x36, 0x51, 0xd7, 0x26, 0xf2, 0x1a, 0x44, 0x5f, 0x4e, 0x05, 0x28, 0x88, 0x44,
		0x20, 0xa5, 0x1d, 0x82, 0x2a, 0xc4, 0x5a, 0x83, 0x78, 0x4b, 0x42, 0x59, 0xed, 0xe2, 0xae, 0x43,
		0xec, 0x75, 0x89, 0xbf, 0x2e, 0x35, 0xa0, 0x5d, 0x1d, 0x68, 0x57, 0x0b, 0x1a, 0xd5, 0x83, 0x1a,
		0x35, 0xa1, 0x48, 0x5d, 0x28, 0x57, 0x1b, 0xc9, 0x82, 0xd0, 0x21, 0x88, 0xa0, 0x43, 0x30, 0x5b,
		0x75, 0x93, 0x99, 0xda, 0xc9, 0x4c, 0xfd, 0x64, 0xa0, 0x86, 0xd4, 0xaa, 0x23, 0xc5, 0x6a, 0x49,
		0xa5, 0xa3, 0xb3, 0x72, 0x6d, 0xe8, 0x10, 0x5c, 0xa3, 0x65, 0xa0, 0x43, 0x30, 0x73, 0x5e, 0x87,
		0x0e, 0x41, 0x11, 0xe5, 0x0b, 0x1d, 0x82, 0xaa, 0x79, 0x1b, 0x3a, 0x04, 0xf3, 0x28, 0x72, 0xf3,
		0xf9, 0xdb, 0xb3, 0xca, 0x69, 0x1d, 0xb5, 0xfa, 0x18, 0x35, 0xec, 0x47, 0x8b, 0x74, 0xb1, 0x8d,
		0xae, 0x48, 0xd7, 0x7f, 0x1e, 0x52, 0xc7, 0x23, 0xa8, 0x49, 0x43, 0xab, 0xe9, 0xdb, 0xe8, 0xb0,
		0x71, 0xd5, 0x2c, 0xb4, 0x09, 0x42, 0x17, 0xce, 0xb0, 0x8f, 0x7d, 0xd4, 0x70, 0x1f, 0x3c, 0xdf,
		0xa1, 0xfd, 0x01, 0x72, 0x48, 0x9c, 0x00, 0xbc, 0xbd, 0xb9, 0x5b, 0x96, 0x3d, 0x0c, 0xef, 0x89,
		0x12, 0x88, 0xb3, 0x69, 0xbf, 0x1b, 0xb3, 0x71, 0xd5, 0x9c, 0x24, 0xfc, 0x1a, 0x38, 0xb8, 0xe8,
		0xdd, 0x97, 0x2b, 0x67, 0xd0, 0x16, 0x98, 0x63, 0xc8, 0x98, 0x57, 0x5e, 0x81, 0x5e, 0xc0, 0x8d,
		0xe8, 0xd2, 0x5c, 0xf4, 0x02, 0x0e, 0x7d, 0xe7, 0x71, 0xda, 0xf4, 0x65, 0xe1, 0xa0, 0xa8, 0x2e,
		0x38, 0x88, 0x38, 0x6b, 0x76, 0xef, 0x7c, 0xe7, 0xf1, 0x5b, 0x03, 0x07, 0xd0, 0x0b, 0xb8, 0xf1,
		0x5e, 0xc0, 0x05, 0xb6, 0xd8, 0xc6, 0xa1, 0x99, 0xb6, 0xca, 0x94, 0x98, 0x0d, 0x29, 0xb1, 0x0c,
		0x83, 0x55, 0x90, 0x12, 0x83, 0x94, 0x98, 0x4e, 0xb1, 0xd6, 0x20, 0xde, 0x0b, 0x91, 0x20, 0x48,
		0x89, 0xe5, 0xd6, 0xe7, 0x80, 0x94, 0xd8, 0xd6, 0x44, 0x1c, 0x20, 0x25, 0x06, 0x29, 0x31, 0xdd,
		0x6a, 0x66, 0x13, 0x21, 0x0e, 0x48, 0x89, 0x6d, 0x26, 0x98, 0x00, 0x29, 0x31, 0x48, 0x89, 0xb1,
		0xfc, 0x00, 0xa4, 0xc4, 0x16, 0x48, 0x02, 0x29, 0x31, 0x11, 0xe5, 0x0b, 0x29, 0x31, 0xd5, 0xbc,
		0x0d, 0x29, 0xb1, 0x3c, 0x8a, 0x5c, 0x5e, 0x87, 0x66, 0x5e, 0x5e, 0x35, 0xef, 0x7c, 0xe7, 0x11,
		0x32, 0x63, 0x39, 0x46, 0x8e, 0x39, 0x67, 0x19, 0x48, 0x90, 0x6d, 0x44, 0xb3, 0xe6, 0x30, 0x41,
		0x66, 0xe3, 0xa0, 0x68, 0x6f, 0x36, 0x41, 0x76, 0x09, 0x09, 0x32, 0x2d, 0xec, 0x21, 0xc9, 0x16,
		0x30, 0x2c, 0x73, 0x73, 0xe0, 0x66, 0x87, 0x87, 0x65, 0x2a, 0x86, 0x2e, 0x30, 0x2c, 0x33, 0xef,
		0x73, 0x1b, 0xd4, 0x02, 0x0f, 0x18, 0x96, 0x99, 0x8d, 0x05, 0x80, 0x61, 0x99, 0x93, 0x35, 0x06,
		0xa3, 0x80, 0x6e, 0x72, 0xa0, 0xce, 0xf1, 0xb1, 0xe8, 0x78, 0xc1, 0x69, 0x9c, 0xcb, 0xf7, 0x3d,
		0xff, 0x06, 0x07, 0x81, 0xf5, 0x80, 0xd5, 0x15, 0x90, 0x7c, 0xef, 0x63, 0x82, 0x42, 0xa6, 0xb1,
		0xba, 0xcf, 0xe8, 0xb0, 0xeb, 0x91, 0x5e, 0x3c, 0x09, 0xcd, 0x72, 0x1d, 0xfa, 0x5c, 0x40, 0x4e,
		0x80, 0x46, 0x01, 0xb6, 0x8f, 0x5e, 0xcd, 0xa5, 0x44, 0x21, 0x3d, 0x91, 0xe5, 0x06, 0x1e, 0xba,
		0xc7, 0xd1, 0x15, 0xb2, 0x55, 0x28, 0x0a, 0x2d, 0xc0, 0xac, 0xf6, 0xc7, 0x21, 0xd1, 0xcc, 0xc1,
		0x98, 0x6a, 0x0a, 0x2c, 0x95, 0x0e, 0xed, 0x3f, 0xa7, 0xf9, 0x95, 0x6d, 0xc8, 0x76, 0x21, 0x3f,
		0xfe, 0x19, 0x3d, 0x47, 0xdb, 0x3d, 0x32, 0x17, 0x27, 0xf5, 0xb5, 0x30, 0x2e, 0x97, 0x5f, 0x4a,
		0x96, 0x50, 0x11, 0x46, 0xe5, 0x66, 0x37, 0x2a, 0x57, 0x60, 0xbc, 0x94, 0x48, 0x54, 0x41, 0xdb,
		0xa8, 0xdc, 0x03, 0x85, 0x3b, 0x10, 0xca, 0x0e, 0xe7, 0x54, 0x5c, 0xe3, 0xa3, 0x13, 0xd0, 0x06,
		0xa5, 0x7c, 0x35, 0x24, 0xc6, 0x8d, 0x43, 0xae, 0xdc, 0x08, 0xc3, 0x73, 0xce, 0x6e, 0x34, 0x6e,
		0xac, 0xa7, 0x99, 0x3b, 0xcb, 0x67, 0xd5, 0xea, 0xe9, 0xdb, 0x6a, 0xb5, 0xf4, 0xf6, 0xe4, 0x6d,
		0xe9, 0xbc, 0x56, 0x2b, 0x9f, 0x96, 0x39, 0x66, 0x1a, 0x19, 0x9f, 0x7c, 0x1b, 0xfb, 0xd8, 0x7e,
		0x1f, 0xbe, 0x35, 0x19, 0xb9, 0xae, 0xc8, 0xad, 0xe1, 0x16, 0x73, 0x0d, 0x8d, 0x64, 0xdd, 0x0c,
		0x09, 0xb0, 0x28, 0xe1, 0xfa, 0x4b, 0x4c, 0x30, 0xcb, 0x9b, 0xa7, 0xd7, 0x8a, 0xe8, 0xb6, 0xd9,
		0x91, 0x6a, 0xb2, 0x3e, 0xbb, 0x9e, 0xa9, 0x6a, 0xf9, 0xdc, 0x29, 0xdd, 0xce, 0xda, 0x81, 0x5a,
		0xf3, 0xc6, 0x2a, 0xc7, 0x82, 0xe6, 0x8c, 0xcb, 0x8c, 0x71, 0x70, 0x17, 0x87, 0xe5, 0x62, 0xdb,
		0x91, 0x74, 0xba, 0xae, 0xbf, 0x22, 0x85, 0x8e, 0xbc, 0xf4, 0x63, 0xa5, 0x1b, 0x03, 0xc9, 0xd8,
		0x48, 0xb5, 0x9e, 0x4a, 0xab, 0xdf, 0x7d, 0xcd, 0x7b, 0x1b, 0x3e, 0x1e, 0x78, 0x34, 0x5d, 0x03,
		0x25, 0xaa, 0x77, 0x7c, 0x7d, 0x0a, 0x25, 0xd9, 0x0a, 0xa7, 0x99, 0x2b, 0x17, 0x79, 0x2a, 0x11,
		0x79, 0x2b, 0x0b, 0x79, 0x75, 0xb0, 0x70, 0xe5, 0x9f, 0xb0, 0x82, 0x15, 0xa8, 0xcc, 0x93, 0x93,
		0x03, 0xd6, 0x42, 0x5d, 0x03, 0x93, 0x07, 0x87, 0x60, 0xd3, 0xb1, 0xd9, 0xa9, 0x37, 0x75, 0xe9,
		0x26, 0xb7, 0xb2, 0x22, 0x46, 0xae, 0xe2, 0x59, 0xee, 0xa2, 0x58, 0x91, 0x62, 0x57, 0xd1, 0x22,
		0x56, 0x51, 0xb3, 0x2f, 0x5d, 0x74, 0x2a, 0x6d, 0xe3, 0x25, 0x8a, 0x44, 0xd5, 0xfa, 0x0f, 0xdc,
		0x05, 0x95, 0xc2, 0x8c, 0x87, 0x04, 0xeb, 0x1f, 0x85, 0xeb, 0x1a, 0x99, 0xea, 0x15, 0x8f, 0xc4,
		0x97, 0x2c, 0x44, 0x6b, 0xbe, 0xfe, 0xa6, 0xf0, 0xa3, 0x7a, 0x74, 0x52, 0x7e, 0x31, 0x36, 0x04,
		0x5d, 0xc0, 0x05, 0x91, 0x04, 0xb6, 0x57, 0x11, 0x5b, 0x5f, 0x5f, 0x82, 0x17, 0xb2, 0x05, 0x5e,
		0x48, 0xb2, 0x59, 0xdb, 0xe6, 0x88, 0x1c, 0x28, 0x90, 0x77, 0x63, 0x14, 0xc7, 0x31, 0x38, 0x01,
		0x03, 0x87, 0xf3, 0xc1, 0xd9, 0xb7, 0x07, 0x58, 0x61, 0xb7, 0xb1, 0x02, 0x6f, 0xdf, 0x99, 0x11,
		0x65, 0x1d, 0x85, 0x8f, 0x11, 0x10, 0xc8, 0x59, 0xc2, 0x31, 0x02, 0x19, 0x32, 0xb6, 0x5e, 0x53,
		0x03, 0xc7, 0x08, 0x2c, 0x65, 0x16, 0x38, 0x46, 0x00, 0x8e, 0x11, 0xd8, 0x84, 0x60, 0x89, 0x09,
		0x98, 0xa0, 0xa0, 0x25, 0xcf, 0x9d, 0x8b, 0x63, 0x04, 0x06, 0x76, 0x4d, 0x5d, 0xc9, 0x4b, 0xb8,
		0x18, 0xcc, 0x4c, 0xd1, 0x2d, 0xda, 0xaa, 0x45, 0x5c, 0x9b, 0xa8, 0x6b, 0x13, 0x79, 0x0d, 0xa2,
		0x2f, 0xa7, 0x02, 0x24, 0x55, 0x81, 0x32, 0x71, 0x56, 0x2a, 0xd6, 0x1a, 0xc4, 0x5b, 0x12, 0xca,
		0x6a, 0x17, 0x77, 0x1d, 0x62, 0xaf, 0x4b, 0xfc, 0x75, 0xa9, 0x01, 0xed, 0xea, 0x40, 0xbb, 0x5a,
		0xd0, 0xa8, 0x1e, 0xd4, 0xa8, 0x09, 0x45, 0xea, 0x42, 0xb9, 0xda, 0x48, 0x16, 0x84, 0x99, 0x29,
		0x08, 0x66, 0xa6, 0x64, 0xab, 0x6e, 0x32, 0x53, 0x3b, 0x99, 0xa9, 0x9f, 0x0c, 0xd4, 0x90, 0x5a,
		0x75, 0xa4, 0x58, 0x2d, 0xa9, 0x74, 0x74, 0x56, 0xae, 0x0d, 0x33, 0x53, 0xd6, 0x68, 0x19, 0x98,
		0x99, 0x92, 0x39, 0xaf, 0xc3, 0xcc, 0x14, 0x11, 0xe5, 0x0b, 0x33, 0x53, 0x54, 0xf3, 0x36, 0xcc,
		0x4c, 0xc9, 0xa3, 0xc8, 0xe5, 0x75, 0x66, 0xca, 0x6f, 0x37, 0x8d, 0x8b, 0x9b, 0xcb, 0x5a, 0x63,
		0x44, 0xfb, 0x30, 0x37, 0x25, 0xc7, 0xe8, 0x71, 0x0b, 0xd8, 0x06, 0x66, 0xa7, 0x6c, 0x44, 0xc3,
		0x6e, 0x6e, 0x76, 0x4a, 0x5c, 0xeb, 0x1b, 0x77, 0x2f, 0x59, 0x23, 0xda, 0x9f, 0x4e, 0xc9, 0x18,
		0xd8, 0xb5, 0xa2, 0xba, 0x98, 0x21, 0x62, 0xa9, 0x80, 0xfe, 0x1c, 0x3d, 0x4c, 0xdc, 0xe7, 0x14,
		0xb2, 0xe5, 0xb7, 0x1b, 0xbb, 0x06, 0xd3, 0x53, 0x36, 0x33, 0x3d, 0x65, 0x2d, 0x63, 0x6c, 0xe3,
		0xf9, 0x02, 0x41, 0xdf, 0x52, 0x97, 0x2b, 0x0b, 0x17, 0x83, 0x5c, 0x59, 0x56, 0x51, 0x2c, 0xc8,
		0x95, 0x41, 0xae, 0x4c, 0xa7, 0x58, 0x6b, 0x10, 0xef, 0x85, 0x10, 0x11, 0xe4, 0xca, 0x72, 0xeb,
		0x81, 0x40, 0xae, 0x6c, 0x6b, 0x42, 0x11, 0x90, 0x2b, 0x83, 0x5c, 0x99, 0x6e, 0x35, 0xb3, 0x89,
		0x80, 0x07, 0xe4, 0xca, 0x36, 0x13, 0x4f, 0x80, 0x5c, 0x19, 0xe4, 0xca, 0x58, 0x7e, 0x00, 0x72,
		0x65, 0x0b, 0x24, 0x81, 0x5c, 0x99, 0x88, 0xf2, 0x85, 0x5c, 0x99, 0x6a, 0xde, 0x86, 0x5c, 0x59,
		0x1e, 0x45, 0x2e, 0xcf, 0xb9, 0xb2, 0xe6, 0x6f, 0x0d, 0xc8, 0x95, 0xe5, 0x1c, 0x3d, 0x6e, 0x01,
		0xdb, 0x40, 0xae, 0x6c, 0x23, 0x1a, 0x36, 0x8f, 0xb9, 0xb2, 0xa0, 0x6f, 0x15, 0xd5, 0xc5, 0x0c,
		0x91, 0x50, 0xae, 0xac, 0xd9, 0xb7, 0x20, 0x57, 0x96, 0xb7, 0x5c, 0x59, 0x20, 0xbb, 0x29, 0x70,
		0xd4, 0xc0, 0x66, 0x71, 0x4d, 0x6e, 0x87, 0x81, 0x28, 0x46, 0x30, 0x70, 0xd4, 0x40, 0xde, 0x07,
		0x8a, 0xa8, 0xc5, 0x1e, 0x70, 0xd4, 0x40, 0x46, 0x26, 0x00, 0xce, 0x1a, 0x98, 0xac, 0x91, 0xa7,
		0x29, 0xe3, 0xf3, 0x53, 0xe2, 0x61, 0xd2, 0x38, 0xbf, 0x7a, 0x5c, 0x41, 0x49, 0x98, 0x36, 0xae,
		0x79, 0xda, 0xf8, 0x6b, 0x45, 0xa3, 0x63, 0xdc, 0xf8, 0x6b, 0xdf, 0x42, 0xdb, 0xbc, 0x71, 0x8e,
		0x19, 0x49, 0xe3, 0xa7, 0x15, 0x1c, 0xd8, 0xc3, 0x31, 0x84, 0x7c, 0x2a, 0x91, 0x42, 0xa9, 0x56,
		0x18, 0xd8, 0x03, 0x03, 0x7b, 0x58, 0x9e, 0x4f, 0x38, 0x9d, 0x97, 0xec, 0x75, 0x7c, 0xfe, 0x49,
		0xcf, 0xe1, 0x1a, 0xd8, 0xfc, 0x9a, 0xbb, 0x45, 0xd2, 0x71, 0xc6, 0x47, 0x4c, 0x1e, 0x22, 0x0d,
		0x95, 0xb9, 0x1d, 0xbf, 0x71, 0xe4, 0x9d, 0x7a, 0xe3, 0x77, 0xcb, 0x1d, 0x61, 0xf9, 0x0c, 0xad,
		0xf1, 0xc1, 0xb7, 0xba, 0xa1, 0xaa, 0xbf, 0x74, 0x1e, 0x1c, 0xde, 0xa3, 0x07, 0x96, 0xef, 0x2c,
		0x7e, 0xb0, 0xa8, 0xf3, 0x88, 0xb9, 0x4e, 0x00, 0x50, 0x1c, 0x42, 0x31, 0x6e, 0xac, 0x27, 0x75,
		0x24, 0x3e, 0xa9, 0xec, 0x2e, 0x8d, 0x77, 0x02, 0xb0, 0xa8, 0x00, 0xf6, 0xf2, 0xf1, 0x1a, 0x05,
		0xc8, 0x3e, 0x6f, 0xee, 0xfa, 0x2d, 0x3f, 0xe2, 0xd0, 0xed, 0x57, 0xa8, 0x8a, 0xc3, 0xe8, 0x75,
		0x2c, 0x72, 0xb9, 0x91, 0xbb, 0xa6, 0x25, 0xb4, 0x40, 0xf4, 0xe8, 0xf4, 0x23, 0x61, 0x88, 0x2e,
		0x70, 0x76, 0x12, 0xcc, 0xd4, 0x04, 0x88, 0xae, 0xd1, 0x36, 0xc2, 0x4c, 0x4d, 0x98, 0xa9, 0xa9,
		0x51, 0x90, 0xb2, 0x31, 0xa7, 0x30, 0x53, 0x93, 0x73, 0x01, 0x0b, 0x07, 0xea, 0xfa, 0x04, 0xc3,
		0xc5, 0xa0, 0x4f, 0x50, 0xb7, 0x68, 0xab, 0x16, 0x71, 0x6d, 0xa2, 0xae, 0x4d, 0xe4, 0x35, 0x88,
		0xbe, 0x9c, 0x0a, 0x50, 0x10, 0x89, 0x40, 0x4a, 0xfb, 0x04, 0x55, 0x88, 0xb5, 0x06, 0xf1, 0x96,
		0x84, 0xb2, 0xda, 0xc5, 0x5d, 0x87, 0xd8, 0xeb, 0x12, 0x7f, 0x5d, 0x6a, 0x40, 0xbb, 0x3a, 0xd0,
		0xae, 0x16, 0x34, 0xaa, 0x07, 0x35, 0x6a, 0x42, 0x91, 0xba, 0x50, 0xae, 0x36, 0x92, 0x05, 0xa1,
		0x4f, 0x10, 0x41, 0x9f, 0x60, 0xb6, 0xea, 0x26, 0x33, 0xb5, 0x93, 0x99, 0xfa, 0xc9, 0x40, 0x0d,
		0xa9, 0x55, 0x47, 0x8a, 0xd5, 0x92, 0x4a, 0x47, 0x67, 0xe5, 0xda, 0xd0, 0x27, 0xb8, 0x46, 0xcb,
		0x40, 0x9f, 0x60, 0xe6, 0xbc, 0x0e, 0x7d, 0x82, 0x22, 0xca, 0x17, 0xfa, 0x04, 0x55, 0xf3, 0x36,
		0xf4, 0x09, 0xe6, 0x51, 0xe4, 0xe6, 0xf3, 0xb7, 0x67, 0x95, 0xd3, 0x3a, 0x6a, 0xf5, 0x31, 0x6a,
		0xd8, 0x8f, 0x16, 0xe9, 0x62, 0x1b, 0x5d, 0x91, 0xae, 0xff, 0x3c, 0xa4, 0x8e, 0x47, 0x50, 0x93,
		0x86, 0x56, 0xd3, 0xb7, 0xd1, 0x61, 0xe3, 0xaa, 0x59, 0x68, 0x13, 0x84, 0x2e, 0x9c, 0x61, 0x1f,
		0xfb, 0xa8, 0xe1, 0x3e, 0x78, 0xbe, 0x43, 0xfb, 0x03, 0xe4, 0x90, 0x38, 0x01, 0x78, 0x7b, 0x73,
		0xb7, 0x2c, 0x7b, 0x18, 0xde, 0x13, 0x25, 0x10, 0x67, 0xd3, 0x7e, 0x37, 0x66, 0xe3, 0xaa, 0x39,
		0x49, 0xf8, 0x35, 0x70, 0x70, 0xd1, 0xbb, 0x2f, 0x57, 0xce, 0xa0, 0x39, 0x30, 0xc7, 0x90, 0x31,
		0xaf, 0xbc, 0x02, 0x1d, 0x81, 0x1b, 0xd1, 0xa5, 0xf9, 0xe8, 0x08, 0x1c, 0xfa, 0xce, 0xe3, 0xb4,
		0xf1, 0xcb, 0xc2, 0x41, 0x51, 0x5d, 0x74, 0x10, 0xf1, 0x56, 0xed, 0xde, 0xf9, 0xce, 0xe3, 0xb7,
		0x06, 0x0e, 0xa0, 0x23, 0x70, 0xf3, 0x1d, 0x81, 0x0b, 0x8c, 0xb1, 0x8d, 0xd3, 0x33, 0x6d, 0x95,
		0x59, 0x31, 0x1b, 0xb2, 0x62, 0x19, 0xc6, 0xab, 0x20, 0x2b, 0x06, 0x59, 0x31, 0x9d, 0x62, 0xad,
		0x41, 0xbc, 0x17, 0x82, 0x41, 0x90, 0x15, 0xcb, 0xad, 0xdb, 0x01, 0x59, 0xb1, 0xad, 0x09, 0x3a,
		0x40, 0x56, 0x0c, 0xb2, 0x62, 0xba, 0xd5, 0xcc, 0x26, 0xa2, 0x1c, 0x90, 0x15, 0xdb, 0x4c, 0x3c,
		0x01, 0xb2, 0x62, 0x90, 0x15, 0x63, 0xf9, 0x01, 0xc8, 0x8a, 0x2d, 0x90, 0x04, 0xb2, 0x62, 0x22,
		0xca, 0x17, 0xb2, 0x62, 0xaa, 0x79, 0x1b, 0xb2, 0x62, 0x79, 0x14, 0xb9, 0xbc, 0x4e, 0xcf, 0xbc,
		0xbc, 0x6a, 0xde, 0xf9, 0xce, 0x23, 0x24, 0xc7, 0x72, 0x8c, 0x1c, 0x73, 0xce, 0x32, 0x90, 0x23,
		0xdb, 0x88, 0x66, 0xcd, 0x63, 0x8e, 0xcc, 0xc6, 0x41, 0xd1, 0xde, 0x70, 0x8e, 0xec, 0x12, 0x72,
		0x64, 0x5a, 0x18, 0x44, 0x96, 0x31, 0x60, 0x6a, 0xe6, 0xe6, 0xf0, 0xcd, 0x0e, 0x4f, 0xcd, 0x54,
		0x8c, 0x5e, 0x60, 0x6a, 0x66, 0xde, 0xa7, 0x37, 0xa8, 0xc5, 0x1e, 0x30, 0x35, 0x33, 0x23, 0x13,
		0x00, 0x53, 0x33, 0x27, 0x6b, 0x0c, 0x46, 0x01, 0xdd, 0xe4, 0x5c, 0x9d, 0xe3, 0x63, 0xd1, 0x31,
		0x83, 0xd3, 0x58, 0x97, 0xef, 0x7b, 0xfe, 0x0d, 0x0e, 0x02, 0xeb, 0x01, 0xab, 0x2b, 0x22, 0xf9,
		0xde, 0xc7, 0x04, 0x85, 0x4c, 0x63, 0x75, 0x9f, 0xd1, 0x61, 0xd7, 0x23, 0xbd, 0x78, 0x20, 0x9a,
		0xe5, 0x3a, 0xf4, 0xb9, 0x80, 0x9c, 0x00, 0x8d, 0x02, 0x6c, 0x1f, 0xbd, 0x1a, 0x50, 0x89, 0x42,
		0x7a, 0x22, 0xcb, 0x0d, 0x3c, 0x74, 0x8f, 0xa3, 0x2b, 0x64, 0x2b, 0x51, 0x14, 0x9a, 0x80, 0x59,
		0xf5, 0x8f, 0x43, 0xa2, 0x99, 0x83, 0x31, 0xd5, 0x14, 0x98, 0x2a, 0x1d, 0xea, 0x7f, 0x4e, 0xf5,
		0x2b, 0xdb, 0x90, 0xed, 0x82, 0x7e, 0xfc, 0xa3, 0x7a, 0x8e, 0xb6, 0x7b, 0x76, 0x2e, 0x4e, 0xca,
		0x6c, 0x61, 0x6e, 0x2e, 0xbf, 0x94, 0x2c, 0xa1, 0x22, 0xcc, 0xcc, 0xcd, 0x70, 0x66, 0xae, 0xc0,
		0x98, 0x29, 0xa1, 0xc8, 0x82, 0xb6, 0x99, 0xb9, 0x07, 0x0a, 0xf7, 0x20, 0x94, 0x1e, 0xce, 0xf1,
		0xb8, 0xc6, 0x47, 0x27, 0xa0, 0x0d, 0x4a, 0xf9, 0x2a, 0x49, 0x8c, 0x1b, 0x87, 0x5c, 0xb9, 0x11,
		0x8c, 0xe7, 0x1c, 0xe2, 0x68, 0xdc, 0x58, 0x4f, 0x33, 0x77, 0x96, 0xcf, 0xaa, 0xd5, 0xd3, 0xb7,
		0xd5, 0x6a, 0xe9, 0xed, 0xc9, 0xdb, 0xd2, 0x79, 0xad, 0x56, 0x3e, 0x2d, 0x73, 0x0c, 0x37, 0x32,
		0x3e, 0xf9, 0x36, 0xf6, 0xb1, 0xfd, 0x3e, 0x7c, 0x6b, 0x32, 0x72, 0x5d, 0x91, 0x5b, 0xc3, 0x2d,
		0xe6, 0x9a, 0x1e, 0xc9, 0xba, 0x19, 0x12, 0x70, 0x51, 0xc2, 0xfb, 0x97, 0x18, 0x65, 0x96, 0x37,
		0x67, 0xaf, 0x15, 0xd1, 0x6d, 0xb3, 0xb3, 0xd5, 0x64, 0xdd, 0x76, 0x3d, 0xe3, 0xd5, 0xf2, 0xb9,
		0x53, 0xba, 0xdd, 0xb5, 0x03, 0xb5, 0x06, 0x8e, 0x55, 0x8e, 0x05, 0x0d, 0x1a, 0x9f, 0x21, 0xe3,
		0x60, 0x2f, 0x1e, 0xdb, 0xc5, 0xb6, 0x27, 0xe9, 0x94, 0x5d, 0x7f, 0x45, 0x0a, 0x25, 0x27, 0x66,
		0x09, 0x93, 0x07, 0x87, 0x60, 0xd3, 0x49, 0xf3, 0xd1, 0xf8, 0x6c, 0x12, 0xbf, 0x2d, 0x52, 0x62,
		0x83, 0x04, 0x6c, 0x8f, 0x80, 0xcd, 0x49, 0xa3, 0x2c, 0x27, 0x6f, 0x32, 0xf3, 0x24, 0x03, 0x3b,
		0x32, 0xb2, 0xe1, 0x7a, 0x0e, 0x5c, 0xcd, 0x57, 0xcb, 0xff, 0xb2, 0x82, 0x1e, 0xac, 0x74, 0x48,
		0x7f, 0xff, 0x35, 0x2f, 0x9e, 0xf6, 0xc2, 0xcb, 0xdf, 0x74, 0xf1, 0x3d, 0x96, 0xbc, 0x83, 0xf1,
		0x68, 0x75, 0x07, 0x2b, 0x9f, 0x3c, 0x31, 0xd0, 0xd1, 0x55, 0x2b, 0x28, 0xb0, 0xbe, 0xb4, 0x3e,
		0xb5, 0xa6, 0x95, 0xa5, 0x36, 0x95, 0xb5, 0xc6, 0x94, 0xd5, 0xfe, 0x72, 0xd7, 0x7c, 0x72, 0x1b,
		0x53, 0x8e, 0x1a, 0x4c, 0x3e, 0x7e, 0x4b, 0x2b, 0xbd, 0x36, 0x1e, 0x7c, 0x6f, 0x34, 0x4c, 0xa7,
		0xc0, 0x84, 0xa2, 0xf1, 0xe5, 0x69, 0x6a, 0x94, 0xa9, 0x7b, 0x82, 0xb9, 0x7c, 0x99, 0xa7, 0x1c,
		0x99, 0xb7, 0xbc, 0x98, 0x17, 0x82, 0x09, 0x97, 0xff, 0x0a, 0xe3, 0x2b, 0x81, 0xf2, 0x5c, 0x39,
		0x23, 0xc8, 0x5a, 0xad, 0x6f, 0x58, 0xdd, 0x2e, 0x0e, 0xd8, 0xfb, 0x78, 0xa6, 0xd3, 0xeb, 0xe2,
		0xfb, 0x58, 0x5d, 0x45, 0xae, 0x56, 0x1c, 0xee, 0x9a, 0x78, 0x91, 0x5a, 0x77, 0xd1, 0x1a, 0x76,
		0x51, 0xbc, 0x2f, 0x5d, 0x73, 0x2e, 0x0d, 0xee, 0x25, 0x6a, 0xc4, 0xd5, 0x06, 0x0e, 0x78, 0x5b,
		0x49, 0x8c, 0xae, 0x47, 0x28, 0x7e, 0xa2, 0xe2, 0xf3, 0xc1, 0x27, 0x0b, 0xc0, 0x29, 0x3e, 0x59,
		0xb8, 0xb1, 0x30, 0x22, 0x9c, 0xe9, 0xf9, 0xe4, 0x4f, 0xf1, 0x19, 0xb3, 0xb5, 0x49, 0xc4, 0xce,
		0x8b, 0x80, 0x73, 0x7c, 0xe4, 0x7b, 0xb7, 0xe1, 0x1c, 0x9f, 0x54, 0x12, 0xc3, 0x39, 0x3e, 0xd2,
		0x77, 0xc1, 0x39, 0x3e, 0x3c, 0x31, 0xe5, 0x5a, 0x1d, 0xfd, 0xee, 0xe0, 0xef, 0xe3, 0x48, 0x65,
		0x23, 0x42, 0xaa, 0xe8, 0xc2, 0x23, 0xd4, 0xf7, 0xdc, 0x49, 0xbc, 0xf2, 0xf7, 0xc6, 0xc5, 0xb4,
		0x8a, 0x99, 0x27, 0x46, 0x39, 0x13, 0xa1, 0xfc, 0xfd, 0xfa, 0xea, 0x8f, 0x71, 0x84, 0xb2, 0x71,
		0x11, 0x87, 0x28, 0x43, 0xa7, 0x39, 0xfe, 0xc1, 0x8b, 0x58, 0x37, 0xdf, 0xc9, 0xb6, 0x17, 0xee,
		0xfd, 0x61, 0x3e, 0x39, 0xdc, 0x4d, 0x38, 0xd1, 0x87, 0x1d, 0xb4, 0x9b, 0x03, 0x8b, 0x76, 0xfb,
		0xd2, 0xd0, 0x7d, 0xbc, 0x0c, 0xef, 0x29, 0x2c, 0x71, 0xa7, 0x99, 0x90, 0x4e, 0x32, 0xf0, 0x93,
		0xd5, 0xa5, 0x7c, 0x7b, 0xdd, 0x01, 0x07, 0x03, 0x1c, 0x8c, 0x1d, 0x72, 0x30, 0x30, 0x19, 0x0d,
		0xb0, 0x2f, 0x7a, 0xce, 0x75, 0xe2, 0x5f, 0x08, 0x4c, 0x5a, 0x32, 0xae, 0xc8, 0x68, 0x20, 0xce,
		0x2c, 0x2d, 0xaf, 0x19, 0xb7, 0x53, 0x4b, 0x15, 0xa1, 0x96, 0x23, 0x1a, 0x44, 0x6a, 0x40, 0xc2,
		0x80, 0x57, 0x66, 0x58, 0x36, 0xd3, 0x5a, 0xdc, 0x96, 0x77, 0x4d, 0xa8, 0x1c, 0x05, 0xe2, 0x97,
		0x97, 0x6a, 0xa9, 0x9f, 0xbc, 0x7a, 0x1d, 0x55, 0xa0, 0x30, 0x17, 0xd0, 0xf2, 0x5a, 0x7c, 0x75,
		0x23, 0x60, 0xe4, 0x01, 0x2c, 0xe7, 0x7a, 0x33, 0x01, 0x2b, 0x33, 0xec, 0x24, 0xf1, 0xa8, 0xd3,
		0x7b, 0x36, 0x1f, 0x1d, 0xfc, 0x5d, 0xe2, 0x9c, 0xfa, 0x99, 0x45, 0x00, 0x87, 0x02, 0x0e, 0xdd,
		0x21, 0x1c, 0x1a, 0xf2, 0x34, 0x44, 0xb9, 0xc5, 0x43, 0xb0, 0x70, 0x5a, 0x3d, 0x44, 0xb9, 0x21,
		0xca, 0xbd, 0xe7, 0xb8, 0x5d, 0x04, 0xec, 0xb1, 0xc0, 0xbd, 0xdb, 0x08, 0x77, 0x84, 0xcf, 0x02,
		0xe7, 0xd6, 0x67, 0x8c, 0xde, 0x33, 0xda, 0x52, 0xc0, 0xf0, 0x4c, 0xba, 0xc1, 0xb2, 0x25, 0x11,
		0xfc, 0x74, 0x09, 0xc0, 0xef, 0x80, 0xdf, 0x01, 0xbf, 0x03, 0x7e, 0x07, 0xfc, 0x0e, 0xf8, 0x1d,
		0xf0, 0x3b, 0xe0, 0x77, 0x5d, 0xa1, 0xda, 0xcf, 0xd8, 0xb2, 0x01, 0xb9, 0x6f, 0x00, 0xb9, 0x6b,
		0xdf, 0x4c, 0xc0, 0xec, 0x0c, 0x3b, 0x19, 0x8c, 0xbb, 0x58, 0x4d, 0x17, 0x3f, 0x62, 0x57, 0x1c,
		0xb8, 0xbf, 0x5a, 0x07, 0xd0, 0x3b, 0xa0, 0xf7, 0x1d, 0x42, 0xef, 0x52, 0xdc, 0x8d, 0x76, 0xa6,
		0x10, 0x84, 0x78, 0xa6, 0x35, 0xa2, 0x7d, 0x93, 0x78, 0xa6, 0xe0, 0x20, 0x90, 0x64, 0xbd, 0xa8,
		0x24, 0x44, 0xd5, 0x62, 0x27, 0xc9, 0x62, 0x43, 0xee, 0xd9, 0x21, 0x92, 0x30, 0x5c, 0x45, 0x89,
		0xc9, 0x1c, 0x19, 0xea, 0x48, 0x02, 0x86, 0xcf, 0x10, 0xa1, 0x8e, 0x4e, 0x24, 0xd6, 0x79, 0xbd,
		0xd3, 0x75, 0x54, 0x86, 0xd2, 0x15, 0x80, 0xd0, 0xcb, 0x51, 0xd7, 0x64, 0x12, 0xc6, 0x47, 0x41,
		0xe5, 0x08, 0x18, 0x3a, 0xbf, 0xbb, 0x09, 0x20, 0x9a, 0x07, 0x44, 0x0f, 0xc2, 0x3d, 0x52, 0x00,
		0xa2, 0xe3, 0x75, 0x00, 0x44, 0x03, 0x88, 0xde, 0x45, 0x10, 0x1d, 0x71, 0xb7, 0xe9, 0xf9, 0xa6,
		0x45, 0x9e, 0x65, 0xb0, 0xf4, 0xb9, 0xc0, 0xbd, 0xe3, 0xd7, 0xd8, 0xe0, 0x18, 0x48, 0x99, 0x7a,
		0x72, 0x15, 0xee, 0x84, 0x1a, 0xb7, 0x42, 0xad, 0x7b, 0x91, 0xac, 0x56, 0x8a, 0x90, 0x3c, 0x79,
		0x36, 0x36, 0x3a, 0xcd, 0x5f, 0x1e, 0xd3, 0x4f, 0x01, 0x39, 0x79, 0x0e, 0x55, 0xeb, 0x3e, 0xcc,
		0xe3, 0x57, 0x20, 0x1d, 0x52, 0x06, 0x50, 0x95, 0x8e, 0x50, 0xa3, 0x2b, 0xe4, 0xa9, 0xa2, 0x49,
		0x77, 0xa8, 0xd4, 0x21, 0x6a, 0x75, 0x89, 0x1e, 0x9d, 0x32, 0x1f, 0xc2, 0x78, 0x2c, 0xab, 0x3c,
		0x30, 0x25, 0x8a, 0x62, 0x3c, 0x56, 0xba, 0x2a, 0xd7, 0x8c, 0x82, 0x19, 0xeb, 0x47, 0x63, 0x71,
		0xaf, 0x59, 0x0d, 0xd7, 0xa4, 0xab, 0x66, 0x66, 0x65, 0xac, 0x5e, 0x35, 0xa8, 0xd9, 0x64, 0xc9,
		0xf0, 0x1d, 0xa5, 0xcf, 0xb5, 0x9f, 0x5b, 0x71, 0x14, 0xad, 0x78, 0xa2, 0x70, 0xc5, 0xc7, 0xb2,
		0xda, 0x13, 0x3a, 0x23, 0x06, 0x14, 0xed, 0x2d, 0x52, 0x67, 0x6b, 0xd4, 0xac, 0x20, 0xc9, 0x5b,
		0x0a, 0xb5, 0xad, 0x43, 0xe8, 0x49, 0x45, 0xa1, 0x9e, 0x55, 0xc0, 0x42, 0xc6, 0x67, 0x8b, 0x3c,
		0xa8, 0x3b, 0x81, 0x4f, 0xa1, 0xdc, 0xa9, 0xa8, 0xf5, 0x58, 0x58, 0x54, 0x51, 0xed, 0xc7, 0xc2,
		0xba, 0xaa, 0xeb, 0x14, 0x16, 0x59, 0x48, 0x55, 0xdd, 0x82, 0x26, 0xcd, 0x8b, 0x54, 0xd5, 0x8e,
		0xac, 0xdc, 0xb2, 0x4a, 0xb9, 0xfa, 0xb6, 0x7a, 0x76, 0x72, 0x5a, 0x7d, 0x0b, 0x7b, 0xa7, 0x4c,
		0xb3, 0xaa, 0x59, 0xa5, 0xb3, 0x5d, 0xa7, 0xf0, 0x40, 0x0d, 0x8e, 0x1e, 0x57, 0x2b, 0x8f, 0x21,
		0xe7, 0x1b, 0x59, 0xaf, 0x0f, 0x12, 0x08, 0xb9, 0xdb, 0x4d, 0x48, 0x20, 0x30, 0x6c, 0xe5, 0x77,
		0xdf, 0xa1, 0x58, 0xb2, 0x74, 0x7e, 0x66, 0x0d, 0x48, 0x1c, 0xe8, 0xd2, 0x10, 0x90, 0x38, 0x80,
		0xda, 0xf9, 0x2c, 0xac, 0x34, 0xd4, 0xce, 0xeb, 0xf6, 0x87, 0xa0, 0x76, 0x7e, 0xbb, 0xed, 0x30,
		0xe0, 0xf6, 0xcd, 0x23, 0xbd, 0x3f, 0x42, 0xc8, 0x01, 0xc5, 0xf3, 0x3b, 0x82, 0xdb, 0xe7, 0x77,
		0x73, 0x7f, 0x71, 0xbb, 0x8e, 0x23, 0xe2, 0xc6, 0x33, 0x1c, 0xd1, 0x7c, 0x82, 0x13, 0x09, 0xd5,
		0x15, 0xc3, 0x19, 0x72, 0x70, 0x86, 0x5c, 0x1e, 0xad, 0x01, 0x9c, 0x1f, 0xb7, 0x0d, 0x5a, 0x1e,
		0xce, 0x8e, 0x5b, 0x72, 0xdf, 0xfa, 0x73, 0xaa, 0x42, 0xe2, 0x15, 0xa3, 0x23, 0x83, 0x8a, 0x5c,
		0x87, 0xbe, 0xa0, 0xb4, 0x53, 0xac, 0x7e, 0xb7, 0xba, 0x83, 0x6f, 0xff, 0x08, 0x17, 0xfe, 0x16,
		0x6f, 0x8e, 0xb2, 0xf3, 0xe3, 0x18, 0x8e, 0x0c, 0x1a, 0xe0, 0xc1, 0x3d, 0xf6, 0xf9, 0xcf, 0xbd,
		0x19, 0xdf, 0x07, 0xe7, 0xde, 0x64, 0x16, 0x33, 0xda, 0xe3, 0x73, 0x6f, 0xa0, 0xb2, 0x1a, 0x02,
		0xa4, 0x10, 0x20, 0xd5, 0xca, 0xdd, 0x08, 0x4a, 0xaa, 0xd1, 0x2e, 0x97, 0x54, 0xab, 0x2b, 0x7b,
		0x54, 0x59, 0xee, 0xa8, 0xb2, 0xcc, 0x51, 0x51, 0x79, 0x63, 0x8e, 0xaa, 0xc6, 0x95, 0x95, 0x31,
		0xaa, 0x2b, 0x5f, 0x54, 0x56, 0xb6, 0xa8, 0xa4, 0x5c, 0x71, 0x7f, 0x4a, 0xe2, 0x65, 0xcb, 0x10,
		0x15, 0x94, 0x1f, 0x2a, 0x2a, 0x3b, 0x54, 0x20, 0x17, 0x2a, 0xcb, 0x0c, 0x55, 0x97, 0x17, 0x6a,
		0x2b, 0x4d, 0x53, 0x5f, 0x92, 0xa6, 0xa0, 0x8c, 0x50, 0x69, 0xf9, 0xa0, 0xb6, 0xb2, 0xc1, 0x6d,
		0xda, 0x13, 0x28, 0xcb, 0x93, 0xc0, 0xd0, 0x42, 0x21, 0xf1, 0x59, 0xb5, 0x32, 0x1b, 0xe0, 0x16,
		0xc0, 0xc0, 0x2a, 0x43, 0xe4, 0xc9, 0xa2, 0xe2, 0xa1, 0xf2, 0xc5, 0x25, 0xb8, 0x43, 0xe6, 0xa2,
		0x3b, 0x01, 0x89, 0x56, 0xa5, 0x41, 0x5b, 0x28, 0x8d, 0x94, 0x75, 0xf9, 0xf3, 0xb8, 0x8f, 0x50,
		0x14, 0xc9, 0x13, 0xfb, 0x1b, 0x07, 0xcf, 0x65, 0x43, 0x7f, 0x02, 0x15, 0x64, 0x10, 0xf9, 0x83,
		0xc8, 0xdf, 0x76, 0x44, 0xfe, 0xa0, 0x3c, 0x72, 0x53, 0xfe, 0x1f, 0x94, 0x47, 0xa6, 0x93, 0x18,
		0xca, 0x23, 0x73, 0xee, 0x3f, 0x01, 0x6a, 0xd7, 0x82, 0xf6, 0xa0, 0x2e, 0x72, 0x27, 0x40, 0x3b,
		0x14, 0x44, 0x2a, 0xd3, 0x38, 0x93, 0x82, 0x48, 0x11, 0xe0, 0x02, 0x85, 0x8f, 0x50, 0xf8, 0x28,
		0xa3, 0xe7, 0x43, 0xed, 0x10, 0x89, 0xbc, 0x72, 0x05, 0xd1, 0xf2, 0xa2, 0x2a, 0x2e, 0xa8, 0x80,
		0x54, 0xa9, 0xcf, 0x33, 0xda, 0x2e, 0x28, 0x85, 0x9c, 0x8f, 0xba, 0xb0, 0x96, 0x42, 0x72, 0xd5,
		0x01, 0x22, 0x8e, 0x52, 0xc8, 0x9b, 0x78, 0xe1, 0x0c, 0x4b, 0x21, 0xb9, 0x02, 0x4c, 0xd3, 0xd3,
		0x66, 0x39, 0x2c, 0x17, 0x5f, 0x1c, 0x09, 0xca, 0x20, 0xb5, 0x68, 0xa6, 0xdc, 0x94, 0x41, 0x72,
		0xc7, 0x7d, 0x92, 0xbd, 0x8a, 0x44, 0x8f, 0x37, 0xd8, 0x23, 0x12, 0xe4, 0x11, 0x0d, 0xee, 0x88,
		0x65, 0xdf, 0xc4, 0x2d, 0x9f, 0x64, 0x10, 0x47, 0x59, 0x60, 0x41, 0x3e, 0xa0, 0xf0, 0x22, 0x96,
		0x76, 0x94, 0x27, 0x9d, 0x68, 0x70, 0x26, 0x4f, 0xb4, 0xdb, 0x0a, 0x93, 0x0c, 0x20, 0x5b, 0x08,
		0xb5, 0x45, 0xa8, 0x40, 0x30, 0x92, 0x02, 0xc8, 0x3a, 0xeb, 0x3d, 0xda, 0x36, 0xd9, 0x3d, 0x90,
		0xbb, 0x22, 0x45, 0xf6, 0x27, 0xe1, 0x0e, 0x06, 0x8b, 0xcd, 0x17, 0xdd, 0xe0, 0x8f, 0x6a, 0x28,
		0x89, 0x66, 0x08, 0x44, 0x31, 0x04, 0xa2, 0x17, 0x69, 0x44, 0x15, 0x50, 0xa4, 0x02, 0x0a, 0x54,
		0x00, 0x9e, 0xe5, 0xd7, 0xcd, 0xd5, 0xd3, 0xc2, 0xa9, 0xc2, 0x17, 0x10, 0x55, 0xab, 0x6a, 0xdd,
		0x81, 0xdd, 0xd8, 0x39, 0xd5, 0xfe, 0xcc, 0x81, 0x9c, 0x92, 0x4d, 0x93, 0x63, 0xce, 0x18, 0x05,
		0x73, 0x6c, 0x82, 0x81, 0x93, 0x18, 0x83, 0x11, 0xeb, 0x29, 0xba, 0x9a, 0x3e, 0x6b, 0xde, 0xdc,
		0x60, 0x1a, 0xf3, 0x35, 0x37, 0xfc, 0x28, 0xcd, 0x72, 0xb0, 0x35, 0x59, 0x32, 0x47, 0x15, 0x78,
		0xa2, 0x09, 0xbc, 0x51, 0x04, 0x5e, 0x8d, 0x21, 0x1c, 0x35, 0x10, 0x56, 0x0f, 0x02, 0x51, 0x02,
		0x39, 0x88, 0xc0, 0xda, 0x14, 0x69, 0xe0, 0xa7, 0xae, 0x3b, 0xb2, 0x05, 0x22, 0x55, 0x93, 0x1b,
		0x21, 0x58, 0x05, 0xc1, 0xaa, 0x0c, 0x83, 0x55, 0xdf, 0x1d, 0xd7, 0xee, 0x5a, 0xbe, 0x6d, 0x7a,
		0xf7, 0xff, 0xc1, 0x5d, 0x6a, 0x3a, 0x36, 0x26, 0xd4, 0xe9, 0x39, 0x7c, 0x51, 0xe3, 0x24, 0x78,
		0xa5, 0xf4, 0xad, 0x20, 0x95, 0x08, 0xa9, 0xc4, 0x5c, 0x95, 0x8c, 0x84, 0xbf, 0xdd, 0xf2, 0x31,
		0xfe, 0x60, 0x0d, 0x1c, 0xf7, 0xb9, 0x39, 0xba, 0xa7, 0x3e, 0xc6, 0x7c, 0x37, 0xdd, 0x58, 0xc1,
		0x9f, 0x7c, 0x77, 0x44, 0xb2, 0x0d, 0x51, 0x15, 0x35, 0xee, 0xc0, 0x2e, 0xf1, 0xc4, 0xee, 0x45,
		0x71, 0x18, 0xa0, 0xa9, 0x43, 0x04, 0xf1, 0xd5, 0xe4, 0x46, 0xc0, 0x57, 0x80, 0xaf, 0x00, 0x5f,
		0x01, 0xbe, 0x02, 0x7c, 0x05, 0xf8, 0x0a, 0xf0, 0x15, 0xe0, 0x2b, 0xc0, 0x57, 0x73, 0x0c, 0x00,
		0x65, 0x56, 0x80, 0xac, 0xb6, 0x03, 0x59, 0x89, 0x9c, 0x38, 0x00, 0x55, 0x56, 0xab, 0xef, 0x87,
		0x2a, 0x2b, 0xa8, 0xb2, 0x92, 0xb6, 0x41, 0x80, 0x8f, 0xb3, 0xc3, 0x42, 0x50, 0x6e, 0xb5, 0x45,
		0xc0, 0x15, 0xea, 0xae, 0x96, 0x32, 0x12, 0xd4, 0x5d, 0x41, 0xdd, 0xd5, 0x06, 0xa5, 0x12, 0x6a,
		0xa9, 0xf2, 0xb7, 0x1b, 0x50, 0x1f, 0xc5, 0x78, 0x3e, 0x60, 0x7a, 0x79, 0x54, 0x48, 0x5e, 0xe1,
		0xea, 0xa8, 0x03, 0x0e, 0x6a, 0xb0, 0x52, 0x81, 0xe1, 0xed, 0xd7, 0xbc, 0x78, 0xea, 0x0b, 0x2f,
		0x7f, 0xd7, 0xc5, 0x37, 0x99, 0xff, 0xe6, 0xd5, 0x3b, 0x19, 0x8d, 0xd1, 0x43, 0xc8, 0xcc, 0xd8,
		0x5e, 0xaa, 0x0d, 0x97, 0xbf, 0x5c, 0xa2, 0xe5, 0xa2, 0x17, 0xa9, 0xaf, 0x89, 0x23, 0xa4, 0x14,
		0x82, 0xa5, 0xc6, 0x3b, 0x58, 0xe2, 0x1b, 0xac, 0xf1, 0x0c, 0x56, 0x75, 0xc6, 0x1d, 0xaf, 0xe0,
		0xd6, 0x55, 0x1c, 0xf1, 0x08, 0x3e, 0xc6, 0x4c, 0x2b, 0xdc, 0x32, 0xba, 0xde, 0x60, 0x30, 0x22,
		0x0e, 0x7d, 0x66, 0x2f, 0xf7, 0x9b, 0xde, 0x92, 0x56, 0x35, 0x86, 0x83, 0xae, 0xef, 0x0c, 0xc7,
		0x62, 0x11, 0x81, 0x18, 0xe4, 0xf5, 0xd0, 0xe4, 0x7e, 0x07, 0x07, 0xc7, 0x50, 0x36, 0xb8, 0xcb,
		0x65, 0x83, 0x63, 0x84, 0xeb, 0x10, 0x1b, 0x3f, 0x01, 0xc4, 0xdd, 0x0f, 0x88, 0x5b, 0x3b, 0xab,
		0xd6, 0xd1, 0x85, 0x87, 0x9f, 0x9c, 0x80, 0x86, 0x3f, 0x88, 0xee, 0x31, 0xfd, 0x8e, 0x31, 0x41,
		0xbf, 0x63, 0x3f, 0x70, 0x3c, 0x82, 0xca, 0x47, 0xc9, 0xc7, 0xca, 0x51, 0x88, 0x90, 0x2c, 0x62,
		0x27, 0xdf, 0x9c, 0x84, 0x0a, 0x22, 0x04, 0x59, 0xd7, 0x84, 0x62, 0x9f, 0x60, 0x6a, 0x06, 0xd4,
		0x22, 0xb6, 0xe5, 0xdb, 0xe1, 0x95, 0x4b, 0x20, 0xd7, 0x07, 0xdf, 0x1a, 0xe0, 0xf0, 0xcb, 0x29,
		0xd8, 0xba, 0xf8, 0x74, 0x73, 0xf3, 0xe5, 0xf6, 0xba, 0xf5, 0xaf, 0x08, 0x67, 0x85, 0x7c, 0x7e,
		0x31, 0xd1, 0x58, 0x7b, 0x0e, 0x78, 0xb7, 0x60, 0x6f, 0xf2, 0x06, 0x7f, 0x79, 0xed, 0xf0, 0x01,
		0x83, 0x34, 0x03, 0x86, 0xda, 0x2d, 0x0c, 0x45, 0xdd, 0x80, 0x0e, 0xd8, 0xf1, 0x53, 0x7c, 0x39,
		0x00, 0x9f, 0x6d, 0x06, 0x3e, 0x8a, 0x58, 0x8b, 0xc3, 0x94, 0x1b, 0x4e, 0xcf, 0xec, 0x61, 0x8b,
		0x8e, 0xfc, 0x74, 0x1b, 0xce, 0xb1, 0xc7, 0x2c, 0xcc, 0x28, 0xbb, 0xc9, 0x33, 0x4f, 0x9e, 0xe5,
		0x46, 0xc7, 0xaf, 0xa6, 0x6d, 0xa7, 0x3b, 0x60, 0x00, 0xc0, 0x00, 0xc4, 0x17, 0xc4, 0x27, 0xd8,
		0x30, 0xaa, 0xff, 0xf4, 0x03, 0x85, 0x5e, 0x3b, 0xce, 0xf1, 0x76, 0x8e, 0xe2, 0xf3, 0xa3, 0x26,
		0x20, 0x2c, 0x74, 0x27, 0xc6, 0x71, 0xcb, 0x49, 0x4b, 0x66, 0x1c, 0xb1, 0x04, 0x9f, 0x7a, 0xbf,
		0x4c, 0x0b, 0x28, 0x9c, 0x3d, 0x44, 0x9c, 0x96, 0xff, 0x80, 0x29, 0x07, 0xe4, 0x8c, 0xaf, 0x17,
		0x8b, 0xd7, 0xc5, 0x37, 0x43, 0xac, 0x6e, 0x2f, 0x62, 0x75, 0x90, 0x8d, 0xde, 0xa7, 0x6c, 0xf4,
		0x49, 0x9d, 0x3d, 0x9b, 0xd9, 0x26, 0x08, 0x35, 0x86, 0x43, 0xd7, 0xe9, 0x46, 0x38, 0x24, 0x98,
		0x06, 0x75, 0x5a, 0x8d, 0xcf, 0xff, 0xb8, 0x6a, 0x25, 0x11, 0x9d, 0x56, 0xa4, 0x2f, 0x1a, 0xb6,
		0xed, 0xef, 0x7d, 0x7e, 0x39, 0x13, 0xfa, 0x6e, 0x4f, 0xc8, 0xec, 0x28, 0xcd, 0xa2, 0x99, 0x43,
		0xcb, 0xb7, 0x06, 0x01, 0xaf, 0x61, 0x9b, 0xdc, 0x26, 0x63, 0xdf, 0x50, 0xb4, 0x06, 0xa6, 0xd8,
		0x07, 0x4b, 0x07, 0x96, 0x0e, 0x2c, 0xdd, 0x1e, 0x5b, 0xba, 0x63, 0x4e, 0x55, 0x7c, 0x17, 0x69,
		0x1f, 0x30, 0x76, 0x19, 0x91, 0x18, 0x52, 0x44, 0xe0, 0xb0, 0x6f, 0x9d, 0xc3, 0xce, 0x13, 0x21,
		0xa4, 0x6a, 0x22, 0x84, 0x2d, 0xdf, 0x22, 0xc1, 0xd0, 0xf3, 0x29, 0x04, 0x08, 0x21, 0xf7, 0x94,
		0xcb, 0xdc, 0x53, 0xb0, 0xab, 0x99, 0xa7, 0x00, 0xf2, 0x4e, 0x60, 0x55, 0xf4, 0x5b, 0x95, 0xa1,
		0xef, 0x3d, 0x71, 0x14, 0x6e, 0xc6, 0x97, 0x8b, 0x39, 0xc9, 0xd1, 0xbd, 0xe0, 0x23, 0x83, 0x8f,
		0x0c, 0x3e, 0x32, 0xf8, 0xc8, 0xeb, 0x1d, 0xb8, 0xbb, 0xcf, 0x9f, 0xfe, 0x67, 0x5a, 0xdf, 0x77,
		0x17, 0x2a, 0x0e, 0xf0, 0x8d, 0x35, 0x93, 0x76, 0xdb, 0x7d, 0xe2, 0xdc, 0x62, 0xd4, 0x08, 0x12,
		0xb1, 0x18, 0xce, 0x2d, 0x85, 0xaa, 0x33, 0xef, 0x07, 0x88, 0x15, 0x10, 0xab, 0x6e, 0xc4, 0x1a,
		0xb5, 0xb8, 0xb1, 0x0f, 0x16, 0x5f, 0xdf, 0x10, 0xc7, 0x1c, 0x09, 0x49, 0xe9, 0xf1, 0x04, 0x2c,
		0x0b, 0x15, 0x53, 0xa0, 0x78, 0x76, 0x5b, 0xf1, 0x60, 0xf2, 0xe0, 0x10, 0xcc, 0xae, 0x7a, 0xc6,
		0xd7, 0x2b, 0x50, 0x3e, 0x21, 0x70, 0x43, 0xf1, 0x72, 0xa0, 0x68, 0x40, 0xd1, 0x80, 0xa2, 0xd9,
		0x6d, 0x45, 0x43, 0x3c, 0xea, 0xf4, 0x38, 0x82, 0x72, 0xe3, 0xeb, 0xf9, 0x14, 0x4d, 0x9c, 0x14,
		0x0d, 0x10, 0xed, 0x5b, 0x14, 0x7d, 0x77, 0x5c, 0x17, 0xf9, 0xb8, 0x8b, 0x9d, 0x47, 0x8c, 0xa2,
		0xe5, 0x66, 0x1c, 0xc7, 0x36, 0xb9, 0x22, 0xd4, 0x77, 0x70, 0x80, 0x1c, 0x82, 0x68, 0xdf, 0x09,
		0x90, 0xeb, 0x04, 0x14, 0x59, 0x3e, 0x46, 0x03, 0x6b, 0x38, 0xc4, 0x36, 0x2a, 0x9b, 0x65, 0x44,
		0x3d, 0x84, 0x93, 0xcb, 0xda, 0x24, 0x24, 0xd8, 0x6d, 0xf4, 0x5c, 0x91, 0x77, 0x79, 0x84, 0xf0,
		0x53, 0x17, 0x0f, 0x69, 0xfc, 0x73, 0x4e, 0x0f, 0x59, 0x24, 0xba, 0xfc, 0x39, 0x5c, 0xf3, 0xd5,
		0xb5, 0x6d, 0xd2, 0xb7, 0x82, 0xf0, 0x82, 0xd9, 0xef, 0x1f, 0xa2, 0xa3, 0x88, 0xbe, 0xf7, 0x9d,
		0x6e, 0x1f, 0x11, 0x0f, 0xcd, 0x17, 0x31, 0x85, 0xcf, 0xf7, 0xdc, 0x26, 0x51, 0x53, 0x62, 0x70,
		0x14, 0xaa, 0x4c, 0x12, 0xe9, 0xcd, 0x57, 0x0b, 0x4f, 0x7e, 0x31, 0x08, 0x5f, 0x71, 0xf2, 0xec,
		0xd4, 0x43, 0x16, 0x69, 0x93, 0xe4, 0x61, 0x92, 0x17, 0x04, 0x4d, 0x0b, 0xe1, 0x49, 0x08, 0x4f,
		0x42, 0x78, 0x72, 0x49, 0x0c, 0xed, 0xf6, 0x53, 0xeb, 0xfa, 0xc3, 0xf5, 0x45, 0xa3, 0x75, 0xfd,
		0xe9, 0x36, 0x09, 0xa5, 0xcd, 0x28, 0x1a, 0x08, 0x53, 0xea, 0x27, 0xf1, 0x4e, 0x94, 0xac, 0xc6,
		0x96, 0xdb, 0xec, 0x39, 0x2e, 0xc5, 0xbe, 0x39, 0xf4, 0xbd, 0x9e, 0xe3, 0x62, 0x5e, 0xc3, 0xff,
		0xfa, 0x76, 0x3e, 0x1c, 0x70, 0x3b, 0x63, 0xed, 0x51, 0xbc, 0x12, 0x1a, 0xaf, 0x14, 0x1b, 0xff,
		0x56, 0x1f, 0x23, 0x17, 0x5b, 0x3d, 0x14, 0x4f, 0x18, 0x8a, 0x4b, 0x5d, 0x8b, 0x4b, 0x7f, 0x3a,
		0x34, 0xad, 0xa3, 0x00, 0xdb, 0x6d, 0x12, 0x5a, 0xd5, 0x20, 0xf0, 0xba, 0x8e, 0x45, 0x31, 0xb2,
		0x5e, 0xad, 0x8b, 0xbe, 0x3b, 0xb4, 0x8f, 0xac, 0x71, 0xd5, 0x6c, 0xf4, 0x23, 0xd7, 0xf3, 0x88,
		0x60, 0x8a, 0x32, 0x9c, 0x00, 0x45, 0xec, 0xed, 0xc7, 0xa6, 0xfa, 0xfe, 0x19, 0x79, 0x04, 0x23,
		0xcf, 0x47, 0x03, 0xcf, 0xc7, 0x6d, 0xc2, 0xf2, 0x4c, 0x14, 0x0f, 0x82, 0x23, 0x84, 0xad, 0x6e,
		0x1f, 0x05, 0xa3, 0x6e, 0xbf, 0x4d, 0x56, 0x3e, 0xbb, 0x8f, 0x87, 0x3e, 0x0e, 0xa2, 0xc9, 0x45,
		0xe3, 0x5f, 0x9a, 0x05, 0x32, 0x1f, 0xa2, 0xeb, 0xef, 0xe2, 0xcb, 0x23, 0xc8, 0x91, 0xfa, 0xe8,
		0x21, 0xce, 0x78, 0xf5, 0xf8, 0x16, 0x79, 0x66, 0x79, 0xec, 0x08, 0xc5, 0x2c, 0x03, 0x2c, 0x11,
		0x6d, 0x57, 0x3c, 0x54, 0x24, 0x19, 0x80, 0x5b, 0x00, 0xb7, 0x00, 0x6e, 0xd1, 0x8f, 0x5b, 0x38,
		0x92, 0x45, 0x12, 0xc0, 0x25, 0xf2, 0xdd, 0x67, 0x3d, 0xb2, 0xb1, 0x9e, 0xc8, 0x18, 0x62, 0x70,
		0xa7, 0x96, 0xf4, 0x60, 0x8c, 0x95, 0xd4, 0xc8, 0x1e, 0x0d, 0x1c, 0xed, 0x1b, 0xb2, 0x5d, 0xb4,
		0x34, 0xec, 0x77, 0x01, 0x2a, 0xde, 0x82, 0xed, 0xd9, 0xbd, 0xa2, 0xf8, 0x83, 0x35, 0x12, 0xcb,
		0xa2, 0xf3, 0x8d, 0x7b, 0xec, 0x7a, 0xe4, 0x21, 0x30, 0xa9, 0xb7, 0x52, 0x84, 0x19, 0x42, 0x9e,
		0xc9, 0x8c, 0xce, 0x75, 0x71, 0x4f, 0x46, 0x14, 0xc5, 0x83, 0xa0, 0x78, 0xa4, 0x48, 0x08, 0x39,
		0x09, 0x89, 0x0a, 0x27, 0x62, 0x92, 0x67, 0x83, 0x25, 0xaa, 0xda, 0xe8, 0x7a, 0x84, 0x5a, 0x5d,
		0x2a, 0xb3, 0xab, 0x7f, 0xfc, 0x03, 0xfd, 0x81, 0xef, 0xeb, 0x08, 0xa1, 0xf6, 0xa8, 0x54, 0x3a,
		0xe9, 0xf6, 0x29, 0x1d, 0xd6, 0x8b, 0x45, 0xea, 0x79, 0x6e, 0x70, 0x1c, 0x6e, 0xf9, 0xb1, 0xe7,
		0x3f, 0x14, 0xbf, 0x3f, 0x14, 0x09, 0xa6, 0x03, 0xcf, 0x2e, 0x46, 0x57, 0xe1, 0x36, 0xf9, 0xe3,
		0x1f, 0x28, 0x04, 0x66, 0xf5, 0xc9, 0x7d, 0x03, 0xcb, 0x71, 0xa9, 0x57, 0x8f, 0xaf, 0xfa, 0xef,
		0xc9, 0x8d, 0x33, 0x57, 0x5f, 0xf4, 0x2d, 0xc7, 0xaf, 0xa3, 0x56, 0xdf, 0x1b, 0x58, 0x01, 0xba,
		0xb5, 0x6c, 0x6c, 0x8d, 0x42, 0xd9, 0x9e, 0xfc, 0x6f, 0x6e, 0x19, 0x4a, 0xa2, 0xbf, 0xff, 0xb7,
		0x3b, 0xea, 0x3a, 0xf6, 0xa3, 0x13, 0x38, 0x1e, 0x39, 0xee, 0x7a, 0x83, 0xc9, 0x72, 0xb3, 0x0b,
		0xfe, 0xbf, 0x23, 0xec, 0x3f, 0x60, 0x82, 0x9a, 0xdd, 0xbe, 0x87, 0xc9, 0x77, 0x0b, 0xbb, 0x36,
		0xf6, 0x57, 0x2e, 0xfc, 0x9f, 0xe3, 0x60, 0xf6, 0xba, 0xff, 0xfe, 0x8f, 0xd5, 0xf5, 0xee, 0x03,
		0x73, 0x44, 0x9c, 0x47, 0xec, 0x07, 0x0e, 0x7d, 0x3e, 0xb6, 0xf1, 0xf4, 0x57, 0xae, 0x6c, 0x87,
		0x7a, 0x7e, 0x48, 0x9c, 0x1b, 0xcb, 0xa7, 0x0e, 0x41, 0xef, 0xff, 0xe3, 0xf9, 0x7f, 0xba, 0x23,
		0x62, 0xaf, 0xfc, 0x81, 0xc1, 0xfd, 0x7f, 0xfe, 0x9b, 0x5a, 0x8e, 0x6b, 0xf6, 0xe6, 0x1f, 0x78,
		0xba, 0x94, 0xae, 0x07, 0x56, 0x9c, 0x8e, 0x98, 0xf0, 0x96, 0xce, 0x7c, 0x04, 0x30, 0xdf, 0xce,
		0x30, 0x9f, 0x16, 0xfd, 0xe6, 0xf9, 0x0f, 0x16, 0x71, 0xfe, 0x9a, 0xcc, 0x93, 0x16, 0x56, 0x72,
		0xd7, 0x57, 0xad, 0x0f, 0xe8, 0xf6, 0xaa, 0x75, 0xf3, 0xe9, 0x12, 0x1d, 0xde, 0x5e, 0xb5, 0x2e,
		0x3e, 0xdd, 0x7e, 0x40, 0x97, 0x16, 0xb5, 0xe2, 0xb2, 0x17, 0x87, 0x3c, 0xa0, 0x8f, 0x16, 0x79,
		0x18, 0x59, 0x0f, 0xb8, 0x80, 0xfe, 0xf0, 0xfc, 0x3f, 0xc3, 0x6f, 0xfe, 0xe1, 0x7b, 0x23, 0xd5,
		0x39, 0xbe, 0xb9, 0x17, 0xd2, 0x29, 0x59, 0x12, 0x6f, 0xac, 0x65, 0x27, 0x7d, 0x1c, 0x0b, 0x92,
		0xcc, 0x2e, 0x56, 0x4a, 0xe5, 0xaa, 0x59, 0xae, 0x98, 0xe5, 0xd2, 0xba, 0x5d, 0x99, 0x0f, 0x0c,
		0x32, 0xc2, 0x90, 0x6b, 0xe2, 0x50, 0xc7, 0x72, 0xd1, 0xe4, 0x31, 0x8f, 0x35, 0x61, 0x12, 0x7b,
		0xe6, 0xe1, 0xb2, 0x00, 0x26, 0x8b, 0xef, 0xa5, 0x21, 0xfc, 0xfb, 0x79, 0xc6, 0x41, 0x64, 0xa4,
		0x77, 0xe8, 0x4f, 0xbc, 0xad, 0x96, 0xde, 0xd6, 0x51, 0x03, 0xfd, 0xab, 0x71, 0xfb, 0x8f, 0x19,
		0xd6, 0x8c, 0x32, 0xa4, 0x51, 0xa9, 0xc8, 0x5c, 0x11, 0x89, 0xa6, 0x0d, 0xe1, 0x71, 0xaf, 0xe4,
		0xb7, 0x43, 0xe0, 0xb5, 0x75, 0xa3, 0xca, 0xf5, 0x13, 0xf0, 0xd7, 0x4f, 0xf3, 0x5f, 0x3f, 0xc5,
		0x7f, 0x09, 0x45, 0xd7, 0x0d, 0xee, 0x9f, 0x7f, 0xd3, 0xe9, 0x93, 0xce, 0x3c, 0x93, 0x11, 0x3c,
		0x07, 0x14, 0x2f, 0x96, 0x4d, 0x4e, 0xbd, 0x89, 0xf8, 0xef, 0xaf, 0xde, 0x62, 0x79, 0xa4, 0x78,
		0x65, 0x64, 0x78, 0x9d, 0x0f, 0x33, 0xfb, 0x4b, 0xcb, 0xde, 0x2f, 0x85, 0x0b, 0x99, 0xdd, 0x13,
		0x66, 0x56, 0x9b, 0x77, 0x43, 0x9e, 0x03, 0x83, 0xf3, 0x8c, 0x83, 0x55, 0x55, 0x1c, 0x86, 0x35,
		0xa2, 0x7d, 0x4c, 0xe8, 0xd8, 0x79, 0x5f, 0xfd, 0x46, 0x13, 0x82, 0xbc, 0xba, 0x3e, 0x0f, 0x25,
		0x3a, 0xcf, 0xc1, 0x16, 0x56, 0xe8, 0x2c, 0xdb, 0x42, 0x4d, 0x05, 0x3a, 0xa3, 0x38, 0xee, 0xcc,
		0x3c, 0xad, 0x31, 0x35, 0x5c, 0x9b, 0x8f, 0x9c, 0xcc, 0x73, 0xb0, 0x83, 0x29, 0x99, 0x75, 0x6c,
		0xa1, 0x26, 0x23, 0x93, 0xc6, 0x2e, 0x73, 0x9a, 0xc1, 0xf3, 0x9d, 0xbf, 0xb0, 0x6d, 0xfe, 0x89,
		0x9f, 0xf9, 0xcf, 0x88, 0x7d, 0x75, 0x3f, 0xdf, 0x69, 0xb1, 0xe5, 0x5c, 0x9e, 0x16, 0xcb, 0xc4,
		0x72, 0x2a, 0xa3, 0xc2, 0x79, 0x38, 0x2c, 0x96, 0x85, 0x25, 0x39, 0x63, 0xad, 0x8c, 0x7b, 0xc5,
		0xca, 0xaa, 0x53, 0x96, 0x75, 0x1f, 0x3c, 0xdf, 0xa1, 0xfd, 0x01, 0x3f, 0xd1, 0x13, 0xae, 0x4d,
		0x96, 0xe0, 0xa4, 0x19, 0xdf, 0x31, 0xc7, 0xc2, 0x0c, 0x2c, 0xc3, 0xc8, 0x92, 0x0c, 0x2d, 0xcb,
		0xd8, 0xca, 0x18, 0x5c, 0x19, 0xa3, 0xcb, 0x33, 0x3c, 0x1f, 0xe3, 0x73, 0x0a, 0xc0, 0x4c, 0xea,
		0x9a, 0xd8, 0x16, 0xf5, 0xfc, 0x67, 0xfe, 0xe3, 0x7e, 0xf9, 0x0f, 0x5c, 0x5e, 0xe4, 0x12, 0xea,
		0x3b, 0xe4, 0x41, 0x84, 0x51, 0x92, 0xd3, 0x97, 0xb5, 0x52, 0x47, 0xe2, 0x70, 0x59, 0x89, 0xe4,
		0xa7, 0x78, 0x32, 0x74, 0x75, 0x74, 0xa2, 0x71, 0xdb, 0x40, 0xbf, 0x44, 0xb3, 0x6b, 0x30, 0x6a,
		0xf6, 0xb1, 0xeb, 0xa2, 0xc3, 0x66, 0xf3, 0xb7, 0xc2, 0x34, 0xe5, 0x76, 0x97, 0x8c, 0x23, 0xf8,
		0xa5, 0x4d, 0x7c, 0xfc, 0xe0, 0x04, 0xd4, 0x7f, 0x3e, 0x42, 0x77, 0xa3, 0x7b, 0xd7, 0xe9, 0xa2,
		0x7f, 0xe2, 0x67, 0xd4, 0x98, 0xe8, 0x2f, 0x14, 0xae, 0x1a, 0x08, 0x4a, 0x96, 0x0a, 0x31, 0x57,
		0x99, 0xe5, 0xd4, 0x26, 0xf9, 0xcb, 0xa3, 0x29, 0x1a, 0xf6, 0x41, 0xf8, 0xe9, 0x5e, 0x0e, 0xb2,
		0xb9, 0xab, 0xa3, 0xe9, 0xe8, 0x59, 0x0e, 0x69, 0x36, 0xfe, 0xc4, 0xcf, 0xa6, 0x6d, 0x51, 0x4b,
		0xdc, 0x7c, 0x27, 0x2b, 0x80, 0xf5, 0x06, 0xeb, 0x0d, 0xd6, 0xbb, 0x8e, 0x8c, 0x7b, 0x87, 0x58,
		0xfe, 0xb3, 0x84, 0xf5, 0x3e, 0x07, 0xe3, 0xcd, 0x1a, 0xea, 0xae, 0x56, 0x6a, 0x27, 0x75, 0xd4,
		0xea, 0x63, 0xb4, 0xc4, 0x78, 0x4c, 0xa7, 0xd3, 0x7d, 0xb4, 0x9e, 0xe7, 0x93, 0x71, 0x13, 0xbb,
		0x02, 0xd6, 0x5a, 0x40, 0xe2, 0x95, 0x10, 0x1e, 0xcc, 0x33, 0x03, 0xd5, 0xc7, 0xf1, 0x7c, 0x41,
		0xd3, 0xcc, 0x50, 0x03, 0x0c, 0x66, 0x19, 0xcc, 0x72, 0x66, 0x66, 0x79, 0x0b, 0x1d, 0xe3, 0x0d,
		0xc5, 0xe1, 0xd8, 0x8b, 0xf8, 0x93, 0x5b, 0xb8, 0x8a, 0xf9, 0xa7, 0x48, 0x89, 0xb7, 0xa8, 0x7f,
		0x06, 0x63, 0xc9, 0x17, 0xf7, 0x27, 0x8b, 0xf1, 0x17, 0xf9, 0x2f, 0xde, 0xca, 0x5c, 0xec, 0xcf,
		0xbb, 0x19, 0x12, 0x80, 0x49, 0x02, 0x28, 0x49, 0x48, 0xc9, 0x86, 0x80, 0x91, 0x4a, 0x85, 0x2a,
		0x0b, 0x84, 0xf4, 0xe8, 0xd4, 0xcd, 0x00, 0x9f, 0x17, 0x4d, 0x2a, 0xab, 0xa3, 0x54, 0x4a, 0x52,
		0x2a, 0x1a, 0x56, 0xde, 0xb7, 0xb4, 0xd2, 0x21, 0xaa, 0x36, 0x28, 0x8e, 0xff, 0x33, 0x9f, 0x00,
		0x2f, 0x8e, 0x02, 0xec, 0x17, 0x85, 0x52, 0x5d, 0x68, 0x45, 0xa1, 0x44, 0xf4, 0x33, 0xdf, 0xc6,
		0xff, 0x69, 0xcc, 0xfd, 0xda, 0xb7, 0x50, 0xab, 0x44, 0xdf, 0xc5, 0xbf, 0x16, 0x2a, 0x66, 0x45,
		0xd5, 0xed, 0x0c, 0x84, 0xe5, 0xc3, 0x7f, 0x22, 0xb8, 0x8f, 0x13, 0xef, 0x41, 0xf6, 0x4f, 0x87,
		0xae, 0xc9, 0x4b, 0xf6, 0x8f, 0x1b, 0x9f, 0x89, 0xe3, 0x32, 0x4e, 0x3c, 0xa6, 0x46, 0x9a, 0x86,
		0x56, 0x10, 0x8c, 0x77, 0x9a, 0x53, 0xa2, 0x92, 0x3b, 0x41, 0xaa, 0x40, 0xaa, 0x32, 0x93, 0xaa,
		0xae, 0xff, 0x3c, 0xa4, 0x66, 0xdf, 0x0a, 0xfa, 0x42, 0x92, 0xc5, 0x71, 0xcf, 0x9d, 0x45, 0x29,
		0xf6, 0x09, 0x37, 0x48, 0x35, 0xfe, 0x56, 0xfa, 0xdb, 0xf1, 0x9b, 0x9f, 0x7f, 0x2b, 0xff, 0xed,
		0xab, 0x65, 0xfe, 0xd5, 0x30, 0xff, 0x5d, 0x32, 0xcf, 0x8f, 0x8b, 0x9d, 0x1f, 0xe5, 0xa3, 0xb3,
		0x97, 0x57, 0x5f, 0x55, 0x2a, 0x2f, 0x3f, 0xff, 0x56, 0xfb, 0xdb, 0xa1, 0xef, 0x8d, 0x88, 0x1d,
		0xfc, 0x57, 0xbb, 0x6d, 0xff, 0xfa, 0xb7, 0xc2, 0xbb, 0xd7, 0xb7, 0x95, 0x4f, 0x5f, 0xdf, 0x57,
		0x3d, 0x79, 0xf9, 0xf9, 0xb7, 0x53, 0xfe, 0xfb, 0xce, 0x4e, 0x5f, 0x0c, 0xd5, 0x50, 0x08, 0x5a,
		0xb7, 0xa1, 0x75, 0x5b, 0xda, 0x5d, 0x4b, 0xc4, 0xdb, 0xf5, 0xba, 0x96, 0x6b, 0x86, 0x70, 0x36,
		0xd8, 0xcf, 0x6e, 0xed, 0x59, 0x02, 0xe4, 0xad, 0xb9, 0x34, 0xad, 0xb2, 0x94, 0xcf, 0xdb, 0x11,
		0xf3, 0x72, 0x58, 0xaa, 0x2d, 0x05, 0xdc, 0x19, 0x1d, 0x9d, 0x0a, 0xe1, 0xe3, 0x9a, 0xf3, 0xaf,
		0x60, 0x7a, 0xa1, 0x2c, 0xf3, 0x95, 0xc1, 0x2e, 0x5f, 0x82, 0xad, 0x36, 0xb6, 0x04, 0xb5, 0xb1,
		0xf2, 0x72, 0x9a, 0x75, 0x6d, 0x2c, 0x33, 0x38, 0x9a, 0x36, 0x4b, 0xdb, 0x21, 0x7f, 0xd0, 0x67,
		0x1f, 0xf7, 0x58, 0x28, 0x3e, 0x41, 0x43, 0x2c, 0xf6, 0xea, 0x7a, 0xbc, 0xf4, 0x7b, 0x2b, 0xc0,
		0x62, 0xd5, 0xb7, 0x33, 0xac, 0x3b, 0xc0, 0xb4, 0xef, 0x31, 0x3b, 0x0c, 0xbf, 0x5b, 0xee, 0x08,
		0x07, 0x5c, 0xf8, 0x4b, 0x30, 0x29, 0x24, 0xa6, 0x74, 0x8f, 0x74, 0x3f, 0x96, 0x6f, 0xd9, 0xce,
		0x48, 0xb9, 0x19, 0xe8, 0x68, 0x66, 0xdf, 0xad, 0x83, 0x61, 0x9c, 0x3c, 0xcd, 0x68, 0x85, 0x44,
		0x71, 0xc9, 0x7c, 0x03, 0x67, 0xf4, 0x94, 0xe6, 0x3d, 0x57, 0x34, 0x4f, 0x06, 0x8f, 0xcc, 0xe9,
		0xba, 0x51, 0xc0, 0x3a, 0x25, 0x46, 0x4d, 0x2c, 0xe2, 0x35, 0xd0, 0x0d, 0x1f, 0x3d, 0x73, 0x9c,
		0x3b, 0x18, 0x05, 0x54, 0x27, 0xc2, 0x3d, 0x3c, 0x46, 0xff, 0xcf, 0x7f, 0xa1, 0x76, 0x68, 0x48,
		0xea, 0xb1, 0x80, 0xb7, 0x0d, 0xe4, 0xf9, 0xe8, 0xf8, 0xb8, 0x78, 0x7c, 0x5c, 0x8c, 0xbf, 0x29,
		0x06, 0xd8, 0x7f, 0xc4, 0x7e, 0x81, 0x67, 0xd7, 0x79, 0x3a, 0x51, 0x57, 0x3e, 0xdc, 0x1f, 0x7d,
		0x4c, 0xd0, 0x2f, 0xf1, 0x43, 0xfc, 0x32, 0x99, 0x4c, 0x87, 0xe2, 0xc9, 0xb2, 0xf3, 0xba, 0x1c,
		0xc5, 0xba, 0xfc, 0xa8, 0x4d, 0x2c, 0xf4, 0xb9, 0x71, 0x79, 0xfd, 0xa5, 0x89, 0xe2, 0x87, 0x46,
		0x21, 0x01, 0xd1, 0x3d, 0x46, 0xdd, 0x71, 0x67, 0x21, 0xb6, 0x8f, 0x79, 0x11, 0xb5, 0x44, 0xd2,
		0x44, 0xbc, 0xff, 0x55, 0x4b, 0xba, 0x64, 0x7e, 0x00, 0x81, 0x26, 0xea, 0xe6, 0xa0, 0x28, 0xe3,
		0xca, 0xf7, 0x3d, 0xff, 0x06, 0x07, 0x81, 0xf5, 0x80, 0x15, 0xb3, 0xdf, 0x11, 0xca, 0x2f, 0x87,
		0xe1, 0xf0, 0xb5, 0xcd, 0xc1, 0xf8, 0xbd, 0x73, 0xcb, 0x63, 0x6c, 0x24, 0xdc, 0x6c, 0x15, 0x40,
		0x4e, 0x8e, 0x3e, 0xba, 0x7a, 0xa2, 0xeb, 0x21, 0x27, 0x7b, 0x03, 0x27, 0xb1, 0xba, 0x83, 0xba,
		0x8d, 0x7b, 0xd6, 0xc8, 0xa5, 0xa6, 0x8d, 0xc9, 0xb3, 0xf9, 0xdd, 0x77, 0x28, 0xe6, 0xeb, 0xe8,
		0x8c, 0x82, 0x3d, 0x1c, 0x2d, 0x9d, 0xbc, 0xfd, 0x9c, 0x9d, 0xdc, 0x1e, 0x01, 0xc5, 0xd4, 0xe3,
		0xab, 0xca, 0x93, 0xdc, 0xd0, 0x31, 0x50, 0xaf, 0xde, 0x31, 0xeb, 0xa3, 0xa0, 0x56, 0x75, 0x79,
		0xb3, 0x05, 0x72, 0xb8, 0x03, 0x38, 0xeb, 0x1a, 0xa4, 0xf9, 0x62, 0x36, 0x86, 0xf8, 0xc1, 0x0f,
		0x46, 0xd7, 0xf5, 0xba, 0x7f, 0xa6, 0xb7, 0x98, 0xc7, 0x97, 0x41, 0x67, 0x79, 0xfe, 0x3b, 0xcb,
		0xa9, 0x33, 0xc0, 0x7f, 0x79, 0x3c, 0xa7, 0xcc, 0x24, 0x77, 0xb0, 0x45, 0xd1, 0x6a, 0x10, 0x45,
		0xdb, 0xbe, 0x28, 0x1a, 0x73, 0x87, 0xf9, 0x84, 0x19, 0x4c, 0xb1, 0xc2, 0x92, 0xf9, 0xdb, 0xf9,
		0x72, 0xe1, 0x55, 0xc8, 0x85, 0x43, 0x2e, 0x9c, 0xbb, 0xbf, 0x5c, 0x8c, 0x61, 0x95, 0x30, 0x2e,
		0x67, 0x7e, 0x41, 0x9a, 0x91, 0x65, 0x18, 0x5a, 0x92, 0xb1, 0x55, 0xb8, 0x8a, 0x08, 0x4a, 0xe2,
		0x37, 0x52, 0x12, 0x2f, 0xc3, 0xda, 0x68, 0xfb, 0x2a, 0xe3, 0x65, 0x8a, 0xb1, 0x05, 0xd2, 0xfa,
		0x62, 0x59, 0x0d, 0xb5, 0x1b, 0xa4, 0x50, 0x28, 0x85, 0x13, 0xff, 0x7a, 0x05, 0x73, 0x9e, 0x44,
		0x50, 0x20, 0xcd, 0xe9, 0x79, 0x46, 0xee, 0x5b, 0x71, 0x42, 0xc4, 0xa2, 0x00, 0x35, 0xd5, 0xe4,
		0x34, 0x92, 0x1f, 0x1e, 0xd1, 0xae, 0xe9, 0xf5, 0x7a, 0x01, 0xa6, 0x12, 0x18, 0x73, 0x66, 0x11,
		0x40, 0x9a, 0x80, 0x34, 0x33, 0x43, 0x9a, 0x02, 0xcc, 0xab, 0x90, 0x89, 0x01, 0x75, 0x02, 0xea,
		0xdc, 0x02, 0xd4, 0xe9, 0x10, 0x5a, 0x3e, 0x95, 0x40, 0x9b, 0x15, 0x81, 0x5b, 0x3f, 0x5b, 0xe4,
		0x61, 0x23, 0x03, 0x07, 0x6e, 0x1c, 0x22, 0xdf, 0xe5, 0x1f, 0x55, 0xf8, 0x44, 0x95, 0x48, 0xa5,
		0x92, 0x64, 0x2f, 0xfe, 0x07, 0xdf, 0xea, 0x86, 0x38, 0xe2, 0xd2, 0x79, 0x70, 0x78, 0xfb, 0x36,
		0x97, 0xef, 0x2a, 0x7e, 0xb0, 0xa8, 0xf3, 0x88, 0x59, 0xea, 0x10, 0x14, 0xf2, 0xe1, 0x3c, 0x91,
		0xad, 0xa7, 0xbd, 0x21, 0x32, 0x7b, 0x8f, 0xaa, 0xbc, 0x6e, 0x10, 0xbf, 0xab, 0xb3, 0x15, 0x0e,
		0x61, 0xf6, 0xb0, 0x7a, 0xc6, 0xa6, 0xe7, 0xa2, 0x6d, 0x40, 0x7d, 0x2d, 0xf2, 0xfc, 0x9b, 0x1b,
		0x99, 0x24, 0xa3, 0xd5, 0x25, 0xe2, 0xd6, 0x65, 0xb3, 0x10, 0x4b, 0xfe, 0xed, 0x22, 0x5a, 0x40,
		0x26, 0xed, 0x96, 0x9c, 0x1e, 0x93, 0x96, 0x78, 0x5b, 0x7b, 0x14, 0x48, 0x0a, 0x06, 0x84, 0xd4,
		0x9b, 0xca, 0xd4, 0x5b, 0x2a, 0x26, 0x62, 0x6f, 0x76, 0x4c, 0x09, 0xa9, 0xbd, 0x28, 0x28, 0x43,
		0x60, 0x9f, 0x2b, 0xc0, 0x91, 0x7e, 0x1b, 0x9f, 0x45, 0x76, 0x56, 0x9f, 0x3d, 0x7c, 0xec, 0x9a,
		0xf4, 0x3c, 0x7f, 0x10, 0x57, 0x6a, 0xbd, 0xb7, 0x02, 0x8c, 0x0e, 0x6f, 0xae, 0xdf, 0x17, 0xa2,
		0xa1, 0xfa, 0xb4, 0x8f, 0x67, 0x3b, 0xdc, 0x99, 0x0f, 0x30, 0x9b, 0xbb, 0xe9, 0xf6, 0xe6, 0xee,
		0xb1, 0x12, 0x9f, 0x3a, 0xf6, 0x1c, 0x5c, 0x30, 0x1d, 0x8d, 0x83, 0x24, 0x93, 0x80, 0xbc, 0xc3,
		0x05, 0xd4, 0xe4, 0x01, 0xf3, 0x43, 0xdd, 0xac, 0x4b, 0x2f, 0x98, 0x74, 0xa6, 0x4d, 0x02, 0xd3,
		0xc7, 0x81, 0xe7, 0x3e, 0xae, 0x69, 0x1a, 0x49, 0x58, 0x75, 0xee, 0x6a, 0x28, 0x5c, 0xc8, 0x7f,
		0xe1, 0x82, 0x17, 0x95, 0xa6, 0x06, 0xec, 0x75, 0x0b, 0x93, 0x1b, 0x60, 0x30, 0x3e, 0x94, 0x2d,
		0x58, 0x94, 0xe2, 0xc1, 0x90, 0x06, 0x02, 0x4d, 0x39, 0x93, 0x3b, 0x59, 0xc3, 0x86, 0x71, 0x09,
		0x23, 0x57, 0x94, 0xc1, 0xa8, 0xb0, 0xf9, 0x01, 0x1d, 0x18, 0x1e, 0x00, 0x61, 0x6c, 0x4e, 0xef,
		0x56, 0x7c, 0x78, 0xc0, 0xc8, 0x21, 0xf4, 0x4c, 0x60, 0x6e, 0x00, 0xcf, 0xd8, 0x2e, 0xb1, 0x88,
		0x9c, 0x40, 0xd8, 0x51, 0x26, 0x02, 0x37, 0x0d, 0x0a, 0x09, 0x06, 0x73, 0x55, 0x45, 0x82, 0xe4,
		0x23, 0x40, 0x02, 0xf1, 0x35, 0xa9, 0xb8, 0x5a, 0x42, 0xba, 0x4a, 0xad, 0xb6, 0xfd, 0xc4, 0xdb,
		0x6c, 0x96, 0x58, 0x59, 0x86, 0xd5, 0x1b, 0x09, 0x66, 0x55, 0xc3, 0x1b, 0x75, 0x9a, 0xc1, 0x1a,
		0x98, 0x41, 0x30, 0x83, 0x60, 0x06, 0xc1, 0x0c, 0x82, 0x19, 0x04, 0x33, 0x28, 0x6e, 0x06, 0x73,
		0x96, 0x0b, 0x99, 0x8d, 0x34, 0x15, 0xd9, 0x82, 0x12, 0x4c, 0x49, 0x86, 0x4b, 0x12, 0x7c, 0x1e,
		0x2f, 0xfb, 0xed, 0xd3, 0x78, 0x59, 0x0d, 0x83, 0x59, 0x02, 0x6c, 0xf9, 0xdd, 0x3e, 0x7b, 0xd8,
		0x65, 0x7c, 0x3d, 0x8c, 0x5c, 0x81, 0x91, 0x2b, 0xd3, 0x60, 0xab, 0x37, 0xb0, 0x1c, 0xc2, 0x5a,
		0xbf, 0xca, 0x33, 0x80, 0xce, 0xf8, 0x88, 0xc9, 0x43, 0x24, 0x7b, 0xca, 0x67, 0x10, 0x88, 0xd8,
		0x4a, 0x51, 0x1b, 0x29, 0xad, 0xde, 0xc5, 0xd5, 0xfa, 0x0b, 0xdf, 0xc8, 0x6e, 0x71, 0x92, 0x54,
		0x6a, 0x27, 0xdb, 0x43, 0x14, 0x55, 0x6d, 0xd8, 0x0c, 0x1c, 0xcc, 0x3b, 0x3a, 0xd1, 0x38, 0x3c,
		0x3c, 0x9c, 0x4e, 0x2a, 0xfc, 0xd6, 0x99, 0xf9, 0x3f, 0xed, 0xb6, 0xf9, 0xad, 0x53, 0xf8, 0x51,
		0x3a, 0x3a, 0x2d, 0xbf, 0xcc, 0x8e, 0x38, 0xec, 0xb4, 0xdb, 0xc7, 0x85, 0x37, 0x22, 0x77, 0xbd,
		0x2b, 0xfc, 0x6c, 0xb7, 0x19, 0xba, 0xdd, 0x3b, 0x30, 0x05, 0x67, 0x9d, 0x0f, 0x01, 0x53, 0x70,
		0x34, 0xc5, 0x33, 0xf8, 0xa7, 0xe0, 0x08, 0x82, 0x20, 0xff, 0x91, 0x67, 0x14, 0xdd, 0xf8, 0x7a,
		0x48, 0x3d, 0x41, 0xea, 0x09, 0x26, 0xb0, 0x43, 0x9c, 0x6b, 0x1b, 0xe2, 0x5c, 0xdb, 0x31, 0x81,
		0x9d, 0x4e, 0xce, 0xc7, 0x10, 0x88, 0x60, 0x27, 0xb7, 0xf2, 0xc9, 0x55, 0x0d, 0xe4, 0x0a, 0xe4,
		0x4a, 0xe0, 0x40, 0x48, 0xfe, 0x0e, 0xa2, 0x91, 0x3d, 0x34, 0x2d, 0x62, 0x9b, 0xb4, 0x3b, 0x14,
		0xef, 0x1c, 0x9a, 0x5d, 0x44, 0xac, 0x63, 0xa8, 0x0a, 0x1d, 0x43, 0xda, 0x05, 0x43, 0x99, 0x80,
		0xc8, 0x0b, 0x8a, 0x60, 0x5c, 0x97, 0x73, 0xaf, 0x79, 0x85, 0x41, 0x89, 0x50, 0x28, 0x14, 0x0e,
		0x4e, 0xd0, 0xae, 0x5c, 0x58, 0x54, 0x08, 0x8d, 0x22, 0xe1, 0x51, 0x25, 0x44, 0xca, 0x85, 0x49,
		0xb9, 0x50, 0xa9, 0x13, 0x2e, 0x31, 0x21, 0x13, 0x14, 0x36, 0x69, 0xa1, 0x4b, 0x16, 0xb0, 0x6c,
		0xdb, 0xc7, 0x41, 0x20, 0xbf, 0xc5, 0x49, 0x39, 0xdd, 0x78, 0x41, 0xc9, 0xfd, 0x10, 0xeb, 0x6d,
		0x55, 0x2e, 0x8c, 0x2a, 0x85, 0x52, 0xb1, 0x70, 0xaa, 0x16, 0x52, 0x6d, 0xc2, 0xaa, 0x4d, 0x68,
		0xd5, 0x0b, 0xaf, 0x9c, 0x10, 0x4b, 0x0a, 0xb3, 0x0c, 0x14, 0x55, 0xe7, 0x2e, 0xa6, 0x72, 0xad,
		0x33, 0x34, 0xd5, 0xc8, 0xf8, 0x9c, 0xb1, 0x3d, 0x57, 0xb0, 0xd6, 0xf8, 0x5d, 0xbf, 0x2a, 0x61,
		0x2a, 0x35, 0xc2, 0xf4, 0x8a, 0x72, 0x8f, 0x55, 0x85, 0xb4, 0x5b, 0x74, 0xd3, 0x15, 0xae, 0x29,
		0x7a, 0xdc, 0x53, 0xea, 0xc2, 0x87, 0x87, 0x5f, 0x4b, 0xe6, 0x79, 0xe7, 0xe7, 0xd7, 0xb2, 0x79,
		0xde, 0x89, 0x3f, 0x96, 0xa3, 0xff, 0xc4, 0x9f, 0x2b, 0x5f, 0x4b, 0x66, 0x75, 0xf2, 0xb9, 0xf6,
		0xb5, 0x64, 0xd6, 0x3a, 0x85, 0x76, 0xfb, 0xb8, 0xf0, 0xe3, 0xe4, 0x85, 0xff, 0xc6, 0xc3, 0xbf,
		0x1f, 0xff, 0x5a, 0x78, 0x67, 0x28, 0x7b, 0x81, 0x8e, 0x92, 0x95, 0x5e, 0x8e, 0x72, 0xcc, 0xa0,
		0xa7, 0xc0, 0xa0, 0x87, 0xf5, 0x9f, 0x21, 0x1b, 0x59, 0x66, 0xaf, 0x61, 0x7e, 0xe8, 0xfc, 0x28,
		0x1d, 0x55, 0x5f, 0x0a, 0xf5, 0xc2, 0xe1, 0xeb, 0xef, 0xea, 0x85, 0x1f, 0xa5, 0xa3, 0xda, 0xcb,
		0xe1, 0xe1, 0x92, 0xbf, 0xbc, 0x5b, 0xb6, 0x46, 0xe1, 0xe7, 0xe1, 0xe1, 0xe1, 0x98, 0x35, 0xe7,
		0xd8, 0xf5, 0x6b, 0xa9, 0xdc, 0x79, 0x17, 0x7d, 0x8c, 0xff, 0x4d, 0x18, 0x9e, 0xe9, 0xe2, 0x42,
		0xe1, 0xf0, 0xef, 0x5f, 0x1b, 0xe6, 0xbf, 0x2d, 0xf3, 0xaf, 0x48, 0x1a, 0x92, 0x8f, 0xed, 0xb6,
		0xd9, 0x6e, 0x1f, 0x7f, 0xfb, 0xbf, 0x62, 0xe7, 0x4d, 0xe1, 0x9d, 0xc2, 0xed, 0x9c, 0x88, 0xf1,
		0xff, 0xd6, 0x3b, 0xbf, 0xd6, 0x0b, 0x3f, 0x4e, 0x5f, 0x26, 0x9f, 0xa3, 0x7f, 0x0b, 0x3f, 0x0f,
		0x8f, 0xdf, 0xb4, 0xdb, 0xc7, 0xc7, 0x6f, 0x0a, 0xf1, 0x1b, 0x8f, 0xaf, 0x7b, 0x13, 0xff, 0xf5,
		0x5d, 0xbd, 0xbe, 0xf0, 0x55, 0x5e, 0xe5, 0xf4, 0x60, 0xb3, 0xcf, 0xf1, 0xb2, 0x91, 0x21, 0x0b,
		0x5c, 0xa1, 0xd7, 0x54, 0x8d, 0xc2, 0x11, 0x8d, 0x5d, 0xed, 0xe3, 0x08, 0x54, 0x1a, 0xaf, 0x5c,
		0xac, 0x76, 0x22, 0xc7, 0x66, 0x1d, 0xf0, 0x6b, 0xc0, 0xaf, 0x01, 0xbf, 0x26, 0x27, 0xbe, 0x48,
		0xa8, 0x5e, 0x4c, 0x32, 0x1a, 0xdc, 0x33, 0x57, 0x5f, 0xb0, 0x08, 0xe7, 0xa9, 0x82, 0xa5, 0xe4,
		0x26, 0x11, 0x69, 0xc4, 0x7a, 0x2a, 0x26, 0x15, 0x2d, 0x2c, 0x3a, 0xa9, 0x00, 0x2b, 0x29, 0x46,
		0x19, 0xaa, 0x27, 0xec, 0x2c, 0x32, 0x92, 0xaa, 0x89, 0x3b, 0x9a, 0x40, 0x3e, 0x52, 0x35, 0xf7,
		0x68, 0xe5, 0x96, 0x9d, 0xd6, 0x6a, 0x27, 0x35, 0xd8, 0x36, 0x65, 0x98, 0x2f, 0x17, 0xc8, 0x51,
		0x52, 0x51, 0x4b, 0x4c, 0xd0, 0x5d, 0xb9, 0xa6, 0xc4, 0x64, 0xdd, 0x0c, 0x3d, 0x60, 0x9b, 0x04,
		0xe6, 0xc8, 0x1e, 0x9a, 0xb4, 0x3b, 0x34, 0x15, 0x60, 0x57, 0x9d, 0x78, 0x66, 0x19, 0xae, 0x91,
		0x1e, 0xde, 0x9b, 0x39, 0xc6, 0x59, 0x8a, 0x75, 0x16, 0x76, 0x01, 0xe4, 0x5b, 0x95, 0x67, 0x98,
		0x69, 0x76, 0x4a, 0xa1, 0x1e, 0xe1, 0x18, 0x67, 0xa4, 0x5f, 0x6d, 0xcc, 0x8d, 0x43, 0x2a, 0x97,
		0x4e, 0x6a, 0x75, 0x74, 0x19, 0x35, 0x40, 0xa0, 0xf0, 0x0f, 0x01, 0x32, 0xd1, 0xf5, 0x60, 0x18,
		0x97, 0x23, 0xc7, 0x73, 0x7b, 0x2c, 0x62, 0xcf, 0xcd, 0xdc, 0x19, 0xe2, 0xae, 0xd3, 0x1b, 0x1f,
		0xde, 0xd3, 0x26, 0xe1, 0x2a, 0xb5, 0xf3, 0xd3, 0xd3, 0x3a, 0xba, 0xbc, 0x6d, 0xa2, 0xd6, 0xa4,
		0x8a, 0x09, 0x79, 0x8f, 0xd8, 0x47, 0xad, 0x8b, 0xbb, 0x85, 0xf5, 0x66, 0xd7, 0xfa, 0x8c, 0xff,
		0xbf, 0x91, 0xe3, 0x8f, 0x4b, 0x9f, 0xf3, 0xed, 0x75, 0xf1, 0x0e, 0x55, 0xca, 0x87, 0xe3, 0x95,
		0xb7, 0x3d, 0xde, 0xb4, 0x13, 0x78, 0x90, 0xad, 0xce, 0x13, 0xd5, 0x3d, 0x82, 0x43, 0x1f, 0x17,
		0xd6, 0xe1, 0x6c, 0xff, 0x8b, 0xeb, 0xc2, 0x8b, 0x49, 0x29, 0x62, 0x71, 0xa6, 0x20, 0xa5, 0x28,
		0x5f, 0x9c, 0x82, 0x78, 0xfb, 0x06, 0x9b, 0xd1, 0xf3, 0x7c, 0xfb, 0x62, 0x0f, 0x1b, 0xc4, 0x6e,
		0x75, 0x87, 0x46, 0x46, 0x93, 0x41, 0xf5, 0xd6, 0x1a, 0x49, 0x6e, 0xae, 0xca, 0x4d, 0x35, 0xf6,
		0x7c, 0x04, 0xea, 0x5a, 0x42, 0xe5, 0x63, 0xfa, 0xe9, 0x3f, 0xf1, 0x33, 0x63, 0xc5, 0x3d, 0xf4,
		0x29, 0xc9, 0x21, 0x01, 0xe8, 0x53, 0xda, 0xec, 0x69, 0xdd, 0x33, 0x34, 0xd7, 0x78, 0x66, 0x37,
		0x07, 0x13, 0x21, 0x45, 0xb5, 0xe9, 0x42, 0xcc, 0x84, 0x94, 0xd7, 0xa7, 0xb3, 0x33, 0x15, 0xca,
		0xee, 0xa8, 0xdf, 0xcd, 0xce, 0x3b, 0x60, 0x6a, 0x84, 0x13, 0x84, 0x2d, 0xdb, 0x36, 0x56, 0x9a,
		0x61, 0xe4, 0x28, 0x2f, 0x25, 0x64, 0x66, 0x4c, 0xf7, 0xbd, 0x80, 0xae, 0x6d, 0x4e, 0x4b, 0x24,
		0x3a, 0xb9, 0x12, 0xa6, 0x4c, 0x6f, 0xd1, 0x94, 0x69, 0xb6, 0xa1, 0x0b, 0x2c, 0xd5, 0x37, 0xac,
		0x43, 0x16, 0xd8, 0x30, 0x11, 0x3b, 0x2c, 0xe1, 0x1c, 0xa6, 0x20, 0x9c, 0x58, 0xe0, 0x4f, 0x18,
		0xbc, 0xb0, 0x81, 0x39, 0xfe, 0x57, 0x65, 0x1e, 0x92, 0x90, 0xe5, 0xcb, 0x8a, 0x0e, 0x73, 0x5e,
		0xc3, 0x51, 0xac, 0xf5, 0x59, 0xb9, 0x1a, 0x76, 0x20, 0x33, 0x9d, 0xda, 0xf5, 0xba, 0xeb, 0x8d,
		0x48, 0x22, 0xb7, 0xc9, 0x95, 0xa0, 0x6d, 0x61, 0xa6, 0x3f, 0xcc, 0xf4, 0x7f, 0x0e, 0x3e, 0x7a,
		0xa9, 0x27, 0xe2, 0x8b, 0x3a, 0x13, 0x30, 0xd4, 0x7f, 0x86, 0xbc, 0xb9, 0x9c, 0xea, 0x4f, 0xe8,
		0x30, 0x5d, 0x65, 0x86, 0x17, 0xc1, 0x0c, 0xff, 0xfc, 0xcf, 0xf0, 0xc7, 0x24, 0x54, 0x62, 0x36,
		0xfb, 0x1c, 0x95, 0xc9, 0x0d, 0x69, 0xc3, 0x38, 0x38, 0x6a, 0x40, 0x8d, 0x90, 0x3e, 0xeb, 0x79,
		0xbd, 0x03, 0xc3, 0xeb, 0x60, 0x78, 0x5d, 0x42, 0xe9, 0x7b, 0xcf, 0x73, 0xb1, 0x45, 0x78, 0x06,
		0xd7, 0x95, 0x61, 0x04, 0x11, 0xb0, 0x72, 0x8e, 0x4e, 0xbf, 0x08, 0x02, 0xaf, 0xeb, 0x44, 0x46,
		0xde, 0xa4, 0x3c, 0x55, 0xb6, 0xd3, 0xb6, 0xdd, 0xd7, 0x2b, 0xe8, 0x1c, 0x03, 0x1e, 0x30, 0x44,
		0xf7, 0x18, 0x55, 0x35, 0xa7, 0xca, 0xe6, 0xe6, 0x77, 0x11, 0xbe, 0x17, 0xe4, 0x7f, 0x95, 0xf1,
		0x72, 0x98, 0x91, 0x24, 0xb6, 0x53, 0x98, 0x8c, 0x06, 0xd8, 0x67, 0x75, 0x46, 0x16, 0x94, 0x2c,
		0xc7, 0x60, 0x15, 0xe3, 0x8a, 0x8c, 0x06, 0xfc, 0x7b, 0xdc, 0xf2, 0x9a, 0xb1, 0x1f, 0x2a, 0x94,
		0xf7, 0x2e, 0x31, 0xdb, 0x8d, 0xa5, 0xb7, 0x97, 0x23, 0xd6, 0xc2, 0x62, 0x37, 0x57, 0xe2, 0x82,
		0x7d, 0xcf, 0x35, 0xf4, 0x1e, 0x5c, 0xec, 0x5d, 0x13, 0xb1, 0x06, 0xa6, 0xf8, 0xcd, 0x84, 0x5a,
		0xae, 0xe3, 0xf7, 0x12, 0x3b, 0xb3, 0x38, 0x31, 0xfb, 0xa5, 0xcd, 0x56, 0x12, 0x28, 0x09, 0x89,
		0x3a, 0xf7, 0x23, 0x3f, 0x10, 0x18, 0xdd, 0x35, 0xbe, 0x4f, 0xa7, 0xd1, 0x89, 0x42, 0xa1, 0x60,
		0x73, 0xc0, 0xe6, 0xe4, 0xcd, 0xe6, 0xb0, 0xbb, 0x1f, 0x9c, 0x6e, 0x88, 0x5a, 0xd1, 0x86, 0x31,
		0x97, 0x20, 0x4e, 0xdb, 0x20, 0x4e, 0xdb, 0x31, 0xe6, 0x72, 0x18, 0x05, 0xa3, 0xf9, 0xe5, 0x69,
		0x7c, 0x1f, 0x18, 0x4a, 0x90, 0x6c, 0x30, 0x94, 0xf9, 0x34, 0x94, 0x30, 0xc1, 0x16, 0x04, 0x6b,
		0x13, 0x82, 0x95, 0xd5, 0x04, 0x5b, 0xa9, 0xc9, 0xb5, 0x30, 0xb1, 0x56, 0xb5, 0x00, 0x28, 0x13,
		0x04, 0x65, 0x02, 0x21, 0x2f, 0x18, 0xfc, 0x41, 0x0e, 0x94, 0xf1, 0xc4, 0x5a, 0x25, 0x93, 0x6a,
		0x61, 0x42, 0x2d, 0x4c, 0xa8, 0xcd, 0x4e, 0x98, 0xc4, 0x84, 0x4a, 0x50, 0xb8, 0xa4, 0x85, 0x2c,
		0x59, 0x00, 0x26, 0xd4, 0x66, 0x26, 0x94, 0x8a, 0x85, 0x53, 0xb5, 0x90, 0x6a, 0x13, 0x56, 0x6d,
		0x42, 0xab, 0x5e, 0x78, 0xe5, 0x84, 0x58, 0x52, 0x98, 0x65, 0xa0, 0xa6, 0x3a, 0x7f, 0x30, 0x95,
		0x6b, 0xfb, 0x5e, 0x40, 0x61, 0x36, 0x2d, 0x1f, 0xcd, 0x94, 0x4e, 0xf5, 0xd5, 0x41, 0x41, 0x3d,
		0x94, 0x54, 0x4f, 0xd1, 0x25, 0x94, 0xd5, 0x32, 0xf5, 0x77, 0x31, 0x7a, 0xa9, 0x61, 0x6d, 0x5d,
		0x43, 0x56, 0x93, 0x1f, 0xd8, 0xe6, 0x69, 0xc0, 0x49, 0x10, 0x54, 0xe9, 0x8a, 0x2f, 0x47, 0x5b,
		0xc4, 0xd8, 0xa7, 0xc0, 0xd8, 0x2b, 0x19, 0x1b, 0xa6, 0x08, 0x73, 0xa9, 0x81, 0xfc, 0x4e, 0x13,
		0xd6, 0x24, 0xe7, 0x30, 0x95, 0x9c, 0x03, 0xce, 0x99, 0x1c, 0x79, 0xe4, 0x4d, 0x29, 0x17, 0xde,
		0x93, 0xaa, 0x37, 0xa8, 0xc2, 0x75, 0x0c, 0x01, 0x4d, 0x16, 0x4f, 0x3a, 0x1d, 0x35, 0x29, 0x0b,
		0xdd, 0xd3, 0x25, 0xa7, 0x0c, 0xa8, 0x6b, 0xca, 0xa4, 0x26, 0x5b, 0x8f, 0x74, 0x0d, 0x0b, 0x5d,
		0xdc, 0x5a, 0xde, 0x93, 0xbe, 0xf7, 0x71, 0x73, 0xf3, 0x6a, 0x2e, 0xb6, 0xe3, 0x10, 0x86, 0xcc,
		0x9b, 0x82, 0x15, 0xcf, 0xb3, 0x9c, 0xfb, 0xed, 0x76, 0xfb, 0xb8, 0xf3, 0x2b, 0x9c, 0x6f, 0xa0,
		0xea, 0xf7, 0xe1, 0x7c, 0x83, 0x95, 0x8b, 0x95, 0x2b, 0x70, 0xc0, 0xc1, 0xbc, 0x8a, 0x82, 0xb0,
		0xb8, 0xf4, 0xc2, 0x10, 0x16, 0xe7, 0x0a, 0x4d, 0xc2, 0x01, 0x07, 0x9b, 0x74, 0x1b, 0xe1, 0x80,
		0x83, 0x4c, 0x60, 0x2e, 0x1c, 0x70, 0x00, 0x07, 0x1c, 0x6c, 0x0e, 0x3a, 0xc2, 0x01, 0x07, 0x82,
		0x06, 0x85, 0xd0, 0x61, 0x34, 0x5a, 0x1f, 0x0e, 0x37, 0xc8, 0x00, 0xdf, 0x2c, 0xc5, 0x39, 0x73,
		0x3b, 0x00, 0x72, 0xad, 0xca, 0x25, 0xdc, 0xd1, 0xe1, 0xe2, 0x84, 0x0e, 0x97, 0x8e, 0x9f, 0x2e,
		0x8a, 0x97, 0x0f, 0x22, 0x96, 0x11, 0x94, 0xb7, 0x74, 0x38, 0x33, 0x3b, 0x1c, 0xa6, 0x86, 0xcb,
		0xed, 0xd6, 0xbe, 0x0f, 0x09, 0x5f, 0x46, 0x17, 0x98, 0x0d, 0xbe, 0x88, 0x82, 0xd5, 0xce, 0x06,
		0x27, 0x23, 0xd7, 0x15, 0x98, 0x5c, 0x9d, 0x0e, 0x38, 0xb3, 0x1f, 0x39, 0x3c, 0x65, 0x20, 0x15,
		0x93, 0x86, 0xa7, 0xca, 0x2d, 0x9b, 0x09, 0xc3, 0x3c, 0x23, 0xfe, 0x38, 0x60, 0x24, 0xc7, 0x04,
		0x9e, 0xd5, 0xf3, 0xd3, 0x64, 0x50, 0x9c, 0x14, 0x3a, 0x53, 0x33, 0x85, 0x27, 0x7c, 0xb1, 0x8d,
		0xcc, 0x37, 0x1d, 0xfa, 0x38, 0x50, 0x3d, 0x89, 0xf1, 0x2a, 0x1a, 0x86, 0x16, 0x20, 0xda, 0xc7,
		0xe8, 0xb6, 0x75, 0x87, 0xba, 0xae, 0x83, 0x09, 0x45, 0x23, 0xe2, 0xe2, 0x20, 0xfe, 0xf6, 0x97,
		0xf1, 0xbc, 0xb4, 0x5f, 0x90, 0x8b, 0xad, 0x5e, 0x9b, 0x1c, 0x7e, 0xef, 0x3b, 0xdd, 0x3e, 0xb2,
		0xe3, 0x10, 0x72, 0x80, 0xa8, 0x87, 0x7e, 0x09, 0x29, 0xf9, 0x4b, 0x01, 0x39, 0x01, 0x0a, 0x30,
		0x8d, 0xbe, 0x89, 0x24, 0xfa, 0x17, 0xfd, 0x23, 0x98, 0x82, 0xcc, 0x87, 0x2b, 0x6a, 0xa6, 0x58,
		0xd6, 0x03, 0x13, 0xb5, 0x4f, 0x28, 0x5f, 0xaf, 0x07, 0x58, 0x14, 0xa7, 0xcc, 0x40, 0x72, 0xdf,
		0xb2, 0x9d, 0x51, 0x90, 0x3e, 0xed, 0x71, 0x7c, 0x1d, 0x0c, 0x7c, 0xcc, 0xff, 0xc0, 0x47, 0x6f,
		0x18, 0xb2, 0x65, 0xc0, 0x3e, 0xb5, 0x6e, 0x72, 0x03, 0x8c, 0xad, 0x83, 0xb1, 0x75, 0x16, 0xa5,
		0x78, 0x30, 0xa4, 0x81, 0xc0, 0xb8, 0xba, 0xc9, 0x9d, 0x3a, 0x07, 0x21, 0x54, 0x60, 0x08, 0x82,
		0xda, 0x68, 0x1f, 0xf4, 0x6a, 0x4f, 0x1e, 0x43, 0x7c, 0x08, 0xc2, 0xc8, 0x21, 0xf4, 0x4c, 0x60,
		0x04, 0x02, 0x47, 0x0a, 0x44, 0x30, 0xb7, 0x27, 0x10, 0x51, 0x91, 0xc9, 0xd5, 0xf1, 0x1e, 0x1e,
		0xb1, 0x70, 0xbf, 0xaa, 0x24, 0x8e, 0x7c, 0xb2, 0x46, 0x20, 0x0c, 0x29, 0x95, 0x33, 0x9b, 0xa9,
		0xe3, 0xab, 0x6d, 0x3f, 0xf1, 0x34, 0xc5, 0xd6, 0x3a, 0x59, 0x8e, 0x0c, 0x71, 0x06, 0xd8, 0x1b,
		0x89, 0x0c, 0x0c, 0x19, 0xdf, 0xa8, 0xd3, 0x0c, 0xd6, 0xc0, 0x0c, 0x82, 0x19, 0x04, 0x33, 0x08,
		0x66, 0x10, 0xcc, 0x20, 0x98, 0x41, 0x71, 0x33, 0x98, 0xb3, 0x8c, 0x42, 0x1c, 0x63, 0x2a, 0xb2,
		0x85, 0x23, 0x98, 0x82, 0x63, 0x9f, 0xa3, 0x15, 0xbf, 0x7d, 0x1a, 0xaf, 0x08, 0x27, 0x04, 0x40,
		0xa8, 0x25, 0x47, 0xa1, 0x96, 0x11, 0xed, 0x63, 0x42, 0xc7, 0xe7, 0xd1, 0x8b, 0x1e, 0x12, 0xb0,
		0x64, 0x11, 0x9d, 0xc8, 0x33, 0x96, 0x51, 0x73, 0x68, 0x0d, 0x01, 0x82, 0x02, 0x04, 0xcd, 0x1b,
		0x04, 0x75, 0xec, 0x50, 0x16, 0xe8, 0xb3, 0x8f, 0x7b, 0x22, 0x23, 0x29, 0x79, 0x90, 0xe8, 0xf5,
		0xf8, 0xa7, 0xde, 0x5b, 0x01, 0x16, 0x1f, 0xbf, 0x37, 0x16, 0x27, 0x71, 0x29, 0x9e, 0x07, 0x4e,
		0x81, 0x50, 0x9d, 0xa3, 0xe4, 0xd4, 0xb4, 0xf1, 0x3b, 0x74, 0xfb, 0x96, 0x40, 0x51, 0x92, 0x00,
		0xc0, 0x54, 0xf3, 0xb8, 0x43, 0xa1, 0xa7, 0xe5, 0xba, 0xa3, 0x93, 0xcb, 0xf3, 0x00, 0x60, 0x68,
		0x38, 0xe8, 0xf2, 0x6d, 0xd0, 0xe5, 0xdb, 0x31, 0x34, 0x1c, 0x26, 0x0b, 0x83, 0x5c, 0x6d, 0x42,
		0xae, 0x60, 0xb2, 0xb0, 0x38, 0xa3, 0xcb, 0x30, 0xbc, 0x24, 0xe3, 0xcb, 0x0a, 0x80, 0x32, 0x41,
		0x50, 0x26, 0x10, 0xf2, 0x82, 0x21, 0x18, 0x2e, 0x83, 0xc9, 0xc2, 0x5a, 0x85, 0x43, 0x85, 0x90,
		0x28, 0x12, 0x16, 0x55, 0x42, 0xa3, 0x5c, 0x78, 0x94, 0x0b, 0x91, 0x3a, 0x61, 0x12, 0x13, 0x2a,
		0x09, 0xaf, 0x0c, 0xc1, 0x64, 0x61, 0xfd, 0xc2, 0xa8, 0x52, 0x28, 0x15, 0x0b, 0xa7, 0x6a, 0x21,
		0xd5, 0x26, 0xac, 0xda, 0x84, 0x56, 0xbd, 0xf0, 0xca, 0x09, 0xb1, 0xa4, 0x30, 0xcb, 0x40, 0x4d,
		0x75, 0xee, 0x60, 0x2a, 0xd7, 0xc2, 0x64, 0x61, 0x7e, 0x9a, 0xc1, 0x64, 0x61, 0xc5, 0xff, 0x83,
		0xc9, 0xc2, 0x2c, 0x3f, 0x00, 0x93, 0x85, 0x15, 0xab, 0xe6, 0x6c, 0x19, 0x1b, 0x26, 0x0b, 0xaf,
		0x66, 0x6c, 0x98, 0x2c, 0xcc, 0xa5, 0x06, 0x60, 0xb2, 0xf0, 0x66, 0x9f, 0x0b, 0x26, 0x0b, 0x4b,
		0xaf, 0x09, 0x93, 0x85, 0x11, 0x4c, 0x16, 0xde, 0xa0, 0xad, 0x47, 0x30, 0x59, 0x38, 0x4f, 0x9b,
		0x0b, 0x93, 0x85, 0x65, 0x00, 0x01, 0x4c, 0x16, 0xd6, 0x6e, 0xf1, 0xf7, 0x72, 0xb2, 0xf0, 0xab,
		0xba, 0x2a, 0xb5, 0x83, 0x86, 0x97, 0x2d, 0x9e, 0xab, 0xb9, 0xc3, 0x67, 0xe5, 0x0a, 0x0c, 0x1e,
		0x9e, 0xd3, 0x60, 0x10, 0x35, 0x97, 0x5e, 0x18, 0xa2, 0xe6, 0x5c, 0x91, 0x4b, 0x18, 0x3c, 0xbc,
		0x49, 0xaf, 0x12, 0x06, 0x0f, 0x67, 0x82, 0x82, 0x61, 0xf0, 0x30, 0x0c, 0x1e, 0xde, 0x33, 0x64,
		0x19, 0xf4, 0x2d, 0x1f, 0xdb, 0x66, 0x80, 0xbb, 0x3e, 0x56, 0x88, 0x29, 0xe7, 0x97, 0x05, 0xf8,
		0x05, 0xf0, 0x0b, 0xe0, 0x97, 0xa0, 0x19, 0xc9, 0x73, 0xd1, 0x02, 0x77, 0x6d, 0x7b, 0x9a, 0x8c,
		0x33, 0xd6, 0xbc, 0xeb, 0xa2, 0xf6, 0xd5, 0x13, 0x0d, 0x94, 0xe0, 0x3f, 0xf5, 0xe2, 0x47, 0xac,
		0xee, 0xa0, 0x3e, 0x1e, 0x2d, 0x68, 0xda, 0x98, 0x3c, 0x9b, 0x96, 0xeb, 0xea, 0x91, 0xc6, 0xc8,
		0x3a, 0x6b, 0x10, 0xc7, 0x4d, 0xcb, 0x62, 0x27, 0x87, 0xa3, 0xfd, 0x7d, 0xdc, 0xc3, 0x3e, 0xd3,
		0xb0, 0xcf, 0x0d, 0xb8, 0x1d, 0x13, 0x31, 0xff, 0xfc, 0xe1, 0x02, 0x55, 0xce, 0x4e, 0x6b, 0x75,
		0xf4, 0x19, 0x0f, 0x3c, 0x8a, 0x51, 0x63, 0x2e, 0x64, 0x84, 0x2e, 0x1d, 0xcb, 0x45, 0xd7, 0x04,
		0x7d, 0x09, 0xb0, 0xdf, 0x26, 0xd3, 0x05, 0x9a, 0xd8, 0x7f, 0x74, 0xba, 0x18, 0x1d, 0x7e, 0x6e,
		0x5c, 0x5e, 0x7f, 0x69, 0x16, 0xb6, 0xec, 0x54, 0x80, 0xe9, 0xde, 0x6c, 0xf3, 0xa1, 0x00, 0xca,
		0x36, 0x0f, 0xf0, 0xba, 0x2a, 0xbc, 0xbe, 0xa3, 0x07, 0x0a, 0x8c, 0xe7, 0x5e, 0x6c, 0xe2, 0x4c,
		0x81, 0xf1, 0x80, 0x0c, 0x38, 0x56, 0x40, 0xe1, 0x9e, 0xed, 0xfb, 0xc9, 0x02, 0x2b, 0x48, 0x03,
		0x87, 0x0b, 0x2c, 0x46, 0xba, 0xd4, 0x1e, 0x2e, 0xc0, 0xd9, 0x7f, 0x3a, 0x0a, 0x98, 0x03, 0xc9,
		0x22, 0xa8, 0x61, 0x16, 0x11, 0x78, 0xf1, 0x53, 0x9a, 0xf7, 0xcf, 0x3c, 0x4d, 0xa2, 0x32, 0xe6,
		0x7e, 0xce, 0x94, 0x47, 0x6f, 0x9a, 0x61, 0x53, 0xf0, 0xeb, 0xe3, 0x1b, 0xc2, 0x47, 0x97, 0xe2,
		0x5a, 0x01, 0x04, 0x3d, 0x4b, 0x73, 0x56, 0x88, 0x2c, 0x32, 0xf4, 0x2d, 0xe0, 0xca, 0x46, 0xa8,
		0x68, 0xfc, 0x15, 0x62, 0x26, 0xa4, 0xbc, 0xf9, 0x97, 0x9d, 0xa9, 0x90, 0xc2, 0x09, 0x0f, 0x9d,
		0x7c, 0xce, 0xec, 0x52, 0x77, 0x10, 0xc8, 0x1c, 0x22, 0xd9, 0x97, 0xb3, 0x40, 0xd6, 0x4e, 0xd7,
		0x97, 0x91, 0x9f, 0x1c, 0x1c, 0x07, 0x32, 0x7e, 0xb7, 0x9d, 0x3b, 0xb7, 0x21, 0x75, 0xcf, 0x18,
		0x59, 0x9d, 0xf9, 0xf4, 0x86, 0x83, 0x35, 0xef, 0x97, 0xf6, 0x5e, 0xe9, 0xef, 0xb3, 0xe4, 0x45,
		0xd2, 0x5e, 0x60, 0xfe, 0xc9, 0xa7, 0xcf, 0x37, 0xf3, 0x6c, 0x46, 0xbc, 0xb8, 0x19, 0x50, 0x8b,
		0x2e, 0x72, 0xed, 0x6c, 0x14, 0x7f, 0x7a, 0xd5, 0xab, 0x37, 0x5b, 0xde, 0xff, 0x3c, 0xcd, 0x4a,
		0xbc, 0xaa, 0x3c, 0x5d, 0x97, 0x65, 0x48, 0xc9, 0x1a, 0xa4, 0x09, 0x17, 0x73, 0x54, 0x9f, 0x59,
		0x70, 0xd2, 0xa3, 0xee, 0xeb, 0x77, 0x7d, 0x55, 0xbf, 0xad, 0xd1, 0x75, 0xbd, 0xee, 0x9f, 0xe9,
		0xa7, 0x7a, 0xc4, 0x97, 0xc1, 0xa1, 0x1e, 0xf9, 0x3f, 0xd4, 0xe3, 0xde, 0xf3, 0xa8, 0x69, 0x5b,
		0x14, 0x53, 0x87, 0x61, 0x7c, 0x53, 0x42, 0xd7, 0xf9, 0xdb, 0xd8, 0xa6, 0x4e, 0x96, 0x60, 0xea,
		0xa4, 0x62, 0x13, 0x98, 0xc1, 0xd4, 0x49, 0xe6, 0x1c, 0x55, 0x42, 0xe9, 0x90, 0x2b, 0x4c, 0x8b,
		0xd8, 0x26, 0x03, 0x6b, 0x20, 0xce, 0x2e, 0x0a, 0xee, 0x5a, 0x61, 0x23, 0x6a, 0x4c, 0xfa, 0x51,
		0x7d, 0x31, 0x0f, 0xcb, 0x5f, 0x4b, 0x66, 0xa5, 0xf3, 0xb3, 0x14, 0x35, 0xfb, 0x15, 0xcc, 0xc3,
		0xf8, 0xc3, 0xcf, 0xaf, 0x65, 0xb3, 0x32, 0xee, 0x67, 0x3a, 0xf9, 0x5a, 0x32, 0xcb, 0x9d, 0x42,
		0xeb, 0xb0, 0x34, 0xdb, 0x0b, 0x18, 0xb5, 0x3c, 0x9d, 0x74, 0x0a, 0xf5, 0xa8, 0x01, 0x2a, 0xfa,
		0x6a, 0xe6, 0xe3, 0x61, 0xbb, 0x7d, 0x1c, 0x7d, 0xf8, 0xb5, 0xf0, 0xee, 0xf0, 0xdf, 0x3f, 0xbf,
		0xb6, 0xdb, 0xbf, 0xb6, 0xdb, 0x66, 0xe7, 0x30, 0xfa, 0xb9, 0x93, 0xf0, 0xe7, 0xa2, 0xce, 0xa8,
		0xfa, 0xe1, 0xf4, 0x96, 0xc2, 0xcf, 0x72, 0xb5, 0x5e, 0x2a, 0x15, 0x58, 0xda, 0x8b, 0x3a, 0x1a,
		0x46, 0xcb, 0x76, 0x47, 0xbe, 0x8f, 0x89, 0x88, 0xd4, 0x2f, 0xdc, 0x09, 0x82, 0x0f, 0x82, 0x0f,
		0x82, 0x9f, 0x2b, 0xc1, 0xdf, 0x8c, 0xd7, 0x12, 0x43, 0xec, 0xe2, 0x3a, 0xdc, 0xc7, 0x82, 0xfc,
		0x9b, 0xe1, 0x2a, 0xdf, 0x2e, 0xa2, 0x55, 0x24, 0x0e, 0x9f, 0x1b, 0xba, 0x16, 0xed, 0x79, 0xfe,
		0x20, 0x1d, 0xa8, 0x26, 0x57, 0x02, 0x56, 0xcd, 0x3f, 0x56, 0x1d, 0x58, 0xdd, 0xbe, 0x43, 0x38,
		0xec, 0xd5, 0xe4, 0x06, 0x30, 0x53, 0x60, 0xa6, 0xf8, 0x6b, 0xa4, 0x18, 0x6b, 0xa0, 0x74, 0xc4,
		0xd8, 0xf9, 0xab, 0x50, 0x04, 0x42, 0xec, 0xd7, 0x57, 0x57, 0x57, 0xa8, 0x49, 0x6d, 0x54, 0x2e,
		0x95, 0x4e, 0x8e, 0xcb, 0x66, 0xa5, 0x54, 0x3a, 0x43, 0x26, 0x1a, 0xd1, 0x20, 0xd4, 0xcf, 0xc7,
		0x6c, 0xc2, 0xa3, 0x3a, 0x08, 0x2f, 0x5a, 0xe3, 0xa1, 0x36, 0x06, 0xcf, 0x48, 0x9a, 0xbc, 0x45,
		0xe9, 0x85, 0xdc, 0x01, 0x2f, 0x30, 0x99, 0x46, 0x37, 0x4f, 0x8f, 0xf5, 0x0c, 0x58, 0x1a, 0xe9,
		0x41, 0xab, 0x82, 0x56, 0x05, 0xad, 0xba, 0xa0, 0x3a, 0x82, 0xe7, 0x80, 0x73, 0x0a, 0xc5, 0xde,
		0x68, 0xd5, 0x09, 0x69, 0x76, 0x45, 0xab, 0xfa, 0xd8, 0xc5, 0x2c, 0x87, 0x38, 0xcc, 0x2a, 0xd6,
		0xc9, 0x3d, 0xa0, 0x5b, 0x41, 0xb7, 0x82, 0x6e, 0xe5, 0xd4, 0xad, 0x6c, 0xc2, 0xb3, 0x97, 0xba,
		0x75, 0x42, 0x9a, 0x5d, 0xd1, 0xad, 0x8f, 0xd8, 0x0f, 0x58, 0xaa, 0x4d, 0x66, 0x75, 0xeb, 0xe4,
		0x1e, 0xd0, 0xad, 0xa0, 0x5b, 0x41, 0xb7, 0x72, 0xea, 0x56, 0x36, 0xe1, 0xd9, 0x4b, 0xdd, 0x3a,
		0x21, 0xcd, 0xf6, 0xe8, 0x56, 0x6d, 0x55, 0x6c, 0xec, 0x9c, 0xca, 0x21, 0xa2, 0x2b, 0xc8, 0x1f,
		0x3c, 0x07, 0xc5, 0xc9, 0x16, 0xf4, 0x35, 0x6b, 0x4b, 0x5e, 0x3e, 0x54, 0xa3, 0x30, 0x99, 0x5e,
		0x7c, 0xd7, 0xea, 0xdf, 0xc6, 0x99, 0xa4, 0x94, 0xc4, 0x0c, 0x62, 0x4e, 0x26, 0xdd, 0x4d, 0x16,
		0xca, 0x47, 0x39, 0xdc, 0xd2, 0x5a, 0x34, 0xe6, 0xb7, 0x59, 0x59, 0x19, 0x77, 0x30, 0xf3, 0xb0,
		0xab, 0x1e, 0xd2, 0x70, 0x82, 0x0f, 0xd6, 0x9f, 0xf8, 0xb3, 0xe7, 0x2d, 0xf2, 0xe4, 0xeb, 0x07,
		0x37, 0x66, 0xff, 0x34, 0xf7, 0x60, 0x97, 0xf8, 0xd1, 0xe9, 0x8e, 0x1f, 0xe4, 0xe5, 0xe0, 0xe5,
		0xff, 0x07, 0x00, 0x00, 0xff, 0xff, 0x01, 0x00, 0x00, 0xff, 0xff, 0x54, 0x41, 0x93, 0xa6, 0xf2,
		0x0a, 0x09, 0x00,
	}
)


// ΛEnumTypes is a map, keyed by a YANG schema path, of the enumerated types that
// correspond with the leaf. The type is represented as a reflect.Type. The naming
// of the map ensures that there are no clashes with valid YANG identifiers.
func initΛEnumTypes(){
  ΛEnumTypes = map[string][]reflect.Type{
	"/nacm/exec-default": []reflect.Type{
		reflect.TypeOf((E_IETFNetconfAcm_ActionType)(0)),
	},
	"/nacm/read-default": []reflect.Type{
		reflect.TypeOf((E_IETFNetconfAcm_ActionType)(0)),
	},
	"/nacm/rule-list/rule/action": []reflect.Type{
		reflect.TypeOf((E_IETFNetconfAcm_ActionType)(0)),
	},
	"/nacm/write-default": []reflect.Type{
		reflect.TypeOf((E_IETFNetconfAcm_ActionType)(0)),
	},
	"/snmp/notify/type": []reflect.Type{
		reflect.TypeOf((E_IETFSnmp_Snmp_Notify_Type)(0)),
	},
	"/snmp/proxy/type": []reflect.Type{
		reflect.TypeOf((E_IETFSnmp_Snmp_Proxy_Type)(0)),
	},
	"/snmp/target-params/tsm/security-level": []reflect.Type{
		reflect.TypeOf((E_IETFSnmp_SecurityLevel)(0)),
	},
	"/snmp/target-params/usm/security-level": []reflect.Type{
		reflect.TypeOf((E_IETFSnmp_SecurityLevel)(0)),
	},
	"/snmp/target/mms": []reflect.Type{
		reflect.TypeOf((E_IETFSnmp_Snmp_Target_Mms_Enum)(0)),
	},
	"/snmp/tlstm/cert-to-name/map-type": []reflect.Type{
		reflect.TypeOf((E_IETFX509CertToName_CertToName)(0)),
	},
	"/snmp/vacm/group/access/context-match": []reflect.Type{
		reflect.TypeOf((E_IETFSnmp_Snmp_Vacm_Group_Access_ContextMatch)(0)),
	},
	"/snmp/vacm/group/access/security-level": []reflect.Type{
		reflect.TypeOf((E_IETFSnmp_SecurityLevel)(0)),
	},
	"/snmp/vacm/group/access/security-model": []reflect.Type{
		reflect.TypeOf((E_IETFSnmp_SecurityModelOrAny_Enum)(0)),
		reflect.TypeOf((E_IETFSnmp_SecurityModel_Enum)(0)),
	},
	"/snmp/vacm/group/member/security-model": []reflect.Type{
		reflect.TypeOf((E_IETFSnmp_SecurityModel_Enum)(0)),
	},
	"/system/authentication/user-authentication-order": []reflect.Type{
		reflect.TypeOf((E_IETFSystem_AuthenticationMethod)(0)),
	},
	"/system/ntp/server/association-type": []reflect.Type{
		reflect.TypeOf((E_IETFSystem_System_Ntp_Server_AssociationType)(0)),
	},
	"/system/radius/server/authentication-type": []reflect.Type{
		reflect.TypeOf((E_IETFSystem_RadiusAuthenticationType)(0)),
	},
  }
}

